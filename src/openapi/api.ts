/* tslint:disable */
/* eslint-disable */
/**
 * Cosmos SDK - Legacy REST and gRPC Gateway docs
 * A REST interface for state queries, legacy transactions
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BankAccountsAddressTransfersBaseReq
 */
export interface BankAccountsAddressTransfersBaseReq {
    /**
     * Sender address or Keybase name to generate a transaction
     * @type {string}
     * @memberof BankAccountsAddressTransfersBaseReq
     */
    from?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountsAddressTransfersBaseReq
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountsAddressTransfersBaseReq
     */
    chain_id?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountsAddressTransfersBaseReq
     */
    account_number?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountsAddressTransfersBaseReq
     */
    sequence?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountsAddressTransfersBaseReq
     */
    gas?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountsAddressTransfersBaseReq
     */
    gas_adjustment?: string;
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof BankAccountsAddressTransfersBaseReq
     */
    fees?: Array<InlineResponse2004TxFeeAmount>;
    /**
     * Estimate gas for a transaction (cannot be used in conjunction with generate_only)
     * @type {boolean}
     * @memberof BankAccountsAddressTransfersBaseReq
     */
    simulate?: boolean;
}
/**
 * 
 * @export
 * @interface BaseReq
 */
export interface BaseReq {
    /**
     * Sender address or Keybase name to generate a transaction
     * @type {string}
     * @memberof BaseReq
     */
    from?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseReq
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseReq
     */
    chain_id?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseReq
     */
    account_number?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseReq
     */
    sequence?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseReq
     */
    gas?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseReq
     */
    gas_adjustment?: string;
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof BaseReq
     */
    fees?: Array<InlineResponse2004TxFeeAmount>;
    /**
     * Estimate gas for a transaction (cannot be used in conjunction with generate_only)
     * @type {boolean}
     * @memberof BaseReq
     */
    simulate?: boolean;
}
/**
 * Consensus captures the consensus rules for processing a block in the blockchain, including all blockchain data structures and the rules of the application\'s state transition machine.
 * @export
 * @interface BasicBlockInfo
 */
export interface BasicBlockInfo {
    /**
     * 
     * @type {string}
     * @memberof BasicBlockInfo
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicBlockInfo
     */
    app?: string;
}
/**
 * CompactBitArray is an implementation of a space efficient bit array. This is used to ensure that the encoded data takes up a minimal amount of space after proto encoding. This is not thread safe, and is not intended for concurrent usage.
 * @export
 * @interface BitarraySpecifiesWhichKeysWithinTheMultisigAreSigning
 */
export interface BitarraySpecifiesWhichKeysWithinTheMultisigAreSigning {
    /**
     * 
     * @type {number}
     * @memberof BitarraySpecifiesWhichKeysWithinTheMultisigAreSigning
     */
    extra_bits_stored?: number;
    /**
     * 
     * @type {string}
     * @memberof BitarraySpecifiesWhichKeysWithinTheMultisigAreSigning
     */
    elems?: string;
}
/**
 * 
 * @export
 * @interface Block
 */
export interface Block {
    /**
     * 
     * @type {InlineResponse2002BlockMetaHeader}
     * @memberof Block
     */
    header?: InlineResponse2002BlockMetaHeader;
    /**
     * 
     * @type {Array<string>}
     * @memberof Block
     */
    txs?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Block
     */
    evidence?: Array<string>;
    /**
     * 
     * @type {InlineResponse2002BlockLastCommit}
     * @memberof Block
     */
    last_commit?: InlineResponse2002BlockLastCommit;
}
/**
 * 
 * @export
 * @interface BlockHeader
 */
export interface BlockHeader {
    /**
     * 
     * @type {string}
     * @memberof BlockHeader
     */
    chain_id?: string;
    /**
     * 
     * @type {number}
     * @memberof BlockHeader
     */
    height?: number;
    /**
     * 
     * @type {string}
     * @memberof BlockHeader
     */
    time?: string;
    /**
     * 
     * @type {number}
     * @memberof BlockHeader
     */
    num_txs?: number;
    /**
     * 
     * @type {InlineResponse2002BlockMetaHeaderLastBlockId}
     * @memberof BlockHeader
     */
    last_block_id?: InlineResponse2002BlockMetaHeaderLastBlockId;
    /**
     * 
     * @type {number}
     * @memberof BlockHeader
     */
    total_txs?: number;
    /**
     * 
     * @type {string}
     * @memberof BlockHeader
     */
    last_commit_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockHeader
     */
    data_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockHeader
     */
    validators_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockHeader
     */
    next_validators_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockHeader
     */
    consensus_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockHeader
     */
    app_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockHeader
     */
    last_results_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockHeader
     */
    evidence_hash?: string;
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof BlockHeader
     */
    proposer_address?: string;
    /**
     * 
     * @type {InlineResponse2002BlockMetaHeaderVersion}
     * @memberof BlockHeader
     */
    version?: InlineResponse2002BlockMetaHeaderVersion;
}
/**
 * 
 * @export
 * @interface BlockID
 */
export interface BlockID {
    /**
     * 
     * @type {string}
     * @memberof BlockID
     */
    hash?: string;
    /**
     * 
     * @type {InlineResponse2002BlockMetaHeaderLastBlockIdParts}
     * @memberof BlockID
     */
    parts?: InlineResponse2002BlockMetaHeaderLastBlockIdParts;
}
/**
 * 
 * @export
 * @interface BlockID1
 */
export interface BlockID1 {
    /**
     * 
     * @type {string}
     * @memberof BlockID1
     */
    hash?: string;
    /**
     * 
     * @type {PartsetHeader}
     * @memberof BlockID1
     */
    part_set_header?: PartsetHeader;
}
/**
 * 
 * @export
 * @interface BlockQuery
 */
export interface BlockQuery {
    /**
     * 
     * @type {InlineResponse2002BlockMeta}
     * @memberof BlockQuery
     */
    block_meta?: InlineResponse2002BlockMeta;
    /**
     * 
     * @type {InlineResponse2002Block}
     * @memberof BlockQuery
     */
    block?: InlineResponse2002Block;
}
/**
 * TxBody is the body of a transaction that all signers sign over.
 * @export
 * @interface BodyIsTheProcessableContentOfTheTransaction
 */
export interface BodyIsTheProcessableContentOfTheTransaction {
    /**
     * messages is a list of messages to be executed. The required signers of those messages define the number and order of elements in AuthInfo\'s signer_infos and Tx\'s signatures. Each required signer address is added to the list only the first time it occurs.  By convention, the first required signer (usually from the first message) is referred to as the primary signer and pays the fee for the whole transaction.
     * @type {Array<InlineResponseDefaultDetails>}
     * @memberof BodyIsTheProcessableContentOfTheTransaction
     */
    messages?: Array<InlineResponseDefaultDetails>;
    /**
     * 
     * @type {string}
     * @memberof BodyIsTheProcessableContentOfTheTransaction
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyIsTheProcessableContentOfTheTransaction
     */
    timeout_height?: string;
    /**
     * 
     * @type {Array<InlineResponseDefaultDetails>}
     * @memberof BodyIsTheProcessableContentOfTheTransaction
     */
    extension_options?: Array<InlineResponseDefaultDetails>;
    /**
     * 
     * @type {Array<InlineResponseDefaultDetails>}
     * @memberof BodyIsTheProcessableContentOfTheTransaction
     */
    non_critical_extension_options?: Array<InlineResponseDefaultDetails>;
}
/**
 * 
 * @export
 * @interface BroadcastTxCommitResult
 */
export interface BroadcastTxCommitResult {
    /**
     * 
     * @type {InlineResponse2006CheckTx}
     * @memberof BroadcastTxCommitResult
     */
    check_tx?: InlineResponse2006CheckTx;
    /**
     * 
     * @type {InlineResponse2006DeliverTx}
     * @memberof BroadcastTxCommitResult
     */
    deliver_tx?: InlineResponse2006DeliverTx;
    /**
     * 
     * @type {string}
     * @memberof BroadcastTxCommitResult
     */
    hash?: string;
    /**
     * 
     * @type {number}
     * @memberof BroadcastTxCommitResult
     */
    height?: number;
}
/**
 * Channel defines pipeline for exactly-once packet delivery between specific modules on separate blockchains, which has at least one end capable of sending packets and one end capable of receiving packets.
 * @export
 * @interface ChannelAssociatedWithTheRequestIdentifiers
 */
export interface ChannelAssociatedWithTheRequestIdentifiers {
    /**
     * State defines if a channel is in one of the following states: CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.   - STATE_UNINITIALIZED_UNSPECIFIED: Default State  - STATE_INIT: A channel has just started the opening handshake.  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.  - STATE_OPEN: A channel has completed the handshake. Open channels are ready to send and receive packets.  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive packets.
     * @type {string}
     * @memberof ChannelAssociatedWithTheRequestIdentifiers
     */
    state?: ChannelAssociatedWithTheRequestIdentifiersStateEnum;
    /**
     * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in which they were sent.  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
     * @type {string}
     * @memberof ChannelAssociatedWithTheRequestIdentifiers
     */
    ordering?: ChannelAssociatedWithTheRequestIdentifiersOrderingEnum;
    /**
     * 
     * @type {CounterpartyChannelEnd}
     * @memberof ChannelAssociatedWithTheRequestIdentifiers
     */
    counterparty?: CounterpartyChannelEnd;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChannelAssociatedWithTheRequestIdentifiers
     */
    connection_hops?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ChannelAssociatedWithTheRequestIdentifiers
     */
    version?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ChannelAssociatedWithTheRequestIdentifiersStateEnum {
    UninitializedUnspecified = 'STATE_UNINITIALIZED_UNSPECIFIED',
    Init = 'STATE_INIT',
    Tryopen = 'STATE_TRYOPEN',
    Open = 'STATE_OPEN',
    Closed = 'STATE_CLOSED'
}
/**
    * @export
    * @enum {string}
    */
export enum ChannelAssociatedWithTheRequestIdentifiersOrderingEnum {
    NoneUnspecified = 'ORDER_NONE_UNSPECIFIED',
    Unordered = 'ORDER_UNORDERED',
    Ordered = 'ORDER_ORDERED'
}

/**
 * 
 * @export
 * @interface CheckTxResult
 */
export interface CheckTxResult {
    /**
     * 
     * @type {number}
     * @memberof CheckTxResult
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof CheckTxResult
     */
    data?: string;
    /**
     * 
     * @type {number}
     * @memberof CheckTxResult
     */
    gas_used?: number;
    /**
     * 
     * @type {number}
     * @memberof CheckTxResult
     */
    gas_wanted?: number;
    /**
     * 
     * @type {string}
     * @memberof CheckTxResult
     */
    info?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckTxResult
     */
    log?: string;
    /**
     * 
     * @type {Array<InlineResponse2004ResultTags>}
     * @memberof CheckTxResult
     */
    tags?: Array<InlineResponse2004ResultTags>;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ClientState
 */
export interface ClientState {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ClientState
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof ClientState
     */
    value?: string;
}
/**
 * IdentifiedClientState defines a client state with an additional client identifier field.
 * @export
 * @interface ClientStateAssociatedWithTheChannel
 */
export interface ClientStateAssociatedWithTheChannel {
    /**
     * 
     * @type {string}
     * @memberof ClientStateAssociatedWithTheChannel
     */
    client_id?: string;
    /**
     * 
     * @type {ClientState}
     * @memberof ClientStateAssociatedWithTheChannel
     */
    client_state?: ClientState;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ClientStateAssociatedWithTheRequestIdentifier
 */
export interface ClientStateAssociatedWithTheRequestIdentifier {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ClientStateAssociatedWithTheRequestIdentifier
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof ClientStateAssociatedWithTheRequestIdentifier
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface Coin
 */
export interface Coin {
    /**
     * 
     * @type {string}
     * @memberof Coin
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof Coin
     */
    amount?: string;
}
/**
 * ConnectionEnd defines a stateful object on a chain connected to another separate one. NOTE: there must only be 2 defined ConnectionEnds to establish a connection between two chains.
 * @export
 * @interface ConnectionAssociatedWithTheRequestIdentifier
 */
export interface ConnectionAssociatedWithTheRequestIdentifier {
    /**
     * client associated with this connection.
     * @type {string}
     * @memberof ConnectionAssociatedWithTheRequestIdentifier
     */
    client_id?: string;
    /**
     * IBC version which can be utilised to determine encodings or protocols for channels or packets utilising this connection.
     * @type {Array<InlineResponse20080Versions>}
     * @memberof ConnectionAssociatedWithTheRequestIdentifier
     */
    versions?: Array<InlineResponse20080Versions>;
    /**
     * current state of the connection end.
     * @type {string}
     * @memberof ConnectionAssociatedWithTheRequestIdentifier
     */
    state?: ConnectionAssociatedWithTheRequestIdentifierStateEnum;
    /**
     * 
     * @type {InlineResponse20080Counterparty}
     * @memberof ConnectionAssociatedWithTheRequestIdentifier
     */
    counterparty?: InlineResponse20080Counterparty;
    /**
     * delay period that must pass before a consensus state can be used for packet-verification NOTE: delay period logic is only implemented by some clients.
     * @type {string}
     * @memberof ConnectionAssociatedWithTheRequestIdentifier
     */
    delay_period?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ConnectionAssociatedWithTheRequestIdentifierStateEnum {
    UninitializedUnspecified = 'STATE_UNINITIALIZED_UNSPECIFIED',
    Init = 'STATE_INIT',
    Tryopen = 'STATE_TRYOPEN',
    Open = 'STATE_OPEN'
}

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ConsensusState
 */
export interface ConsensusState {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ConsensusState
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof ConsensusState
     */
    value?: string;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ConsensusStateAssociatedWithTheChannel
 */
export interface ConsensusStateAssociatedWithTheChannel {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ConsensusStateAssociatedWithTheChannel
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof ConsensusStateAssociatedWithTheChannel
     */
    value?: string;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ConsensusStateAssociatedWithTheClientIdentifierAtTheGivenHeight
 */
export interface ConsensusStateAssociatedWithTheClientIdentifierAtTheGivenHeight {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ConsensusStateAssociatedWithTheClientIdentifierAtTheGivenHeight
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof ConsensusStateAssociatedWithTheClientIdentifierAtTheGivenHeight
     */
    value?: string;
}
/**
 * Normally the RevisionHeight is incremented at each height while keeping RevisionNumber the same. However some consensus algorithms may choose to reset the height in certain conditions e.g. hard forks, state-machine breaking changes In these cases, the RevisionNumber is incremented so that height continues to be monitonically increasing even as the RevisionHeight gets reset
 * @export
 * @interface ConsensusStateHeight
 */
export interface ConsensusStateHeight {
    /**
     * 
     * @type {string}
     * @memberof ConsensusStateHeight
     */
    revision_number?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsensusStateHeight
     */
    revision_height?: string;
}
/**
 * Params defines the parameters for the auth module.
 * @export
 * @interface CosmosAuthV1beta1Params
 */
export interface CosmosAuthV1beta1Params {
    /**
     * 
     * @type {string}
     * @memberof CosmosAuthV1beta1Params
     */
    max_memo_characters?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosAuthV1beta1Params
     */
    tx_sig_limit?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosAuthV1beta1Params
     */
    tx_size_cost_per_byte?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosAuthV1beta1Params
     */
    sig_verify_cost_ed25519?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosAuthV1beta1Params
     */
    sig_verify_cost_secp256k1?: string;
}
/**
 * QueryAccountResponse is the response type for the Query/Account RPC method.
 * @export
 * @interface CosmosAuthV1beta1QueryAccountResponse
 */
export interface CosmosAuthV1beta1QueryAccountResponse {
    /**
     * 
     * @type {InlineResponse20025Account}
     * @memberof CosmosAuthV1beta1QueryAccountResponse
     */
    account?: InlineResponse20025Account;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface CosmosAuthV1beta1QueryParamsResponse
 */
export interface CosmosAuthV1beta1QueryParamsResponse {
    /**
     * 
     * @type {InlineResponse20026Params}
     * @memberof CosmosAuthV1beta1QueryParamsResponse
     */
    params?: InlineResponse20026Params;
}
/**
 * Params defines the parameters for the bank module.
 * @export
 * @interface CosmosBankV1beta1Params
 */
export interface CosmosBankV1beta1Params {
    /**
     * 
     * @type {Array<InlineResponse20029ParamsSendEnabled>}
     * @memberof CosmosBankV1beta1Params
     */
    send_enabled?: Array<InlineResponse20029ParamsSendEnabled>;
    /**
     * 
     * @type {boolean}
     * @memberof CosmosBankV1beta1Params
     */
    default_send_enabled?: boolean;
}
/**
 * QueryAllBalancesResponse is the response type for the Query/AllBalances RPC method.
 * @export
 * @interface CosmosBankV1beta1QueryAllBalancesResponse
 */
export interface CosmosBankV1beta1QueryAllBalancesResponse {
    /**
     * balances is the balances of all the coins.
     * @type {Array<InlineResponse20027Balances>}
     * @memberof CosmosBankV1beta1QueryAllBalancesResponse
     */
    balances?: Array<InlineResponse20027Balances>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof CosmosBankV1beta1QueryAllBalancesResponse
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * QueryBalanceResponse is the response type for the Query/Balance RPC method.
 * @export
 * @interface CosmosBankV1beta1QueryBalanceResponse
 */
export interface CosmosBankV1beta1QueryBalanceResponse {
    /**
     * 
     * @type {InlineResponse20028Balance}
     * @memberof CosmosBankV1beta1QueryBalanceResponse
     */
    balance?: InlineResponse20028Balance;
}
/**
 * QueryParamsResponse defines the response type for querying x/bank parameters.
 * @export
 * @interface CosmosBankV1beta1QueryParamsResponse
 */
export interface CosmosBankV1beta1QueryParamsResponse {
    /**
     * 
     * @type {InlineResponse20029Params}
     * @memberof CosmosBankV1beta1QueryParamsResponse
     */
    params?: InlineResponse20029Params;
}
/**
 * QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method.
 * @export
 * @interface CosmosBankV1beta1QuerySupplyOfResponse
 */
export interface CosmosBankV1beta1QuerySupplyOfResponse {
    /**
     * 
     * @type {InlineResponse20030Amount}
     * @memberof CosmosBankV1beta1QuerySupplyOfResponse
     */
    amount?: InlineResponse20030Amount;
}
/**
 * 
 * @export
 * @interface CosmosBankV1beta1QueryTotalSupplyResponse
 */
export interface CosmosBankV1beta1QueryTotalSupplyResponse {
    /**
     * 
     * @type {Array<InlineResponse20027Balances>}
     * @memberof CosmosBankV1beta1QueryTotalSupplyResponse
     */
    supply?: Array<InlineResponse20027Balances>;
}
/**
 * SendEnabled maps coin denom to a send_enabled status (whether a denom is sendable).
 * @export
 * @interface CosmosBankV1beta1SendEnabled
 */
export interface CosmosBankV1beta1SendEnabled {
    /**
     * 
     * @type {string}
     * @memberof CosmosBankV1beta1SendEnabled
     */
    denom?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CosmosBankV1beta1SendEnabled
     */
    enabled?: boolean;
}
/**
 * ABCIMessageLog defines a structure containing an indexed tx ABCI message log.
 * @export
 * @interface CosmosBaseAbciV1beta1ABCIMessageLog
 */
export interface CosmosBaseAbciV1beta1ABCIMessageLog {
    /**
     * 
     * @type {number}
     * @memberof CosmosBaseAbciV1beta1ABCIMessageLog
     */
    msg_index?: number;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1ABCIMessageLog
     */
    log?: string;
    /**
     * Events contains a slice of Event objects that were emitted during some execution.
     * @type {Array<InlineResponse20071TxResponseEvents>}
     * @memberof CosmosBaseAbciV1beta1ABCIMessageLog
     */
    events?: Array<InlineResponse20071TxResponseEvents>;
}
/**
 * Attribute defines an attribute wrapper where the key and value are strings instead of raw bytes.
 * @export
 * @interface CosmosBaseAbciV1beta1Attribute
 */
export interface CosmosBaseAbciV1beta1Attribute {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1Attribute
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1Attribute
     */
    value?: string;
}
/**
 * GasInfo defines tx execution gas context.
 * @export
 * @interface CosmosBaseAbciV1beta1GasInfo
 */
export interface CosmosBaseAbciV1beta1GasInfo {
    /**
     * GasWanted is the maximum units of work we allow this tx to perform.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1GasInfo
     */
    gas_wanted?: string;
    /**
     * GasUsed is the amount of gas actually consumed.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1GasInfo
     */
    gas_used?: string;
}
/**
 * Result is the union of ResponseFormat and ResponseCheckTx.
 * @export
 * @interface CosmosBaseAbciV1beta1Result
 */
export interface CosmosBaseAbciV1beta1Result {
    /**
     * Data is any data returned from message or handler execution. It MUST be length prefixed in order to separate data from multiple message executions.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1Result
     */
    data?: string;
    /**
     * Log contains the log information from message or handler execution.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1Result
     */
    log?: string;
    /**
     * Events contains a slice of Event objects that were emitted during message or handler execution.
     * @type {Array<InlineResponse20070ResultEvents>}
     * @memberof CosmosBaseAbciV1beta1Result
     */
    events?: Array<InlineResponse20070ResultEvents>;
}
/**
 * StringEvent defines en Event object wrapper where all the attributes contain key/value pairs that are strings instead of raw bytes.
 * @export
 * @interface CosmosBaseAbciV1beta1StringEvent
 */
export interface CosmosBaseAbciV1beta1StringEvent {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1StringEvent
     */
    type?: string;
    /**
     * 
     * @type {Array<InlineResponse20071TxResponseAttributes>}
     * @memberof CosmosBaseAbciV1beta1StringEvent
     */
    attributes?: Array<InlineResponse20071TxResponseAttributes>;
}
/**
 * TxResponse defines a structure containing relevant tx data and metadata. The tags are stringified and the log is JSON decoded.
 * @export
 * @interface CosmosBaseAbciV1beta1TxResponse
 */
export interface CosmosBaseAbciV1beta1TxResponse {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    height?: string;
    /**
     * The transaction hash.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    txhash?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    codespace?: string;
    /**
     * Response code.
     * @type {number}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    code?: number;
    /**
     * Result bytes, if any.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    data?: string;
    /**
     * The output of the application\'s logger (raw string). May be non-deterministic.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    raw_log?: string;
    /**
     * The output of the application\'s logger (typed). May be non-deterministic.
     * @type {Array<InlineResponse20071TxResponseLogs>}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    logs?: Array<InlineResponse20071TxResponseLogs>;
    /**
     * Additional information. May be non-deterministic.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    info?: string;
    /**
     * Amount of gas requested for transaction.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    gas_wanted?: string;
    /**
     * Amount of gas consumed by transaction.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    gas_used?: string;
    /**
     * 
     * @type {InlineResponse20071TxResponseTx}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    tx?: InlineResponse20071TxResponseTx;
    /**
     * Time of the previous block. For heights > 1, it\'s the weighted median of the timestamps of the valid votes in the block.LastCommit. For height == 1, it\'s genesis time.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    timestamp?: string;
}
/**
 * message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }
 * @export
 * @interface CosmosBaseQueryV1beta1PageRequest
 */
export interface CosmosBaseQueryV1beta1PageRequest {
    /**
     * key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    key?: string;
    /**
     * offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    offset?: string;
    /**
     * limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    limit?: string;
    /**
     * count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @type {boolean}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    count_total?: boolean;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the corresponding request message has used PageRequest.   message SomeResponse {          repeated Bar results = 1;          PageResponse page = 2;  }
 * @export
 * @interface CosmosBaseQueryV1beta1PageResponse
 */
export interface CosmosBaseQueryV1beta1PageResponse {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageResponse
     */
    next_key?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageResponse
     */
    total?: string;
}
/**
 * GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method.
 * @export
 * @interface CosmosBaseTendermintV1beta1GetBlockByHeightResponse
 */
export interface CosmosBaseTendermintV1beta1GetBlockByHeightResponse {
    /**
     * 
     * @type {BlockID1}
     * @memberof CosmosBaseTendermintV1beta1GetBlockByHeightResponse
     */
    block_id?: BlockID1;
    /**
     * 
     * @type {InlineResponse20031Block}
     * @memberof CosmosBaseTendermintV1beta1GetBlockByHeightResponse
     */
    block?: InlineResponse20031Block;
}
/**
 * GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method.
 * @export
 * @interface CosmosBaseTendermintV1beta1GetLatestBlockResponse
 */
export interface CosmosBaseTendermintV1beta1GetLatestBlockResponse {
    /**
     * 
     * @type {BlockID1}
     * @memberof CosmosBaseTendermintV1beta1GetLatestBlockResponse
     */
    block_id?: BlockID1;
    /**
     * 
     * @type {InlineResponse20031Block}
     * @memberof CosmosBaseTendermintV1beta1GetLatestBlockResponse
     */
    block?: InlineResponse20031Block;
}
/**
 * GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method.
 * @export
 * @interface CosmosBaseTendermintV1beta1GetLatestValidatorSetResponse
 */
export interface CosmosBaseTendermintV1beta1GetLatestValidatorSetResponse {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1GetLatestValidatorSetResponse
     */
    block_height?: string;
    /**
     * 
     * @type {Array<InlineResponse20035Validators>}
     * @memberof CosmosBaseTendermintV1beta1GetLatestValidatorSetResponse
     */
    validators?: Array<InlineResponse20035Validators>;
    /**
     * 
     * @type {InlineResponse20035Pagination}
     * @memberof CosmosBaseTendermintV1beta1GetLatestValidatorSetResponse
     */
    pagination?: InlineResponse20035Pagination;
}
/**
 * GetNodeInfoResponse is the request type for the Query/GetNodeInfo RPC method.
 * @export
 * @interface CosmosBaseTendermintV1beta1GetNodeInfoResponse
 */
export interface CosmosBaseTendermintV1beta1GetNodeInfoResponse {
    /**
     * 
     * @type {InlineResponse20033DefaultNodeInfo}
     * @memberof CosmosBaseTendermintV1beta1GetNodeInfoResponse
     */
    default_node_info?: InlineResponse20033DefaultNodeInfo;
    /**
     * 
     * @type {InlineResponse20033ApplicationVersion}
     * @memberof CosmosBaseTendermintV1beta1GetNodeInfoResponse
     */
    application_version?: InlineResponse20033ApplicationVersion;
}
/**
 * GetSyncingResponse is the response type for the Query/GetSyncing RPC method.
 * @export
 * @interface CosmosBaseTendermintV1beta1GetSyncingResponse
 */
export interface CosmosBaseTendermintV1beta1GetSyncingResponse {
    /**
     * 
     * @type {boolean}
     * @memberof CosmosBaseTendermintV1beta1GetSyncingResponse
     */
    syncing?: boolean;
}
/**
 * GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method.
 * @export
 * @interface CosmosBaseTendermintV1beta1GetValidatorSetByHeightResponse
 */
export interface CosmosBaseTendermintV1beta1GetValidatorSetByHeightResponse {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1GetValidatorSetByHeightResponse
     */
    block_height?: string;
    /**
     * 
     * @type {Array<InlineResponse20035Validators>}
     * @memberof CosmosBaseTendermintV1beta1GetValidatorSetByHeightResponse
     */
    validators?: Array<InlineResponse20035Validators>;
    /**
     * 
     * @type {InlineResponse20035Pagination}
     * @memberof CosmosBaseTendermintV1beta1GetValidatorSetByHeightResponse
     */
    pagination?: InlineResponse20035Pagination;
}
/**
 * 
 * @export
 * @interface CosmosBaseTendermintV1beta1Module
 */
export interface CosmosBaseTendermintV1beta1Module {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Module
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Module
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Module
     */
    sum?: string;
}
/**
 * Validator is the type for the validator-set.
 * @export
 * @interface CosmosBaseTendermintV1beta1Validator
 */
export interface CosmosBaseTendermintV1beta1Validator {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Validator
     */
    address?: string;
    /**
     * 
     * @type {InlineResponseDefaultDetails}
     * @memberof CosmosBaseTendermintV1beta1Validator
     */
    pub_key?: InlineResponseDefaultDetails;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Validator
     */
    voting_power?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Validator
     */
    proposer_priority?: string;
}
/**
 * VersionInfo is the type for the GetNodeInfoResponse message.
 * @export
 * @interface CosmosBaseTendermintV1beta1VersionInfo
 */
export interface CosmosBaseTendermintV1beta1VersionInfo {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1VersionInfo
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1VersionInfo
     */
    app_name?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1VersionInfo
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1VersionInfo
     */
    git_commit?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1VersionInfo
     */
    build_tags?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1VersionInfo
     */
    go_version?: string;
    /**
     * 
     * @type {Array<ModuleIsTheTypeForVersionInfo>}
     * @memberof CosmosBaseTendermintV1beta1VersionInfo
     */
    build_deps?: Array<ModuleIsTheTypeForVersionInfo>;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface CosmosBaseV1beta1Coin
 */
export interface CosmosBaseV1beta1Coin {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseV1beta1Coin
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseV1beta1Coin
     */
    amount?: string;
}
/**
 * DecCoin defines a token with a denomination and a decimal amount.  NOTE: The amount field is an Dec which implements the custom method signatures required by gogoproto.
 * @export
 * @interface CosmosBaseV1beta1DecCoin
 */
export interface CosmosBaseV1beta1DecCoin {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseV1beta1DecCoin
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseV1beta1DecCoin
     */
    amount?: string;
}
/**
 * CompactBitArray is an implementation of a space efficient bit array. This is used to ensure that the encoded data takes up a minimal amount of space after proto encoding. This is not thread safe, and is not intended for concurrent usage.
 * @export
 * @interface CosmosCryptoMultisigV1beta1CompactBitArray
 */
export interface CosmosCryptoMultisigV1beta1CompactBitArray {
    /**
     * 
     * @type {number}
     * @memberof CosmosCryptoMultisigV1beta1CompactBitArray
     */
    extra_bits_stored?: number;
    /**
     * 
     * @type {string}
     * @memberof CosmosCryptoMultisigV1beta1CompactBitArray
     */
    elems?: string;
}
/**
 * DelegationDelegatorReward represents the properties of a delegator\'s delegation reward.
 * @export
 * @interface CosmosDistributionV1beta1DelegationDelegatorReward
 */
export interface CosmosDistributionV1beta1DelegationDelegatorReward {
    /**
     * 
     * @type {string}
     * @memberof CosmosDistributionV1beta1DelegationDelegatorReward
     */
    validator_address?: string;
    /**
     * 
     * @type {Array<InlineResponse20037Pool>}
     * @memberof CosmosDistributionV1beta1DelegationDelegatorReward
     */
    reward?: Array<InlineResponse20037Pool>;
}
/**
 * Params defines the set of params for the distribution module.
 * @export
 * @interface CosmosDistributionV1beta1Params
 */
export interface CosmosDistributionV1beta1Params {
    /**
     * 
     * @type {string}
     * @memberof CosmosDistributionV1beta1Params
     */
    community_tax?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosDistributionV1beta1Params
     */
    base_proposer_reward?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosDistributionV1beta1Params
     */
    bonus_proposer_reward?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CosmosDistributionV1beta1Params
     */
    withdraw_addr_enabled?: boolean;
}
/**
 * QueryCommunityPoolResponse is the response type for the Query/CommunityPool RPC method.
 * @export
 * @interface CosmosDistributionV1beta1QueryCommunityPoolResponse
 */
export interface CosmosDistributionV1beta1QueryCommunityPoolResponse {
    /**
     * pool defines community pool\'s coins.
     * @type {Array<InlineResponse20037Pool>}
     * @memberof CosmosDistributionV1beta1QueryCommunityPoolResponse
     */
    pool?: Array<InlineResponse20037Pool>;
}
/**
 * QueryDelegationRewardsResponse is the response type for the Query/DelegationRewards RPC method.
 * @export
 * @interface CosmosDistributionV1beta1QueryDelegationRewardsResponse
 */
export interface CosmosDistributionV1beta1QueryDelegationRewardsResponse {
    /**
     * rewards defines the rewards accrued by a delegation.
     * @type {Array<InlineResponse20037Pool>}
     * @memberof CosmosDistributionV1beta1QueryDelegationRewardsResponse
     */
    rewards?: Array<InlineResponse20037Pool>;
}
/**
 * QueryDelegationTotalRewardsResponse is the response type for the Query/DelegationTotalRewards RPC method.
 * @export
 * @interface CosmosDistributionV1beta1QueryDelegationTotalRewardsResponse
 */
export interface CosmosDistributionV1beta1QueryDelegationTotalRewardsResponse {
    /**
     * rewards defines all the rewards accrued by a delegator.
     * @type {Array<InlineResponse20038Rewards>}
     * @memberof CosmosDistributionV1beta1QueryDelegationTotalRewardsResponse
     */
    rewards?: Array<InlineResponse20038Rewards>;
    /**
     * total defines the sum of all the rewards.
     * @type {Array<InlineResponse20037Pool>}
     * @memberof CosmosDistributionV1beta1QueryDelegationTotalRewardsResponse
     */
    total?: Array<InlineResponse20037Pool>;
}
/**
 * QueryDelegatorValidatorsResponse is the response type for the Query/DelegatorValidators RPC method.
 * @export
 * @interface CosmosDistributionV1beta1QueryDelegatorValidatorsResponse
 */
export interface CosmosDistributionV1beta1QueryDelegatorValidatorsResponse {
    /**
     * validators defines the validators a delegator is delegating for.
     * @type {Array<string>}
     * @memberof CosmosDistributionV1beta1QueryDelegatorValidatorsResponse
     */
    validators?: Array<string>;
}
/**
 * QueryDelegatorWithdrawAddressResponse is the response type for the Query/DelegatorWithdrawAddress RPC method.
 * @export
 * @interface CosmosDistributionV1beta1QueryDelegatorWithdrawAddressResponse
 */
export interface CosmosDistributionV1beta1QueryDelegatorWithdrawAddressResponse {
    /**
     * withdraw_address defines the delegator address to query for.
     * @type {string}
     * @memberof CosmosDistributionV1beta1QueryDelegatorWithdrawAddressResponse
     */
    withdraw_address?: string;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface CosmosDistributionV1beta1QueryParamsResponse
 */
export interface CosmosDistributionV1beta1QueryParamsResponse {
    /**
     * 
     * @type {InlineResponse20042Params}
     * @memberof CosmosDistributionV1beta1QueryParamsResponse
     */
    params?: InlineResponse20042Params;
}
/**
 * 
 * @export
 * @interface CosmosDistributionV1beta1QueryValidatorCommissionResponse
 */
export interface CosmosDistributionV1beta1QueryValidatorCommissionResponse {
    /**
     * 
     * @type {QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethodCommission}
     * @memberof CosmosDistributionV1beta1QueryValidatorCommissionResponse
     */
    commission?: QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethodCommission;
}
/**
 * QueryValidatorOutstandingRewardsResponse is the response type for the Query/ValidatorOutstandingRewards RPC method.
 * @export
 * @interface CosmosDistributionV1beta1QueryValidatorOutstandingRewardsResponse
 */
export interface CosmosDistributionV1beta1QueryValidatorOutstandingRewardsResponse {
    /**
     * 
     * @type {InlineResponse20043Rewards}
     * @memberof CosmosDistributionV1beta1QueryValidatorOutstandingRewardsResponse
     */
    rewards?: InlineResponse20043Rewards;
}
/**
 * QueryValidatorSlashesResponse is the response type for the Query/ValidatorSlashes RPC method.
 * @export
 * @interface CosmosDistributionV1beta1QueryValidatorSlashesResponse
 */
export interface CosmosDistributionV1beta1QueryValidatorSlashesResponse {
    /**
     * slashes defines the slashes the validator received.
     * @type {Array<InlineResponse20044Slashes>}
     * @memberof CosmosDistributionV1beta1QueryValidatorSlashesResponse
     */
    slashes?: Array<InlineResponse20044Slashes>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof CosmosDistributionV1beta1QueryValidatorSlashesResponse
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * ValidatorAccumulatedCommission represents accumulated commission for a validator kept as a running counter, can be withdrawn at any time.
 * @export
 * @interface CosmosDistributionV1beta1ValidatorAccumulatedCommission
 */
export interface CosmosDistributionV1beta1ValidatorAccumulatedCommission {
    /**
     * 
     * @type {Array<InlineResponse20037Pool>}
     * @memberof CosmosDistributionV1beta1ValidatorAccumulatedCommission
     */
    commission?: Array<InlineResponse20037Pool>;
}
/**
 * ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards for a validator inexpensive to track, allows simple sanity checks.
 * @export
 * @interface CosmosDistributionV1beta1ValidatorOutstandingRewards
 */
export interface CosmosDistributionV1beta1ValidatorOutstandingRewards {
    /**
     * 
     * @type {Array<InlineResponse20037Pool>}
     * @memberof CosmosDistributionV1beta1ValidatorOutstandingRewards
     */
    rewards?: Array<InlineResponse20037Pool>;
}
/**
 * ValidatorSlashEvent represents a validator slash event. Height is implicit within the store key. This is needed to calculate appropriate amount of staking tokens for delegations which are withdrawn after a slash has occurred.
 * @export
 * @interface CosmosDistributionV1beta1ValidatorSlashEvent
 */
export interface CosmosDistributionV1beta1ValidatorSlashEvent {
    /**
     * 
     * @type {string}
     * @memberof CosmosDistributionV1beta1ValidatorSlashEvent
     */
    validator_period?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosDistributionV1beta1ValidatorSlashEvent
     */
    fraction?: string;
}
/**
 * QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC method.
 * @export
 * @interface CosmosEvidenceV1beta1QueryAllEvidenceResponse
 */
export interface CosmosEvidenceV1beta1QueryAllEvidenceResponse {
    /**
     * evidence returns all evidences.
     * @type {Array<InlineResponseDefaultDetails>}
     * @memberof CosmosEvidenceV1beta1QueryAllEvidenceResponse
     */
    evidence?: Array<InlineResponseDefaultDetails>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof CosmosEvidenceV1beta1QueryAllEvidenceResponse
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * QueryEvidenceResponse is the response type for the Query/Evidence RPC method.
 * @export
 * @interface CosmosEvidenceV1beta1QueryEvidenceResponse
 */
export interface CosmosEvidenceV1beta1QueryEvidenceResponse {
    /**
     * 
     * @type {InlineResponse20046Evidence}
     * @memberof CosmosEvidenceV1beta1QueryEvidenceResponse
     */
    evidence?: InlineResponse20046Evidence;
}
/**
 * Deposit defines an amount deposited by an account address to an active proposal.
 * @export
 * @interface CosmosGovV1beta1Deposit
 */
export interface CosmosGovV1beta1Deposit {
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1Deposit
     */
    proposal_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1Deposit
     */
    depositor?: string;
    /**
     * 
     * @type {Array<InlineResponse20027Balances>}
     * @memberof CosmosGovV1beta1Deposit
     */
    amount?: Array<InlineResponse20027Balances>;
}
/**
 * DepositParams defines the params for deposits on governance proposals.
 * @export
 * @interface CosmosGovV1beta1DepositParams
 */
export interface CosmosGovV1beta1DepositParams {
    /**
     * Minimum deposit for a proposal to enter voting period.
     * @type {Array<InlineResponse20027Balances>}
     * @memberof CosmosGovV1beta1DepositParams
     */
    min_deposit?: Array<InlineResponse20027Balances>;
    /**
     * Maximum period for Atom holders to deposit on a proposal. Initial value: 2  months.
     * @type {string}
     * @memberof CosmosGovV1beta1DepositParams
     */
    max_deposit_period?: string;
}
/**
 * Proposal defines the core field members of a governance proposal.
 * @export
 * @interface CosmosGovV1beta1Proposal
 */
export interface CosmosGovV1beta1Proposal {
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1Proposal
     */
    proposal_id?: string;
    /**
     * 
     * @type {InlineResponseDefaultDetails}
     * @memberof CosmosGovV1beta1Proposal
     */
    content?: InlineResponseDefaultDetails;
    /**
     * ProposalStatus enumerates the valid statuses of a proposal.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
     * @type {string}
     * @memberof CosmosGovV1beta1Proposal
     */
    status?: CosmosGovV1beta1ProposalStatusEnum;
    /**
     * 
     * @type {InlineResponse20048FinalTallyResult}
     * @memberof CosmosGovV1beta1Proposal
     */
    final_tally_result?: InlineResponse20048FinalTallyResult;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1Proposal
     */
    submit_time?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1Proposal
     */
    deposit_end_time?: string;
    /**
     * 
     * @type {Array<InlineResponse20027Balances>}
     * @memberof CosmosGovV1beta1Proposal
     */
    total_deposit?: Array<InlineResponse20027Balances>;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1Proposal
     */
    voting_start_time?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1Proposal
     */
    voting_end_time?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum CosmosGovV1beta1ProposalStatusEnum {
    Unspecified = 'PROPOSAL_STATUS_UNSPECIFIED',
    DepositPeriod = 'PROPOSAL_STATUS_DEPOSIT_PERIOD',
    VotingPeriod = 'PROPOSAL_STATUS_VOTING_PERIOD',
    Passed = 'PROPOSAL_STATUS_PASSED',
    Rejected = 'PROPOSAL_STATUS_REJECTED',
    Failed = 'PROPOSAL_STATUS_FAILED'
}

/**
 * ProposalStatus enumerates the valid statuses of a proposal.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
 * @export
 * @enum {string}
 */
export enum CosmosGovV1beta1ProposalStatus {
    Unspecified = 'PROPOSAL_STATUS_UNSPECIFIED',
    DepositPeriod = 'PROPOSAL_STATUS_DEPOSIT_PERIOD',
    VotingPeriod = 'PROPOSAL_STATUS_VOTING_PERIOD',
    Passed = 'PROPOSAL_STATUS_PASSED',
    Rejected = 'PROPOSAL_STATUS_REJECTED',
    Failed = 'PROPOSAL_STATUS_FAILED'
}

/**
 * QueryDepositResponse is the response type for the Query/Deposit RPC method.
 * @export
 * @interface CosmosGovV1beta1QueryDepositResponse
 */
export interface CosmosGovV1beta1QueryDepositResponse {
    /**
     * 
     * @type {InlineResponse20051Deposit}
     * @memberof CosmosGovV1beta1QueryDepositResponse
     */
    deposit?: InlineResponse20051Deposit;
}
/**
 * QueryDepositsResponse is the response type for the Query/Deposits RPC method.
 * @export
 * @interface CosmosGovV1beta1QueryDepositsResponse
 */
export interface CosmosGovV1beta1QueryDepositsResponse {
    /**
     * 
     * @type {Array<InlineResponse20050Deposits>}
     * @memberof CosmosGovV1beta1QueryDepositsResponse
     */
    deposits?: Array<InlineResponse20050Deposits>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof CosmosGovV1beta1QueryDepositsResponse
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface CosmosGovV1beta1QueryParamsResponse
 */
export interface CosmosGovV1beta1QueryParamsResponse {
    /**
     * 
     * @type {InlineResponse20047VotingParams}
     * @memberof CosmosGovV1beta1QueryParamsResponse
     */
    voting_params?: InlineResponse20047VotingParams;
    /**
     * 
     * @type {InlineResponse20047DepositParams}
     * @memberof CosmosGovV1beta1QueryParamsResponse
     */
    deposit_params?: InlineResponse20047DepositParams;
    /**
     * 
     * @type {InlineResponse20047TallyParams}
     * @memberof CosmosGovV1beta1QueryParamsResponse
     */
    tally_params?: InlineResponse20047TallyParams;
}
/**
 * QueryProposalResponse is the response type for the Query/Proposal RPC method.
 * @export
 * @interface CosmosGovV1beta1QueryProposalResponse
 */
export interface CosmosGovV1beta1QueryProposalResponse {
    /**
     * 
     * @type {InlineResponse20048Proposals}
     * @memberof CosmosGovV1beta1QueryProposalResponse
     */
    proposal?: InlineResponse20048Proposals;
}
/**
 * QueryProposalsResponse is the response type for the Query/Proposals RPC method.
 * @export
 * @interface CosmosGovV1beta1QueryProposalsResponse
 */
export interface CosmosGovV1beta1QueryProposalsResponse {
    /**
     * 
     * @type {Array<InlineResponse20048Proposals>}
     * @memberof CosmosGovV1beta1QueryProposalsResponse
     */
    proposals?: Array<InlineResponse20048Proposals>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof CosmosGovV1beta1QueryProposalsResponse
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * QueryTallyResultResponse is the response type for the Query/Tally RPC method.
 * @export
 * @interface CosmosGovV1beta1QueryTallyResultResponse
 */
export interface CosmosGovV1beta1QueryTallyResultResponse {
    /**
     * 
     * @type {InlineResponse20052Tally}
     * @memberof CosmosGovV1beta1QueryTallyResultResponse
     */
    tally?: InlineResponse20052Tally;
}
/**
 * QueryVoteResponse is the response type for the Query/Vote RPC method.
 * @export
 * @interface CosmosGovV1beta1QueryVoteResponse
 */
export interface CosmosGovV1beta1QueryVoteResponse {
    /**
     * 
     * @type {InlineResponse20054Vote}
     * @memberof CosmosGovV1beta1QueryVoteResponse
     */
    vote?: InlineResponse20054Vote;
}
/**
 * QueryVotesResponse is the response type for the Query/Votes RPC method.
 * @export
 * @interface CosmosGovV1beta1QueryVotesResponse
 */
export interface CosmosGovV1beta1QueryVotesResponse {
    /**
     * votes defined the queried votes.
     * @type {Array<InlineResponse20053Votes>}
     * @memberof CosmosGovV1beta1QueryVotesResponse
     */
    votes?: Array<InlineResponse20053Votes>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof CosmosGovV1beta1QueryVotesResponse
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * TallyParams defines the params for tallying votes on governance proposals.
 * @export
 * @interface CosmosGovV1beta1TallyParams
 */
export interface CosmosGovV1beta1TallyParams {
    /**
     * Minimum percentage of total stake needed to vote for a result to be  considered valid.
     * @type {string}
     * @memberof CosmosGovV1beta1TallyParams
     */
    quorum?: string;
    /**
     * Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.
     * @type {string}
     * @memberof CosmosGovV1beta1TallyParams
     */
    threshold?: string;
    /**
     * Minimum value of Veto votes to Total votes ratio for proposal to be  vetoed. Default value: 1/3.
     * @type {string}
     * @memberof CosmosGovV1beta1TallyParams
     */
    veto_threshold?: string;
}
/**
 * TallyResult defines a standard tally for a governance proposal.
 * @export
 * @interface CosmosGovV1beta1TallyResult
 */
export interface CosmosGovV1beta1TallyResult {
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1TallyResult
     */
    yes?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1TallyResult
     */
    abstain?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1TallyResult
     */
    no?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1TallyResult
     */
    no_with_veto?: string;
}
/**
 * Vote defines a vote on a governance proposal. A Vote consists of a proposal ID, the voter, and the vote option.
 * @export
 * @interface CosmosGovV1beta1Vote
 */
export interface CosmosGovV1beta1Vote {
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1Vote
     */
    proposal_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1Vote
     */
    voter?: string;
    /**
     * VoteOption enumerates the valid vote options for a given governance proposal.   - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.  - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.  - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.  - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.  - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
     * @type {string}
     * @memberof CosmosGovV1beta1Vote
     */
    option?: CosmosGovV1beta1VoteOptionEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CosmosGovV1beta1VoteOptionEnum {
    Unspecified = 'VOTE_OPTION_UNSPECIFIED',
    Yes = 'VOTE_OPTION_YES',
    Abstain = 'VOTE_OPTION_ABSTAIN',
    No = 'VOTE_OPTION_NO',
    NoWithVeto = 'VOTE_OPTION_NO_WITH_VETO'
}

/**
 * VoteOption enumerates the valid vote options for a given governance proposal.   - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.  - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.  - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.  - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.  - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
 * @export
 * @enum {string}
 */
export enum CosmosGovV1beta1VoteOption {
    Unspecified = 'VOTE_OPTION_UNSPECIFIED',
    Yes = 'VOTE_OPTION_YES',
    Abstain = 'VOTE_OPTION_ABSTAIN',
    No = 'VOTE_OPTION_NO',
    NoWithVeto = 'VOTE_OPTION_NO_WITH_VETO'
}

/**
 * VotingParams defines the params for voting on governance proposals.
 * @export
 * @interface CosmosGovV1beta1VotingParams
 */
export interface CosmosGovV1beta1VotingParams {
    /**
     * Length of the voting period.
     * @type {string}
     * @memberof CosmosGovV1beta1VotingParams
     */
    voting_period?: string;
}
/**
 * Params holds parameters for the mint module.
 * @export
 * @interface CosmosMintV1beta1Params
 */
export interface CosmosMintV1beta1Params {
    /**
     * 
     * @type {string}
     * @memberof CosmosMintV1beta1Params
     */
    mint_denom?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosMintV1beta1Params
     */
    inflation_rate_change?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosMintV1beta1Params
     */
    inflation_max?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosMintV1beta1Params
     */
    inflation_min?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosMintV1beta1Params
     */
    goal_bonded?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosMintV1beta1Params
     */
    blocks_per_year?: string;
}
/**
 * QueryAnnualProvisionsResponse is the response type for the Query/AnnualProvisions RPC method.
 * @export
 * @interface CosmosMintV1beta1QueryAnnualProvisionsResponse
 */
export interface CosmosMintV1beta1QueryAnnualProvisionsResponse {
    /**
     * annual_provisions is the current minting annual provisions value.
     * @type {string}
     * @memberof CosmosMintV1beta1QueryAnnualProvisionsResponse
     */
    annual_provisions?: string;
}
/**
 * QueryInflationResponse is the response type for the Query/Inflation RPC method.
 * @export
 * @interface CosmosMintV1beta1QueryInflationResponse
 */
export interface CosmosMintV1beta1QueryInflationResponse {
    /**
     * inflation is the current minting inflation value.
     * @type {string}
     * @memberof CosmosMintV1beta1QueryInflationResponse
     */
    inflation?: string;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface CosmosMintV1beta1QueryParamsResponse
 */
export interface CosmosMintV1beta1QueryParamsResponse {
    /**
     * 
     * @type {InlineResponse20057Params}
     * @memberof CosmosMintV1beta1QueryParamsResponse
     */
    params?: InlineResponse20057Params;
}
/**
 * ParamChange defines an individual parameter change, for use in ParameterChangeProposal.
 * @export
 * @interface CosmosParamsV1beta1ParamChange
 */
export interface CosmosParamsV1beta1ParamChange {
    /**
     * 
     * @type {string}
     * @memberof CosmosParamsV1beta1ParamChange
     */
    subspace?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosParamsV1beta1ParamChange
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosParamsV1beta1ParamChange
     */
    value?: string;
}
/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 * @export
 * @interface CosmosParamsV1beta1QueryParamsResponse
 */
export interface CosmosParamsV1beta1QueryParamsResponse {
    /**
     * 
     * @type {InlineResponse20058Param}
     * @memberof CosmosParamsV1beta1QueryParamsResponse
     */
    param?: InlineResponse20058Param;
}
/**
 * Params represents the parameters used for by the slashing module.
 * @export
 * @interface CosmosSlashingV1beta1Params
 */
export interface CosmosSlashingV1beta1Params {
    /**
     * 
     * @type {string}
     * @memberof CosmosSlashingV1beta1Params
     */
    signed_blocks_window?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosSlashingV1beta1Params
     */
    min_signed_per_window?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosSlashingV1beta1Params
     */
    downtime_jail_duration?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosSlashingV1beta1Params
     */
    slash_fraction_double_sign?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosSlashingV1beta1Params
     */
    slash_fraction_downtime?: string;
}
/**
 * 
 * @export
 * @interface CosmosSlashingV1beta1QueryParamsResponse
 */
export interface CosmosSlashingV1beta1QueryParamsResponse {
    /**
     * 
     * @type {QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams}
     * @memberof CosmosSlashingV1beta1QueryParamsResponse
     */
    params?: QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams;
}
/**
 * 
 * @export
 * @interface CosmosSlashingV1beta1QuerySigningInfoResponse
 */
export interface CosmosSlashingV1beta1QuerySigningInfoResponse {
    /**
     * 
     * @type {ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress}
     * @memberof CosmosSlashingV1beta1QuerySigningInfoResponse
     */
    val_signing_info?: ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress;
}
/**
 * 
 * @export
 * @interface CosmosSlashingV1beta1QuerySigningInfosResponse
 */
export interface CosmosSlashingV1beta1QuerySigningInfosResponse {
    /**
     * 
     * @type {Array<QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodInfo>}
     * @memberof CosmosSlashingV1beta1QuerySigningInfosResponse
     */
    info?: Array<QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodInfo>;
    /**
     * 
     * @type {QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination}
     * @memberof CosmosSlashingV1beta1QuerySigningInfosResponse
     */
    pagination?: QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination;
}
/**
 * ValidatorSigningInfo defines a validator\'s signing info for monitoring their liveness activity.
 * @export
 * @interface CosmosSlashingV1beta1ValidatorSigningInfo
 */
export interface CosmosSlashingV1beta1ValidatorSigningInfo {
    /**
     * 
     * @type {string}
     * @memberof CosmosSlashingV1beta1ValidatorSigningInfo
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosSlashingV1beta1ValidatorSigningInfo
     */
    start_height?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosSlashingV1beta1ValidatorSigningInfo
     */
    index_offset?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosSlashingV1beta1ValidatorSigningInfo
     */
    jailed_until?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CosmosSlashingV1beta1ValidatorSigningInfo
     */
    tombstoned?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CosmosSlashingV1beta1ValidatorSigningInfo
     */
    missed_blocks_counter?: string;
}
/**
 * BondStatus is the status of a validator.   - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.  - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.  - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.  - BOND_STATUS_BONDED: BONDED defines a validator that is bonded.
 * @export
 * @enum {string}
 */
export enum CosmosStakingV1beta1BondStatus {
    Unspecified = 'BOND_STATUS_UNSPECIFIED',
    Unbonded = 'BOND_STATUS_UNBONDED',
    Unbonding = 'BOND_STATUS_UNBONDING',
    Bonded = 'BOND_STATUS_BONDED'
}

/**
 * Commission defines commission parameters for a given validator.
 * @export
 * @interface CosmosStakingV1beta1Commission
 */
export interface CosmosStakingV1beta1Commission {
    /**
     * 
     * @type {InlineResponse20062CommissionCommissionRates}
     * @memberof CosmosStakingV1beta1Commission
     */
    commission_rates?: InlineResponse20062CommissionCommissionRates;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Commission
     */
    update_time?: string;
}
/**
 * CommissionRates defines the initial commission rates to be used for creating a validator.
 * @export
 * @interface CosmosStakingV1beta1CommissionRates
 */
export interface CosmosStakingV1beta1CommissionRates {
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1CommissionRates
     */
    rate?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1CommissionRates
     */
    max_rate?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1CommissionRates
     */
    max_change_rate?: string;
}
/**
 * Delegation represents the bond with tokens held by an account. It is owned by one delegator, and is associated with the voting power of one validator.
 * @export
 * @interface CosmosStakingV1beta1Delegation
 */
export interface CosmosStakingV1beta1Delegation {
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Delegation
     */
    delegator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Delegation
     */
    validator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Delegation
     */
    shares?: string;
}
/**
 * DelegationResponse is equivalent to Delegation except that it contains a balance in addition to shares which is more suitable for client responses.
 * @export
 * @interface CosmosStakingV1beta1DelegationResponse
 */
export interface CosmosStakingV1beta1DelegationResponse {
    /**
     * 
     * @type {InlineResponse20059Delegation}
     * @memberof CosmosStakingV1beta1DelegationResponse
     */
    delegation?: InlineResponse20059Delegation;
    /**
     * 
     * @type {InlineResponse20027Balances}
     * @memberof CosmosStakingV1beta1DelegationResponse
     */
    balance?: InlineResponse20027Balances;
}
/**
 * Description defines a validator description.
 * @export
 * @interface CosmosStakingV1beta1Description
 */
export interface CosmosStakingV1beta1Description {
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Description
     */
    moniker?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Description
     */
    identity?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Description
     */
    website?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Description
     */
    security_contact?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Description
     */
    details?: string;
}
/**
 * HistoricalInfo contains header and validator information for a given block. It is stored as part of staking module\'s state, which persists the `n` most recent HistoricalInfo (`n` is set by the staking module\'s `historical_entries` parameter).
 * @export
 * @interface CosmosStakingV1beta1HistoricalInfo
 */
export interface CosmosStakingV1beta1HistoricalInfo {
    /**
     * 
     * @type {InlineResponse20031BlockHeader}
     * @memberof CosmosStakingV1beta1HistoricalInfo
     */
    header?: InlineResponse20031BlockHeader;
    /**
     * 
     * @type {Array<InlineResponse20062Validators>}
     * @memberof CosmosStakingV1beta1HistoricalInfo
     */
    valset?: Array<InlineResponse20062Validators>;
}
/**
 * Params defines the parameters for the staking module.
 * @export
 * @interface CosmosStakingV1beta1Params
 */
export interface CosmosStakingV1beta1Params {
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Params
     */
    unbonding_time?: string;
    /**
     * 
     * @type {number}
     * @memberof CosmosStakingV1beta1Params
     */
    max_validators?: number;
    /**
     * 
     * @type {number}
     * @memberof CosmosStakingV1beta1Params
     */
    max_entries?: number;
    /**
     * 
     * @type {number}
     * @memberof CosmosStakingV1beta1Params
     */
    historical_entries?: number;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Params
     */
    bond_denom?: string;
}
/**
 * Pool is used for tracking bonded and not-bonded token supply of the bond denomination.
 * @export
 * @interface CosmosStakingV1beta1Pool
 */
export interface CosmosStakingV1beta1Pool {
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Pool
     */
    not_bonded_tokens?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Pool
     */
    bonded_tokens?: string;
}
/**
 * QueryDelegationResponse is response type for the Query/Delegation RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryDelegationResponse
 */
export interface CosmosStakingV1beta1QueryDelegationResponse {
    /**
     * 
     * @type {InlineResponse20067DelegationResponse}
     * @memberof CosmosStakingV1beta1QueryDelegationResponse
     */
    delegation_response?: InlineResponse20067DelegationResponse;
}
/**
 * QueryDelegatorDelegationsResponse is response type for the Query/DelegatorDelegations RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryDelegatorDelegationsResponse
 */
export interface CosmosStakingV1beta1QueryDelegatorDelegationsResponse {
    /**
     * delegation_responses defines all the delegations\' info of a delegator.
     * @type {Array<InlineResponse20059DelegationResponses>}
     * @memberof CosmosStakingV1beta1QueryDelegatorDelegationsResponse
     */
    delegation_responses?: Array<InlineResponse20059DelegationResponses>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof CosmosStakingV1beta1QueryDelegatorDelegationsResponse
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * QueryUnbondingDelegatorDelegationsResponse is response type for the Query/UnbondingDelegatorDelegations RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryDelegatorUnbondingDelegationsResponse
 */
export interface CosmosStakingV1beta1QueryDelegatorUnbondingDelegationsResponse {
    /**
     * 
     * @type {Array<InlineResponse20061UnbondingResponses>}
     * @memberof CosmosStakingV1beta1QueryDelegatorUnbondingDelegationsResponse
     */
    unbonding_responses?: Array<InlineResponse20061UnbondingResponses>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof CosmosStakingV1beta1QueryDelegatorUnbondingDelegationsResponse
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * QueryDelegatorValidatorResponse response type for the Query/DelegatorValidator RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryDelegatorValidatorResponse
 */
export interface CosmosStakingV1beta1QueryDelegatorValidatorResponse {
    /**
     * 
     * @type {InlineResponse20063Validator}
     * @memberof CosmosStakingV1beta1QueryDelegatorValidatorResponse
     */
    validator?: InlineResponse20063Validator;
}
/**
 * QueryDelegatorValidatorsResponse is response type for the Query/DelegatorValidators RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryDelegatorValidatorsResponse
 */
export interface CosmosStakingV1beta1QueryDelegatorValidatorsResponse {
    /**
     * validators defines the the validators\' info of a delegator.
     * @type {Array<InlineResponse20062Validators>}
     * @memberof CosmosStakingV1beta1QueryDelegatorValidatorsResponse
     */
    validators?: Array<InlineResponse20062Validators>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof CosmosStakingV1beta1QueryDelegatorValidatorsResponse
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryHistoricalInfoResponse
 */
export interface CosmosStakingV1beta1QueryHistoricalInfoResponse {
    /**
     * 
     * @type {InlineResponse20064Hist}
     * @memberof CosmosStakingV1beta1QueryHistoricalInfoResponse
     */
    hist?: InlineResponse20064Hist;
}
/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryParamsResponse
 */
export interface CosmosStakingV1beta1QueryParamsResponse {
    /**
     * 
     * @type {InlineResponse20065Params}
     * @memberof CosmosStakingV1beta1QueryParamsResponse
     */
    params?: InlineResponse20065Params;
}
/**
 * QueryPoolResponse is response type for the Query/Pool RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryPoolResponse
 */
export interface CosmosStakingV1beta1QueryPoolResponse {
    /**
     * 
     * @type {InlineResponse20066Pool}
     * @memberof CosmosStakingV1beta1QueryPoolResponse
     */
    pool?: InlineResponse20066Pool;
}
/**
 * QueryRedelegationsResponse is response type for the Query/Redelegations RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryRedelegationsResponse
 */
export interface CosmosStakingV1beta1QueryRedelegationsResponse {
    /**
     * 
     * @type {Array<InlineResponse20060RedelegationResponses>}
     * @memberof CosmosStakingV1beta1QueryRedelegationsResponse
     */
    redelegation_responses?: Array<InlineResponse20060RedelegationResponses>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof CosmosStakingV1beta1QueryRedelegationsResponse
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * QueryDelegationResponse is response type for the Query/UnbondingDelegation RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryUnbondingDelegationResponse
 */
export interface CosmosStakingV1beta1QueryUnbondingDelegationResponse {
    /**
     * 
     * @type {InlineResponse20068Unbond}
     * @memberof CosmosStakingV1beta1QueryUnbondingDelegationResponse
     */
    unbond?: InlineResponse20068Unbond;
}
/**
 * 
 * @export
 * @interface CosmosStakingV1beta1QueryValidatorDelegationsResponse
 */
export interface CosmosStakingV1beta1QueryValidatorDelegationsResponse {
    /**
     * 
     * @type {Array<InlineResponse20059DelegationResponses>}
     * @memberof CosmosStakingV1beta1QueryValidatorDelegationsResponse
     */
    delegation_responses?: Array<InlineResponse20059DelegationResponses>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof CosmosStakingV1beta1QueryValidatorDelegationsResponse
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * 
 * @export
 * @interface CosmosStakingV1beta1QueryValidatorResponse
 */
export interface CosmosStakingV1beta1QueryValidatorResponse {
    /**
     * 
     * @type {InlineResponse20063Validator}
     * @memberof CosmosStakingV1beta1QueryValidatorResponse
     */
    validator?: InlineResponse20063Validator;
}
/**
 * QueryValidatorUnbondingDelegationsResponse is response type for the Query/ValidatorUnbondingDelegations RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryValidatorUnbondingDelegationsResponse
 */
export interface CosmosStakingV1beta1QueryValidatorUnbondingDelegationsResponse {
    /**
     * 
     * @type {Array<InlineResponse20061UnbondingResponses>}
     * @memberof CosmosStakingV1beta1QueryValidatorUnbondingDelegationsResponse
     */
    unbonding_responses?: Array<InlineResponse20061UnbondingResponses>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof CosmosStakingV1beta1QueryValidatorUnbondingDelegationsResponse
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * 
 * @export
 * @interface CosmosStakingV1beta1QueryValidatorsResponse
 */
export interface CosmosStakingV1beta1QueryValidatorsResponse {
    /**
     * validators contains all the queried validators.
     * @type {Array<InlineResponse20062Validators>}
     * @memberof CosmosStakingV1beta1QueryValidatorsResponse
     */
    validators?: Array<InlineResponse20062Validators>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof CosmosStakingV1beta1QueryValidatorsResponse
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * Redelegation contains the list of a particular delegator\'s redelegating bonds from a particular source validator to a particular destination validator.
 * @export
 * @interface CosmosStakingV1beta1Redelegation
 */
export interface CosmosStakingV1beta1Redelegation {
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Redelegation
     */
    delegator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Redelegation
     */
    validator_src_address?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Redelegation
     */
    validator_dst_address?: string;
    /**
     * 
     * @type {Array<InlineResponse20060RedelegationEntries>}
     * @memberof CosmosStakingV1beta1Redelegation
     */
    entries?: Array<InlineResponse20060RedelegationEntries>;
}
/**
 * RedelegationEntry defines a redelegation object with relevant metadata.
 * @export
 * @interface CosmosStakingV1beta1RedelegationEntry
 */
export interface CosmosStakingV1beta1RedelegationEntry {
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1RedelegationEntry
     */
    creation_height?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1RedelegationEntry
     */
    completion_time?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1RedelegationEntry
     */
    initial_balance?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1RedelegationEntry
     */
    shares_dst?: string;
}
/**
 * RedelegationEntryResponse is equivalent to a RedelegationEntry except that it contains a balance in addition to shares which is more suitable for client responses.
 * @export
 * @interface CosmosStakingV1beta1RedelegationEntryResponse
 */
export interface CosmosStakingV1beta1RedelegationEntryResponse {
    /**
     * 
     * @type {InlineResponse20060RedelegationEntries}
     * @memberof CosmosStakingV1beta1RedelegationEntryResponse
     */
    redelegation_entry?: InlineResponse20060RedelegationEntries;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1RedelegationEntryResponse
     */
    balance?: string;
}
/**
 * RedelegationResponse is equivalent to a Redelegation except that its entries contain a balance in addition to shares which is more suitable for client responses.
 * @export
 * @interface CosmosStakingV1beta1RedelegationResponse
 */
export interface CosmosStakingV1beta1RedelegationResponse {
    /**
     * 
     * @type {InlineResponse20060Redelegation}
     * @memberof CosmosStakingV1beta1RedelegationResponse
     */
    redelegation?: InlineResponse20060Redelegation;
    /**
     * 
     * @type {Array<InlineResponse20060Entries>}
     * @memberof CosmosStakingV1beta1RedelegationResponse
     */
    entries?: Array<InlineResponse20060Entries>;
}
/**
 * UnbondingDelegation stores all of a single delegator\'s unbonding bonds for a single validator in an time-ordered list.
 * @export
 * @interface CosmosStakingV1beta1UnbondingDelegation
 */
export interface CosmosStakingV1beta1UnbondingDelegation {
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1UnbondingDelegation
     */
    delegator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1UnbondingDelegation
     */
    validator_address?: string;
    /**
     * 
     * @type {Array<InlineResponse20061Entries>}
     * @memberof CosmosStakingV1beta1UnbondingDelegation
     */
    entries?: Array<InlineResponse20061Entries>;
}
/**
 * UnbondingDelegationEntry defines an unbonding object with relevant metadata.
 * @export
 * @interface CosmosStakingV1beta1UnbondingDelegationEntry
 */
export interface CosmosStakingV1beta1UnbondingDelegationEntry {
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1UnbondingDelegationEntry
     */
    creation_height?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1UnbondingDelegationEntry
     */
    completion_time?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1UnbondingDelegationEntry
     */
    initial_balance?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1UnbondingDelegationEntry
     */
    balance?: string;
}
/**
 * Validator defines a validator, together with the total amount of the Validator\'s bond shares and their exchange rate to coins. Slashing results in a decrease in the exchange rate, allowing correct calculation of future undelegations without iterating over delegators. When coins are delegated to this validator, the validator is credited with a delegation whose number of bond shares is based on the amount of coins delegated divided by the current exchange rate. Voting power can be calculated as total bonded shares multiplied by exchange rate.
 * @export
 * @interface CosmosStakingV1beta1Validator
 */
export interface CosmosStakingV1beta1Validator {
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Validator
     */
    operator_address?: string;
    /**
     * 
     * @type {InlineResponseDefaultDetails}
     * @memberof CosmosStakingV1beta1Validator
     */
    consensus_pubkey?: InlineResponseDefaultDetails;
    /**
     * 
     * @type {boolean}
     * @memberof CosmosStakingV1beta1Validator
     */
    jailed?: boolean;
    /**
     * BondStatus is the status of a validator.   - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.  - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.  - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.  - BOND_STATUS_BONDED: BONDED defines a validator that is bonded.
     * @type {string}
     * @memberof CosmosStakingV1beta1Validator
     */
    status?: CosmosStakingV1beta1ValidatorStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Validator
     */
    tokens?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Validator
     */
    delegator_shares?: string;
    /**
     * 
     * @type {InlineResponse20062Description}
     * @memberof CosmosStakingV1beta1Validator
     */
    description?: InlineResponse20062Description;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Validator
     */
    unbonding_height?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Validator
     */
    unbonding_time?: string;
    /**
     * 
     * @type {InlineResponse20062Commission}
     * @memberof CosmosStakingV1beta1Validator
     */
    commission?: InlineResponse20062Commission;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Validator
     */
    min_self_delegation?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum CosmosStakingV1beta1ValidatorStatusEnum {
    Unspecified = 'BOND_STATUS_UNSPECIFIED',
    Unbonded = 'BOND_STATUS_UNBONDED',
    Unbonding = 'BOND_STATUS_UNBONDING',
    Bonded = 'BOND_STATUS_BONDED'
}

/**
 * SignMode represents a signing mode with its own security guarantees.   - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be rejected  - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is verified with raw bytes from Tx  - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some human-readable textual representation on top of the binary representation from SIGN_MODE_DIRECT  - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses Amino JSON and will be removed in the future
 * @export
 * @enum {string}
 */
export enum CosmosTxSigningV1beta1SignMode {
    Unspecified = 'SIGN_MODE_UNSPECIFIED',
    Direct = 'SIGN_MODE_DIRECT',
    Textual = 'SIGN_MODE_TEXTUAL',
    LegacyAminoJson = 'SIGN_MODE_LEGACY_AMINO_JSON'
}

/**
 * AuthInfo describes the fee and signer modes that are used to sign a transaction.
 * @export
 * @interface CosmosTxV1beta1AuthInfo
 */
export interface CosmosTxV1beta1AuthInfo {
    /**
     * signer_infos defines the signing modes for the required signers. The number and order of elements must match the required signers from TxBody\'s messages. The first element is the primary signer and the one which pays the fee.
     * @type {Array<CosmosTxV1beta1SignerInfo>}
     * @memberof CosmosTxV1beta1AuthInfo
     */
    signer_infos?: Array<CosmosTxV1beta1SignerInfo>;
    /**
     * 
     * @type {CosmosTxV1beta1AuthInfoFee}
     * @memberof CosmosTxV1beta1AuthInfo
     */
    fee?: CosmosTxV1beta1AuthInfoFee;
}
/**
 * Fee is the fee and gas limit for the transaction. The first signer is the primary signer and the one which pays the fee. The fee can be calculated based on the cost of evaluating the body and doing signature verification of the signers. This can be estimated via simulation.
 * @export
 * @interface CosmosTxV1beta1AuthInfoFee
 */
export interface CosmosTxV1beta1AuthInfoFee {
    /**
     * 
     * @type {Array<InlineResponse20027Balances>}
     * @memberof CosmosTxV1beta1AuthInfoFee
     */
    amount?: Array<InlineResponse20027Balances>;
    /**
     * 
     * @type {string}
     * @memberof CosmosTxV1beta1AuthInfoFee
     */
    gas_limit?: string;
    /**
     * if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees. the payer must be a tx signer (and thus have signed this field in AuthInfo). setting this field does *not* change the ordering of required signers for the transaction.
     * @type {string}
     * @memberof CosmosTxV1beta1AuthInfoFee
     */
    payer?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosTxV1beta1AuthInfoFee
     */
    granter?: string;
}
/**
 * BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.   - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering  - BROADCAST_MODE_BLOCK: BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for the tx to be committed in a block.  - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for a CheckTx execution response only.  - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns immediately.
 * @export
 * @enum {string}
 */
export enum CosmosTxV1beta1BroadcastMode {
    Unspecified = 'BROADCAST_MODE_UNSPECIFIED',
    Block = 'BROADCAST_MODE_BLOCK',
    Sync = 'BROADCAST_MODE_SYNC',
    Async = 'BROADCAST_MODE_ASYNC'
}

/**
 * BroadcastTxRequest is the request type for the Service.BroadcastTxRequest RPC method.
 * @export
 * @interface CosmosTxV1beta1BroadcastTxRequest
 */
export interface CosmosTxV1beta1BroadcastTxRequest {
    /**
     * tx_bytes is the raw transaction.
     * @type {string}
     * @memberof CosmosTxV1beta1BroadcastTxRequest
     */
    tx_bytes?: string;
    /**
     * BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.   - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering  - BROADCAST_MODE_BLOCK: BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for the tx to be committed in a block.  - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for a CheckTx execution response only.  - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns immediately.
     * @type {string}
     * @memberof CosmosTxV1beta1BroadcastTxRequest
     */
    mode?: CosmosTxV1beta1BroadcastTxRequestModeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CosmosTxV1beta1BroadcastTxRequestModeEnum {
    Unspecified = 'BROADCAST_MODE_UNSPECIFIED',
    Block = 'BROADCAST_MODE_BLOCK',
    Sync = 'BROADCAST_MODE_SYNC',
    Async = 'BROADCAST_MODE_ASYNC'
}

/**
 * BroadcastTxResponse is the response type for the Service.BroadcastTx method.
 * @export
 * @interface CosmosTxV1beta1BroadcastTxResponse
 */
export interface CosmosTxV1beta1BroadcastTxResponse {
    /**
     * 
     * @type {InlineResponse20071TxResponse}
     * @memberof CosmosTxV1beta1BroadcastTxResponse
     */
    tx_response?: InlineResponse20071TxResponse;
}
/**
 * Fee includes the amount of coins paid in fees and the maximum gas to be used by the transaction. The ratio yields an effective \"gasprice\", which must be above some miminum to be accepted into the mempool.
 * @export
 * @interface CosmosTxV1beta1Fee
 */
export interface CosmosTxV1beta1Fee {
    /**
     * 
     * @type {Array<InlineResponse20027Balances>}
     * @memberof CosmosTxV1beta1Fee
     */
    amount?: Array<InlineResponse20027Balances>;
    /**
     * 
     * @type {string}
     * @memberof CosmosTxV1beta1Fee
     */
    gas_limit?: string;
    /**
     * if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees. the payer must be a tx signer (and thus have signed this field in AuthInfo). setting this field does *not* change the ordering of required signers for the transaction.
     * @type {string}
     * @memberof CosmosTxV1beta1Fee
     */
    payer?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosTxV1beta1Fee
     */
    granter?: string;
}
/**
 * GetTxResponse is the response type for the Service.GetTx method.
 * @export
 * @interface CosmosTxV1beta1GetTxResponse
 */
export interface CosmosTxV1beta1GetTxResponse {
    /**
     * 
     * @type {CosmosTxV1beta1Tx}
     * @memberof CosmosTxV1beta1GetTxResponse
     */
    tx?: CosmosTxV1beta1Tx;
    /**
     * 
     * @type {InlineResponse20071TxResponse}
     * @memberof CosmosTxV1beta1GetTxResponse
     */
    tx_response?: InlineResponse20071TxResponse;
}
/**
 * GetTxsEventResponse is the response type for the Service.TxsByEvents RPC method.
 * @export
 * @interface CosmosTxV1beta1GetTxsEventResponse
 */
export interface CosmosTxV1beta1GetTxsEventResponse {
    /**
     * txs is the list of queried transactions.
     * @type {Array<CosmosTxV1beta1Tx>}
     * @memberof CosmosTxV1beta1GetTxsEventResponse
     */
    txs?: Array<CosmosTxV1beta1Tx>;
    /**
     * tx_responses is the list of queried TxResponses.
     * @type {Array<CosmosTxV1beta1GetTxsEventResponseTxResponses>}
     * @memberof CosmosTxV1beta1GetTxsEventResponse
     */
    tx_responses?: Array<CosmosTxV1beta1GetTxsEventResponseTxResponses>;
    /**
     * 
     * @type {InlineResponse20035Pagination}
     * @memberof CosmosTxV1beta1GetTxsEventResponse
     */
    pagination?: InlineResponse20035Pagination;
}
/**
 * TxResponse defines a structure containing relevant tx data and metadata. The tags are stringified and the log is JSON decoded.
 * @export
 * @interface CosmosTxV1beta1GetTxsEventResponseTxResponses
 */
export interface CosmosTxV1beta1GetTxsEventResponseTxResponses {
    /**
     * 
     * @type {string}
     * @memberof CosmosTxV1beta1GetTxsEventResponseTxResponses
     */
    height?: string;
    /**
     * The transaction hash.
     * @type {string}
     * @memberof CosmosTxV1beta1GetTxsEventResponseTxResponses
     */
    txhash?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosTxV1beta1GetTxsEventResponseTxResponses
     */
    codespace?: string;
    /**
     * Response code.
     * @type {number}
     * @memberof CosmosTxV1beta1GetTxsEventResponseTxResponses
     */
    code?: number;
    /**
     * Result bytes, if any.
     * @type {string}
     * @memberof CosmosTxV1beta1GetTxsEventResponseTxResponses
     */
    data?: string;
    /**
     * The output of the application\'s logger (raw string). May be non-deterministic.
     * @type {string}
     * @memberof CosmosTxV1beta1GetTxsEventResponseTxResponses
     */
    raw_log?: string;
    /**
     * The output of the application\'s logger (typed). May be non-deterministic.
     * @type {Array<InlineResponse20071TxResponseLogs>}
     * @memberof CosmosTxV1beta1GetTxsEventResponseTxResponses
     */
    logs?: Array<InlineResponse20071TxResponseLogs>;
    /**
     * Additional information. May be non-deterministic.
     * @type {string}
     * @memberof CosmosTxV1beta1GetTxsEventResponseTxResponses
     */
    info?: string;
    /**
     * Amount of gas requested for transaction.
     * @type {string}
     * @memberof CosmosTxV1beta1GetTxsEventResponseTxResponses
     */
    gas_wanted?: string;
    /**
     * Amount of gas consumed by transaction.
     * @type {string}
     * @memberof CosmosTxV1beta1GetTxsEventResponseTxResponses
     */
    gas_used?: string;
    /**
     * 
     * @type {InlineResponse20071TxResponseTx}
     * @memberof CosmosTxV1beta1GetTxsEventResponseTxResponses
     */
    tx?: InlineResponse20071TxResponseTx;
    /**
     * Time of the previous block. For heights > 1, it\'s the weighted median of the timestamps of the valid votes in the block.LastCommit. For height == 1, it\'s genesis time.
     * @type {string}
     * @memberof CosmosTxV1beta1GetTxsEventResponseTxResponses
     */
    timestamp?: string;
}
/**
 * ModeInfo describes the signing mode of a single or nested multisig signer.
 * @export
 * @interface CosmosTxV1beta1ModeInfo
 */
export interface CosmosTxV1beta1ModeInfo {
    /**
     * 
     * @type {SingleRepresentsASingleSigner}
     * @memberof CosmosTxV1beta1ModeInfo
     */
    single?: SingleRepresentsASingleSigner;
    /**
     * 
     * @type {CosmosTxV1beta1ModeInfoMulti}
     * @memberof CosmosTxV1beta1ModeInfo
     */
    multi?: CosmosTxV1beta1ModeInfoMulti;
}
/**
 * 
 * @export
 * @interface CosmosTxV1beta1ModeInfoMulti
 */
export interface CosmosTxV1beta1ModeInfoMulti {
    /**
     * 
     * @type {BitarraySpecifiesWhichKeysWithinTheMultisigAreSigning}
     * @memberof CosmosTxV1beta1ModeInfoMulti
     */
    bitarray?: BitarraySpecifiesWhichKeysWithinTheMultisigAreSigning;
    /**
     * 
     * @type {Array<CosmosTxV1beta1ModeInfo>}
     * @memberof CosmosTxV1beta1ModeInfoMulti
     */
    mode_infos?: Array<CosmosTxV1beta1ModeInfo>;
}
/**
 * 
 * @export
 * @interface CosmosTxV1beta1ModeInfoSingle
 */
export interface CosmosTxV1beta1ModeInfoSingle {
    /**
     * SignMode represents a signing mode with its own security guarantees.   - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be rejected  - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is verified with raw bytes from Tx  - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some human-readable textual representation on top of the binary representation from SIGN_MODE_DIRECT  - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses Amino JSON and will be removed in the future
     * @type {string}
     * @memberof CosmosTxV1beta1ModeInfoSingle
     */
    mode?: CosmosTxV1beta1ModeInfoSingleModeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CosmosTxV1beta1ModeInfoSingleModeEnum {
    Unspecified = 'SIGN_MODE_UNSPECIFIED',
    Direct = 'SIGN_MODE_DIRECT',
    Textual = 'SIGN_MODE_TEXTUAL',
    LegacyAminoJson = 'SIGN_MODE_LEGACY_AMINO_JSON'
}

/**
 * SignerInfo describes the public key and signing mode of a single top-level signer.
 * @export
 * @interface CosmosTxV1beta1SignerInfo
 */
export interface CosmosTxV1beta1SignerInfo {
    /**
     * 
     * @type {CosmosTxV1beta1SignerInfoPublicKey}
     * @memberof CosmosTxV1beta1SignerInfo
     */
    public_key?: CosmosTxV1beta1SignerInfoPublicKey;
    /**
     * 
     * @type {CosmosTxV1beta1ModeInfo}
     * @memberof CosmosTxV1beta1SignerInfo
     */
    mode_info?: CosmosTxV1beta1ModeInfo;
    /**
     * sequence is the sequence of the account, which describes the number of committed transactions signed by a given address. It is used to prevent replay attacks.
     * @type {string}
     * @memberof CosmosTxV1beta1SignerInfo
     */
    sequence?: string;
}
/**
 * public_key is the public key of the signer. It is optional for accounts that already exist in state. If unset, the verifier can use the required \\ signer address for this position and lookup the public key.
 * @export
 * @interface CosmosTxV1beta1SignerInfoPublicKey
 */
export interface CosmosTxV1beta1SignerInfoPublicKey {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof CosmosTxV1beta1SignerInfoPublicKey
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof CosmosTxV1beta1SignerInfoPublicKey
     */
    value?: string;
}
/**
 * SimulateRequest is the request type for the Service.Simulate RPC method.
 * @export
 * @interface CosmosTxV1beta1SimulateRequest
 */
export interface CosmosTxV1beta1SimulateRequest {
    /**
     * 
     * @type {CosmosTxV1beta1Tx}
     * @memberof CosmosTxV1beta1SimulateRequest
     */
    tx?: CosmosTxV1beta1Tx;
}
/**
 * SimulateResponse is the response type for the Service.SimulateRPC method.
 * @export
 * @interface CosmosTxV1beta1SimulateResponse
 */
export interface CosmosTxV1beta1SimulateResponse {
    /**
     * 
     * @type {InlineResponse20070GasInfo}
     * @memberof CosmosTxV1beta1SimulateResponse
     */
    gas_info?: InlineResponse20070GasInfo;
    /**
     * 
     * @type {InlineResponse20070Result}
     * @memberof CosmosTxV1beta1SimulateResponse
     */
    result?: InlineResponse20070Result;
}
/**
 * Tx is the standard type used for broadcasting transactions.
 * @export
 * @interface CosmosTxV1beta1Tx
 */
export interface CosmosTxV1beta1Tx {
    /**
     * 
     * @type {BodyIsTheProcessableContentOfTheTransaction}
     * @memberof CosmosTxV1beta1Tx
     */
    body?: BodyIsTheProcessableContentOfTheTransaction;
    /**
     * 
     * @type {CosmosTxV1beta1AuthInfo}
     * @memberof CosmosTxV1beta1Tx
     */
    auth_info?: CosmosTxV1beta1AuthInfo;
    /**
     * signatures is a list of signatures that matches the length and order of AuthInfo\'s signer_infos to allow connecting signature meta information like public key and signing mode by position.
     * @type {Array<string>}
     * @memberof CosmosTxV1beta1Tx
     */
    signatures?: Array<string>;
}
/**
 * TxBody is the body of a transaction that all signers sign over.
 * @export
 * @interface CosmosTxV1beta1TxBody
 */
export interface CosmosTxV1beta1TxBody {
    /**
     * messages is a list of messages to be executed. The required signers of those messages define the number and order of elements in AuthInfo\'s signer_infos and Tx\'s signatures. Each required signer address is added to the list only the first time it occurs.  By convention, the first required signer (usually from the first message) is referred to as the primary signer and pays the fee for the whole transaction.
     * @type {Array<InlineResponseDefaultDetails>}
     * @memberof CosmosTxV1beta1TxBody
     */
    messages?: Array<InlineResponseDefaultDetails>;
    /**
     * 
     * @type {string}
     * @memberof CosmosTxV1beta1TxBody
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosTxV1beta1TxBody
     */
    timeout_height?: string;
    /**
     * 
     * @type {Array<InlineResponseDefaultDetails>}
     * @memberof CosmosTxV1beta1TxBody
     */
    extension_options?: Array<InlineResponseDefaultDetails>;
    /**
     * 
     * @type {Array<InlineResponseDefaultDetails>}
     * @memberof CosmosTxV1beta1TxBody
     */
    non_critical_extension_options?: Array<InlineResponseDefaultDetails>;
}
/**
 * Plan specifies information about a planned upgrade and when it should occur.
 * @export
 * @interface CosmosUpgradeV1beta1Plan
 */
export interface CosmosUpgradeV1beta1Plan {
    /**
     * Sets the name for the upgrade. This name will be used by the upgraded version of the software to apply any special \"on-upgrade\" commands during the first BeginBlock method after the upgrade is applied. It is also used to detect whether a software version can handle a given upgrade. If no upgrade handler with this name has been set in the software, it will be assumed that the software is out-of-date when the upgrade Time or Height is reached and the software will exit.
     * @type {string}
     * @memberof CosmosUpgradeV1beta1Plan
     */
    name?: string;
    /**
     * The time after which the upgrade must be performed. Leave set to its zero value to use a pre-defined Height instead.
     * @type {string}
     * @memberof CosmosUpgradeV1beta1Plan
     */
    time?: string;
    /**
     * The height at which the upgrade must be performed. Only used if Time is not set.
     * @type {string}
     * @memberof CosmosUpgradeV1beta1Plan
     */
    height?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosUpgradeV1beta1Plan
     */
    info?: string;
    /**
     * 
     * @type {IBCEnabledChainsCanOptInToIncludingTheUpgradedClientStateInItsUpgradePlanThisWillMakeTheChainCommitToTheCorrectUpgradedSelfClientStateBeforeTheUpgradeOccursSoThatConnectingChainsCanVerifyThatTheNewUpgradedClientIsValidByVerifyingAProofOnThePreviousVersionOfTheChainThisWillAllowIBCConnectionsToPersistSmoothlyAcrossPlannedChainUpgrades}
     * @memberof CosmosUpgradeV1beta1Plan
     */
    upgraded_client_state?: IBCEnabledChainsCanOptInToIncludingTheUpgradedClientStateInItsUpgradePlanThisWillMakeTheChainCommitToTheCorrectUpgradedSelfClientStateBeforeTheUpgradeOccursSoThatConnectingChainsCanVerifyThatTheNewUpgradedClientIsValidByVerifyingAProofOnThePreviousVersionOfTheChainThisWillAllowIBCConnectionsToPersistSmoothlyAcrossPlannedChainUpgrades;
}
/**
 * QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC method.
 * @export
 * @interface CosmosUpgradeV1beta1QueryAppliedPlanResponse
 */
export interface CosmosUpgradeV1beta1QueryAppliedPlanResponse {
    /**
     * height is the block height at which the plan was applied.
     * @type {string}
     * @memberof CosmosUpgradeV1beta1QueryAppliedPlanResponse
     */
    height?: string;
}
/**
 * QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC method.
 * @export
 * @interface CosmosUpgradeV1beta1QueryCurrentPlanResponse
 */
export interface CosmosUpgradeV1beta1QueryCurrentPlanResponse {
    /**
     * 
     * @type {InlineResponse20073Plan}
     * @memberof CosmosUpgradeV1beta1QueryCurrentPlanResponse
     */
    plan?: InlineResponse20073Plan;
}
/**
 * QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState RPC method.
 * @export
 * @interface CosmosUpgradeV1beta1QueryUpgradedConsensusStateResponse
 */
export interface CosmosUpgradeV1beta1QueryUpgradedConsensusStateResponse {
    /**
     * 
     * @type {InlineResponseDefaultDetails}
     * @memberof CosmosUpgradeV1beta1QueryUpgradedConsensusStateResponse
     */
    upgraded_consensus_state?: InlineResponseDefaultDetails;
}
/**
 * 
 * @export
 * @interface CounterpartyChannelEnd
 */
export interface CounterpartyChannelEnd {
    /**
     * port on the counterparty chain which owns the other end of the channel.
     * @type {string}
     * @memberof CounterpartyChannelEnd
     */
    port_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CounterpartyChannelEnd
     */
    channel_id?: string;
}
/**
 * 
 * @export
 * @interface DataContainsTheSetOfTransactionsIncludedInTheBlock
 */
export interface DataContainsTheSetOfTransactionsIncludedInTheBlock {
    /**
     * Txs that will be applied by state @ block.Height+1. NOTE: not all txs here are valid.  We\'re just agreeing on the order first. This means that block.AppHash does not include these txs.
     * @type {Array<string>}
     * @memberof DataContainsTheSetOfTransactionsIncludedInTheBlock
     */
    txs?: Array<string>;
}
/**
 * 
 * @export
 * @interface Delegation
 */
export interface Delegation {
    /**
     * 
     * @type {string}
     * @memberof Delegation
     */
    delegator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof Delegation
     */
    validator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof Delegation
     */
    shares?: string;
    /**
     * 
     * @type {InlineResponse2004TxFeeAmount}
     * @memberof Delegation
     */
    balance?: InlineResponse2004TxFeeAmount;
}
/**
 * 
 * @export
 * @interface DelegationDelegatorReward
 */
export interface DelegationDelegatorReward {
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof DelegationDelegatorReward
     */
    validator_address?: string;
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof DelegationDelegatorReward
     */
    reward?: Array<InlineResponse2004TxFeeAmount>;
}
/**
 * 
 * @export
 * @interface DelegatorTotalRewards
 */
export interface DelegatorTotalRewards {
    /**
     * 
     * @type {Array<InlineResponse20022Rewards>}
     * @memberof DelegatorTotalRewards
     */
    rewards?: Array<InlineResponse20022Rewards>;
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof DelegatorTotalRewards
     */
    total?: Array<InlineResponse2004TxFeeAmount>;
}
/**
 * 
 * @export
 * @interface DeliverTxResult
 */
export interface DeliverTxResult {
    /**
     * 
     * @type {number}
     * @memberof DeliverTxResult
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof DeliverTxResult
     */
    data?: string;
    /**
     * 
     * @type {number}
     * @memberof DeliverTxResult
     */
    gas_used?: number;
    /**
     * 
     * @type {number}
     * @memberof DeliverTxResult
     */
    gas_wanted?: number;
    /**
     * 
     * @type {string}
     * @memberof DeliverTxResult
     */
    info?: string;
    /**
     * 
     * @type {string}
     * @memberof DeliverTxResult
     */
    log?: string;
    /**
     * 
     * @type {Array<InlineResponse2004ResultTags>}
     * @memberof DeliverTxResult
     */
    tags?: Array<InlineResponse2004ResultTags>;
}
/**
 * 
 * @export
 * @interface Deposit
 */
export interface Deposit {
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof Deposit
     */
    amount?: Array<InlineResponse2004TxFeeAmount>;
    /**
     * 
     * @type {string}
     * @memberof Deposit
     */
    proposal_id?: string;
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof Deposit
     */
    depositor?: string;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface GoogleProtobufAny
 */
export interface GoogleProtobufAny {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface GovProposalsFinalTallyResult
 */
export interface GovProposalsFinalTallyResult {
    /**
     * 
     * @type {string}
     * @memberof GovProposalsFinalTallyResult
     */
    yes?: string;
    /**
     * 
     * @type {string}
     * @memberof GovProposalsFinalTallyResult
     */
    abstain?: string;
    /**
     * 
     * @type {string}
     * @memberof GovProposalsFinalTallyResult
     */
    no?: string;
    /**
     * 
     * @type {string}
     * @memberof GovProposalsFinalTallyResult
     */
    no_with_veto?: string;
}
/**
 * 
 * @export
 * @interface GovProposalsParamChangeChanges
 */
export interface GovProposalsParamChangeChanges {
    /**
     * 
     * @type {string}
     * @memberof GovProposalsParamChangeChanges
     */
    subspace?: string;
    /**
     * 
     * @type {string}
     * @memberof GovProposalsParamChangeChanges
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof GovProposalsParamChangeChanges
     */
    subkey?: string;
    /**
     * 
     * @type {object}
     * @memberof GovProposalsParamChangeChanges
     */
    value?: object;
}
/**
 * 
 * @export
 * @interface GrpcGatewayRuntimeError
 */
export interface GrpcGatewayRuntimeError {
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeError
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof GrpcGatewayRuntimeError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeError
     */
    message?: string;
    /**
     * 
     * @type {Array<InlineResponseDefaultDetails>}
     * @memberof GrpcGatewayRuntimeError
     */
    details?: Array<InlineResponseDefaultDetails>;
}
/**
 * Normally the RevisionHeight is incremented at each height while keeping RevisionNumber the same. However some consensus algorithms may choose to reset the height in certain conditions e.g. hard forks, state-machine breaking changes In these cases, the RevisionNumber is incremented so that height continues to be monitonically increasing even as the RevisionHeight gets reset
 * @export
 * @interface HeightAtWhichTheProofWasGenerated
 */
export interface HeightAtWhichTheProofWasGenerated {
    /**
     * 
     * @type {string}
     * @memberof HeightAtWhichTheProofWasGenerated
     */
    revision_number?: string;
    /**
     * 
     * @type {string}
     * @memberof HeightAtWhichTheProofWasGenerated
     */
    revision_height?: string;
}
/**
 * Normally the RevisionHeight is incremented at each height while keeping RevisionNumber the same. However some consensus algorithms may choose to reset the height in certain conditions e.g. hard forks, state-machine breaking changes In these cases, the RevisionNumber is incremented so that height continues to be monitonically increasing even as the RevisionHeight gets reset
 * @export
 * @interface HeightAtWhichTheProofWasRetrieved
 */
export interface HeightAtWhichTheProofWasRetrieved {
    /**
     * 
     * @type {string}
     * @memberof HeightAtWhichTheProofWasRetrieved
     */
    revision_number?: string;
    /**
     * 
     * @type {string}
     * @memberof HeightAtWhichTheProofWasRetrieved
     */
    revision_height?: string;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface IBCEnabledChainsCanOptInToIncludingTheUpgradedClientStateInItsUpgradePlanThisWillMakeTheChainCommitToTheCorrectUpgradedSelfClientStateBeforeTheUpgradeOccursSoThatConnectingChainsCanVerifyThatTheNewUpgradedClientIsValidByVerifyingAProofOnThePreviousVersionOfTheChainThisWillAllowIBCConnectionsToPersistSmoothlyAcrossPlannedChainUpgrades
 */
export interface IBCEnabledChainsCanOptInToIncludingTheUpgradedClientStateInItsUpgradePlanThisWillMakeTheChainCommitToTheCorrectUpgradedSelfClientStateBeforeTheUpgradeOccursSoThatConnectingChainsCanVerifyThatTheNewUpgradedClientIsValidByVerifyingAProofOnThePreviousVersionOfTheChainThisWillAllowIBCConnectionsToPersistSmoothlyAcrossPlannedChainUpgrades {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof IBCEnabledChainsCanOptInToIncludingTheUpgradedClientStateInItsUpgradePlanThisWillMakeTheChainCommitToTheCorrectUpgradedSelfClientStateBeforeTheUpgradeOccursSoThatConnectingChainsCanVerifyThatTheNewUpgradedClientIsValidByVerifyingAProofOnThePreviousVersionOfTheChainThisWillAllowIBCConnectionsToPersistSmoothlyAcrossPlannedChainUpgrades
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof IBCEnabledChainsCanOptInToIncludingTheUpgradedClientStateInItsUpgradePlanThisWillMakeTheChainCommitToTheCorrectUpgradedSelfClientStateBeforeTheUpgradeOccursSoThatConnectingChainsCanVerifyThatTheNewUpgradedClientIsValidByVerifyingAProofOnThePreviousVersionOfTheChainThisWillAllowIBCConnectionsToPersistSmoothlyAcrossPlannedChainUpgrades
     */
    value?: string;
}
/**
 * DenomTrace contains the base denomination for ICS20 fungible tokens and the source tracing information path.
 * @export
 * @interface IbcApplicationsTransferV1DenomTrace
 */
export interface IbcApplicationsTransferV1DenomTrace {
    /**
     * path defines the chain of port/channel identifiers used for tracing the source of the fungible token.
     * @type {string}
     * @memberof IbcApplicationsTransferV1DenomTrace
     */
    path?: string;
    /**
     * base denomination of the relayed fungible token.
     * @type {string}
     * @memberof IbcApplicationsTransferV1DenomTrace
     */
    base_denom?: string;
}
/**
 * Params defines the set of IBC transfer parameters. NOTE: To prevent a single token from being transferred, set the TransfersEnabled parameter to true and then set the bank module\'s SendEnabled parameter for the denomination to false.
 * @export
 * @interface IbcApplicationsTransferV1Params
 */
export interface IbcApplicationsTransferV1Params {
    /**
     * send_enabled enables or disables all cross-chain token transfers from this chain.
     * @type {boolean}
     * @memberof IbcApplicationsTransferV1Params
     */
    send_enabled?: boolean;
    /**
     * receive_enabled enables or disables all cross-chain token transfers to this chain.
     * @type {boolean}
     * @memberof IbcApplicationsTransferV1Params
     */
    receive_enabled?: boolean;
}
/**
 * QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC method.
 * @export
 * @interface IbcApplicationsTransferV1QueryDenomTraceResponse
 */
export interface IbcApplicationsTransferV1QueryDenomTraceResponse {
    /**
     * 
     * @type {InlineResponse20083DenomTrace}
     * @memberof IbcApplicationsTransferV1QueryDenomTraceResponse
     */
    denom_trace?: InlineResponse20083DenomTrace;
}
/**
 * QueryConnectionsResponse is the response type for the Query/DenomTraces RPC method.
 * @export
 * @interface IbcApplicationsTransferV1QueryDenomTracesResponse
 */
export interface IbcApplicationsTransferV1QueryDenomTracesResponse {
    /**
     * denom_traces returns all denominations trace information.
     * @type {Array<InlineResponse20082DenomTraces>}
     * @memberof IbcApplicationsTransferV1QueryDenomTracesResponse
     */
    denom_traces?: Array<InlineResponse20082DenomTraces>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof IbcApplicationsTransferV1QueryDenomTracesResponse
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface IbcApplicationsTransferV1QueryParamsResponse
 */
export interface IbcApplicationsTransferV1QueryParamsResponse {
    /**
     * 
     * @type {InlineResponse20084Params}
     * @memberof IbcApplicationsTransferV1QueryParamsResponse
     */
    params?: InlineResponse20084Params;
}
/**
 * Channel defines pipeline for exactly-once packet delivery between specific modules on separate blockchains, which has at least one end capable of sending packets and one end capable of receiving packets.
 * @export
 * @interface IbcCoreChannelV1Channel
 */
export interface IbcCoreChannelV1Channel {
    /**
     * State defines if a channel is in one of the following states: CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.   - STATE_UNINITIALIZED_UNSPECIFIED: Default State  - STATE_INIT: A channel has just started the opening handshake.  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.  - STATE_OPEN: A channel has completed the handshake. Open channels are ready to send and receive packets.  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive packets.
     * @type {string}
     * @memberof IbcCoreChannelV1Channel
     */
    state?: IbcCoreChannelV1ChannelStateEnum;
    /**
     * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in which they were sent.  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
     * @type {string}
     * @memberof IbcCoreChannelV1Channel
     */
    ordering?: IbcCoreChannelV1ChannelOrderingEnum;
    /**
     * 
     * @type {CounterpartyChannelEnd}
     * @memberof IbcCoreChannelV1Channel
     */
    counterparty?: CounterpartyChannelEnd;
    /**
     * 
     * @type {Array<string>}
     * @memberof IbcCoreChannelV1Channel
     */
    connection_hops?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1Channel
     */
    version?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum IbcCoreChannelV1ChannelStateEnum {
    UninitializedUnspecified = 'STATE_UNINITIALIZED_UNSPECIFIED',
    Init = 'STATE_INIT',
    Tryopen = 'STATE_TRYOPEN',
    Open = 'STATE_OPEN',
    Closed = 'STATE_CLOSED'
}
/**
    * @export
    * @enum {string}
    */
export enum IbcCoreChannelV1ChannelOrderingEnum {
    NoneUnspecified = 'ORDER_NONE_UNSPECIFIED',
    Unordered = 'ORDER_UNORDERED',
    Ordered = 'ORDER_ORDERED'
}

/**
 * 
 * @export
 * @interface IbcCoreChannelV1Counterparty
 */
export interface IbcCoreChannelV1Counterparty {
    /**
     * port on the counterparty chain which owns the other end of the channel.
     * @type {string}
     * @memberof IbcCoreChannelV1Counterparty
     */
    port_id?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1Counterparty
     */
    channel_id?: string;
}
/**
 * IdentifiedChannel defines a channel with additional port and channel identifier fields.
 * @export
 * @interface IbcCoreChannelV1IdentifiedChannel
 */
export interface IbcCoreChannelV1IdentifiedChannel {
    /**
     * State defines if a channel is in one of the following states: CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.   - STATE_UNINITIALIZED_UNSPECIFIED: Default State  - STATE_INIT: A channel has just started the opening handshake.  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.  - STATE_OPEN: A channel has completed the handshake. Open channels are ready to send and receive packets.  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive packets.
     * @type {string}
     * @memberof IbcCoreChannelV1IdentifiedChannel
     */
    state?: IbcCoreChannelV1IdentifiedChannelStateEnum;
    /**
     * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in which they were sent.  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
     * @type {string}
     * @memberof IbcCoreChannelV1IdentifiedChannel
     */
    ordering?: IbcCoreChannelV1IdentifiedChannelOrderingEnum;
    /**
     * 
     * @type {CounterpartyChannelEnd}
     * @memberof IbcCoreChannelV1IdentifiedChannel
     */
    counterparty?: CounterpartyChannelEnd;
    /**
     * 
     * @type {Array<string>}
     * @memberof IbcCoreChannelV1IdentifiedChannel
     */
    connection_hops?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1IdentifiedChannel
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1IdentifiedChannel
     */
    port_id?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1IdentifiedChannel
     */
    channel_id?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum IbcCoreChannelV1IdentifiedChannelStateEnum {
    UninitializedUnspecified = 'STATE_UNINITIALIZED_UNSPECIFIED',
    Init = 'STATE_INIT',
    Tryopen = 'STATE_TRYOPEN',
    Open = 'STATE_OPEN',
    Closed = 'STATE_CLOSED'
}
/**
    * @export
    * @enum {string}
    */
export enum IbcCoreChannelV1IdentifiedChannelOrderingEnum {
    NoneUnspecified = 'ORDER_NONE_UNSPECIFIED',
    Unordered = 'ORDER_UNORDERED',
    Ordered = 'ORDER_ORDERED'
}

/**
 * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in which they were sent.  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
 * @export
 * @enum {string}
 */
export enum IbcCoreChannelV1Order {
    NoneUnspecified = 'ORDER_NONE_UNSPECIFIED',
    Unordered = 'ORDER_UNORDERED',
    Ordered = 'ORDER_ORDERED'
}

/**
 * PacketState defines the generic type necessary to retrieve and store packet commitments, acknowledgements, and receipts. Caller is responsible for knowing the context necessary to interpret this state as a commitment, acknowledgement, or a receipt.
 * @export
 * @interface IbcCoreChannelV1PacketState
 */
export interface IbcCoreChannelV1PacketState {
    /**
     * channel port identifier.
     * @type {string}
     * @memberof IbcCoreChannelV1PacketState
     */
    port_id?: string;
    /**
     * channel unique identifier.
     * @type {string}
     * @memberof IbcCoreChannelV1PacketState
     */
    channel_id?: string;
    /**
     * packet sequence.
     * @type {string}
     * @memberof IbcCoreChannelV1PacketState
     */
    sequence?: string;
    /**
     * embedded data that represents packet state.
     * @type {string}
     * @memberof IbcCoreChannelV1PacketState
     */
    data?: string;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryChannelClientStateResponse
 */
export interface IbcCoreChannelV1QueryChannelClientStateResponse {
    /**
     * 
     * @type {ClientStateAssociatedWithTheChannel}
     * @memberof IbcCoreChannelV1QueryChannelClientStateResponse
     */
    identified_client_state?: ClientStateAssociatedWithTheChannel;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryChannelClientStateResponse
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreChannelV1QueryChannelClientStateResponse
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryChannelConsensusStateResponse
 */
export interface IbcCoreChannelV1QueryChannelConsensusStateResponse {
    /**
     * 
     * @type {ConsensusStateAssociatedWithTheChannel}
     * @memberof IbcCoreChannelV1QueryChannelConsensusStateResponse
     */
    consensus_state?: ConsensusStateAssociatedWithTheChannel;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryChannelConsensusStateResponse
     */
    client_id?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryChannelConsensusStateResponse
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreChannelV1QueryChannelConsensusStateResponse
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * QueryChannelResponse is the response type for the Query/Channel RPC method. Besides the Channel end, it includes a proof and the height from which the proof was retrieved.
 * @export
 * @interface IbcCoreChannelV1QueryChannelResponse
 */
export interface IbcCoreChannelV1QueryChannelResponse {
    /**
     * 
     * @type {ChannelAssociatedWithTheRequestIdentifiers}
     * @memberof IbcCoreChannelV1QueryChannelResponse
     */
    channel?: ChannelAssociatedWithTheRequestIdentifiers;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryChannelResponse
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreChannelV1QueryChannelResponse
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * QueryChannelsResponse is the response type for the Query/Channels RPC method.
 * @export
 * @interface IbcCoreChannelV1QueryChannelsResponse
 */
export interface IbcCoreChannelV1QueryChannelsResponse {
    /**
     * list of stored channels of the chain.
     * @type {Array<InlineResponse20075Channels>}
     * @memberof IbcCoreChannelV1QueryChannelsResponse
     */
    channels?: Array<InlineResponse20075Channels>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof IbcCoreChannelV1QueryChannelsResponse
     */
    pagination?: PaginationResponse;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof IbcCoreChannelV1QueryChannelsResponse
     */
    height?: QueryBlockHeight;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryConnectionChannelsResponse
 */
export interface IbcCoreChannelV1QueryConnectionChannelsResponse {
    /**
     * list of channels associated with a connection.
     * @type {Array<InlineResponse20075Channels>}
     * @memberof IbcCoreChannelV1QueryConnectionChannelsResponse
     */
    channels?: Array<InlineResponse20075Channels>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof IbcCoreChannelV1QueryConnectionChannelsResponse
     */
    pagination?: PaginationResponse;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof IbcCoreChannelV1QueryConnectionChannelsResponse
     */
    height?: QueryBlockHeight;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryNextSequenceReceiveResponse
 */
export interface IbcCoreChannelV1QueryNextSequenceReceiveResponse {
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryNextSequenceReceiveResponse
     */
    next_sequence_receive?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryNextSequenceReceiveResponse
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreChannelV1QueryNextSequenceReceiveResponse
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryPacketAcknowledgementResponse
 */
export interface IbcCoreChannelV1QueryPacketAcknowledgementResponse {
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryPacketAcknowledgementResponse
     */
    acknowledgement?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryPacketAcknowledgementResponse
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreChannelV1QueryPacketAcknowledgementResponse
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryPacketAcknowledgementsResponse
 */
export interface IbcCoreChannelV1QueryPacketAcknowledgementsResponse {
    /**
     * 
     * @type {Array<QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgements>}
     * @memberof IbcCoreChannelV1QueryPacketAcknowledgementsResponse
     */
    acknowledgements?: Array<QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgements>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof IbcCoreChannelV1QueryPacketAcknowledgementsResponse
     */
    pagination?: PaginationResponse;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof IbcCoreChannelV1QueryPacketAcknowledgementsResponse
     */
    height?: QueryBlockHeight;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryPacketCommitmentResponse
 */
export interface IbcCoreChannelV1QueryPacketCommitmentResponse {
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryPacketCommitmentResponse
     */
    commitment?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryPacketCommitmentResponse
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreChannelV1QueryPacketCommitmentResponse
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryPacketCommitmentsResponse
 */
export interface IbcCoreChannelV1QueryPacketCommitmentsResponse {
    /**
     * 
     * @type {Array<QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgements>}
     * @memberof IbcCoreChannelV1QueryPacketCommitmentsResponse
     */
    commitments?: Array<QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgements>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof IbcCoreChannelV1QueryPacketCommitmentsResponse
     */
    pagination?: PaginationResponse;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof IbcCoreChannelV1QueryPacketCommitmentsResponse
     */
    height?: QueryBlockHeight;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryPacketReceiptResponse
 */
export interface IbcCoreChannelV1QueryPacketReceiptResponse {
    /**
     * 
     * @type {boolean}
     * @memberof IbcCoreChannelV1QueryPacketReceiptResponse
     */
    received?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreChannelV1QueryPacketReceiptResponse
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreChannelV1QueryPacketReceiptResponse
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryUnreceivedAcksResponse
 */
export interface IbcCoreChannelV1QueryUnreceivedAcksResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof IbcCoreChannelV1QueryUnreceivedAcksResponse
     */
    sequences?: Array<string>;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof IbcCoreChannelV1QueryUnreceivedAcksResponse
     */
    height?: QueryBlockHeight;
}
/**
 * 
 * @export
 * @interface IbcCoreChannelV1QueryUnreceivedPacketsResponse
 */
export interface IbcCoreChannelV1QueryUnreceivedPacketsResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof IbcCoreChannelV1QueryUnreceivedPacketsResponse
     */
    sequences?: Array<string>;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof IbcCoreChannelV1QueryUnreceivedPacketsResponse
     */
    height?: QueryBlockHeight;
}
/**
 * State defines if a channel is in one of the following states: CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.   - STATE_UNINITIALIZED_UNSPECIFIED: Default State  - STATE_INIT: A channel has just started the opening handshake.  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.  - STATE_OPEN: A channel has completed the handshake. Open channels are ready to send and receive packets.  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive packets.
 * @export
 * @enum {string}
 */
export enum IbcCoreChannelV1State {
    UninitializedUnspecified = 'STATE_UNINITIALIZED_UNSPECIFIED',
    Init = 'STATE_INIT',
    Tryopen = 'STATE_TRYOPEN',
    Open = 'STATE_OPEN',
    Closed = 'STATE_CLOSED'
}

/**
 * ConsensusStateWithHeight defines a consensus state with an additional height field.
 * @export
 * @interface IbcCoreClientV1ConsensusStateWithHeight
 */
export interface IbcCoreClientV1ConsensusStateWithHeight {
    /**
     * 
     * @type {ConsensusStateHeight}
     * @memberof IbcCoreClientV1ConsensusStateWithHeight
     */
    height?: ConsensusStateHeight;
    /**
     * 
     * @type {ConsensusState}
     * @memberof IbcCoreClientV1ConsensusStateWithHeight
     */
    consensus_state?: ConsensusState;
}
/**
 * Normally the RevisionHeight is incremented at each height while keeping RevisionNumber the same. However some consensus algorithms may choose to reset the height in certain conditions e.g. hard forks, state-machine breaking changes In these cases, the RevisionNumber is incremented so that height continues to be monitonically increasing even as the RevisionHeight gets reset
 * @export
 * @interface IbcCoreClientV1Height
 */
export interface IbcCoreClientV1Height {
    /**
     * 
     * @type {string}
     * @memberof IbcCoreClientV1Height
     */
    revision_number?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreClientV1Height
     */
    revision_height?: string;
}
/**
 * IdentifiedClientState defines a client state with an additional client identifier field.
 * @export
 * @interface IbcCoreClientV1IdentifiedClientState
 */
export interface IbcCoreClientV1IdentifiedClientState {
    /**
     * 
     * @type {string}
     * @memberof IbcCoreClientV1IdentifiedClientState
     */
    client_id?: string;
    /**
     * 
     * @type {ClientState}
     * @memberof IbcCoreClientV1IdentifiedClientState
     */
    client_state?: ClientState;
}
/**
 * Params defines the set of IBC light client parameters.
 * @export
 * @interface IbcCoreClientV1Params
 */
export interface IbcCoreClientV1Params {
    /**
     * allowed_clients defines the list of allowed client state types.
     * @type {Array<string>}
     * @memberof IbcCoreClientV1Params
     */
    allowed_clients?: Array<string>;
}
/**
 * QueryClientParamsResponse is the response type for the Query/ClientParams RPC method.
 * @export
 * @interface IbcCoreClientV1QueryClientParamsResponse
 */
export interface IbcCoreClientV1QueryClientParamsResponse {
    /**
     * 
     * @type {InlineResponse20077Params}
     * @memberof IbcCoreClientV1QueryClientParamsResponse
     */
    params?: InlineResponse20077Params;
}
/**
 * QueryClientStateResponse is the response type for the Query/ClientState RPC method. Besides the client state, it includes a proof and the height from which the proof was retrieved.
 * @export
 * @interface IbcCoreClientV1QueryClientStateResponse
 */
export interface IbcCoreClientV1QueryClientStateResponse {
    /**
     * 
     * @type {ClientStateAssociatedWithTheRequestIdentifier}
     * @memberof IbcCoreClientV1QueryClientStateResponse
     */
    client_state?: ClientStateAssociatedWithTheRequestIdentifier;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreClientV1QueryClientStateResponse
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreClientV1QueryClientStateResponse
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * QueryClientStatesResponse is the response type for the Query/ClientStates RPC method.
 * @export
 * @interface IbcCoreClientV1QueryClientStatesResponse
 */
export interface IbcCoreClientV1QueryClientStatesResponse {
    /**
     * list of stored ClientStates of the chain.
     * @type {Array<InlineResponse20078ClientStates>}
     * @memberof IbcCoreClientV1QueryClientStatesResponse
     */
    client_states?: Array<InlineResponse20078ClientStates>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof IbcCoreClientV1QueryClientStatesResponse
     */
    pagination?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface IbcCoreClientV1QueryConsensusStateResponse
 */
export interface IbcCoreClientV1QueryConsensusStateResponse {
    /**
     * 
     * @type {ConsensusStateAssociatedWithTheClientIdentifierAtTheGivenHeight}
     * @memberof IbcCoreClientV1QueryConsensusStateResponse
     */
    consensus_state?: ConsensusStateAssociatedWithTheClientIdentifierAtTheGivenHeight;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreClientV1QueryConsensusStateResponse
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreClientV1QueryConsensusStateResponse
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface IbcCoreClientV1QueryConsensusStatesResponse
 */
export interface IbcCoreClientV1QueryConsensusStatesResponse {
    /**
     * 
     * @type {Array<QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethodConsensusStates>}
     * @memberof IbcCoreClientV1QueryConsensusStatesResponse
     */
    consensus_states?: Array<QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethodConsensusStates>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof IbcCoreClientV1QueryConsensusStatesResponse
     */
    pagination?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface IbcCoreCommitmentV1MerklePrefix
 */
export interface IbcCoreCommitmentV1MerklePrefix {
    /**
     * 
     * @type {string}
     * @memberof IbcCoreCommitmentV1MerklePrefix
     */
    key_prefix?: string;
}
/**
 * ConnectionEnd defines a stateful object on a chain connected to another separate one. NOTE: there must only be 2 defined ConnectionEnds to establish a connection between two chains.
 * @export
 * @interface IbcCoreConnectionV1ConnectionEnd
 */
export interface IbcCoreConnectionV1ConnectionEnd {
    /**
     * client associated with this connection.
     * @type {string}
     * @memberof IbcCoreConnectionV1ConnectionEnd
     */
    client_id?: string;
    /**
     * IBC version which can be utilised to determine encodings or protocols for channels or packets utilising this connection.
     * @type {Array<InlineResponse20080Versions>}
     * @memberof IbcCoreConnectionV1ConnectionEnd
     */
    versions?: Array<InlineResponse20080Versions>;
    /**
     * current state of the connection end.
     * @type {string}
     * @memberof IbcCoreConnectionV1ConnectionEnd
     */
    state?: IbcCoreConnectionV1ConnectionEndStateEnum;
    /**
     * 
     * @type {InlineResponse20080Counterparty}
     * @memberof IbcCoreConnectionV1ConnectionEnd
     */
    counterparty?: InlineResponse20080Counterparty;
    /**
     * delay period that must pass before a consensus state can be used for packet-verification NOTE: delay period logic is only implemented by some clients.
     * @type {string}
     * @memberof IbcCoreConnectionV1ConnectionEnd
     */
    delay_period?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum IbcCoreConnectionV1ConnectionEndStateEnum {
    UninitializedUnspecified = 'STATE_UNINITIALIZED_UNSPECIFIED',
    Init = 'STATE_INIT',
    Tryopen = 'STATE_TRYOPEN',
    Open = 'STATE_OPEN'
}

/**
 * Counterparty defines the counterparty chain associated with a connection end.
 * @export
 * @interface IbcCoreConnectionV1Counterparty
 */
export interface IbcCoreConnectionV1Counterparty {
    /**
     * identifies the client on the counterparty chain associated with a given connection.
     * @type {string}
     * @memberof IbcCoreConnectionV1Counterparty
     */
    client_id?: string;
    /**
     * identifies the connection end on the counterparty chain associated with a given connection.
     * @type {string}
     * @memberof IbcCoreConnectionV1Counterparty
     */
    connection_id?: string;
    /**
     * 
     * @type {MerklePrefixIsMerklePathPrefixedToTheKeyTheConstructedKeyFromThePathAndTheKeyWillBeAppendPathKeyPathAppendPathKeyPrefixKey}
     * @memberof IbcCoreConnectionV1Counterparty
     */
    prefix?: MerklePrefixIsMerklePathPrefixedToTheKeyTheConstructedKeyFromThePathAndTheKeyWillBeAppendPathKeyPathAppendPathKeyPrefixKey;
}
/**
 * IdentifiedConnection defines a connection with additional connection identifier field.
 * @export
 * @interface IbcCoreConnectionV1IdentifiedConnection
 */
export interface IbcCoreConnectionV1IdentifiedConnection {
    /**
     * connection identifier.
     * @type {string}
     * @memberof IbcCoreConnectionV1IdentifiedConnection
     */
    id?: string;
    /**
     * client associated with this connection.
     * @type {string}
     * @memberof IbcCoreConnectionV1IdentifiedConnection
     */
    client_id?: string;
    /**
     * 
     * @type {Array<InlineResponse20080Versions>}
     * @memberof IbcCoreConnectionV1IdentifiedConnection
     */
    versions?: Array<InlineResponse20080Versions>;
    /**
     * current state of the connection end.
     * @type {string}
     * @memberof IbcCoreConnectionV1IdentifiedConnection
     */
    state?: IbcCoreConnectionV1IdentifiedConnectionStateEnum;
    /**
     * 
     * @type {InlineResponse20080Counterparty}
     * @memberof IbcCoreConnectionV1IdentifiedConnection
     */
    counterparty?: InlineResponse20080Counterparty;
    /**
     * delay period associated with this connection.
     * @type {string}
     * @memberof IbcCoreConnectionV1IdentifiedConnection
     */
    delay_period?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum IbcCoreConnectionV1IdentifiedConnectionStateEnum {
    UninitializedUnspecified = 'STATE_UNINITIALIZED_UNSPECIFIED',
    Init = 'STATE_INIT',
    Tryopen = 'STATE_TRYOPEN',
    Open = 'STATE_OPEN'
}

/**
 * 
 * @export
 * @interface IbcCoreConnectionV1QueryClientConnectionsResponse
 */
export interface IbcCoreConnectionV1QueryClientConnectionsResponse {
    /**
     * slice of all the connection paths associated with a client.
     * @type {Array<string>}
     * @memberof IbcCoreConnectionV1QueryClientConnectionsResponse
     */
    connection_paths?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreConnectionV1QueryClientConnectionsResponse
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasGenerated}
     * @memberof IbcCoreConnectionV1QueryClientConnectionsResponse
     */
    proof_height?: HeightAtWhichTheProofWasGenerated;
}
/**
 * 
 * @export
 * @interface IbcCoreConnectionV1QueryConnectionClientStateResponse
 */
export interface IbcCoreConnectionV1QueryConnectionClientStateResponse {
    /**
     * 
     * @type {ClientStateAssociatedWithTheChannel}
     * @memberof IbcCoreConnectionV1QueryConnectionClientStateResponse
     */
    identified_client_state?: ClientStateAssociatedWithTheChannel;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreConnectionV1QueryConnectionClientStateResponse
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreConnectionV1QueryConnectionClientStateResponse
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface IbcCoreConnectionV1QueryConnectionConsensusStateResponse
 */
export interface IbcCoreConnectionV1QueryConnectionConsensusStateResponse {
    /**
     * 
     * @type {ConsensusStateAssociatedWithTheChannel}
     * @memberof IbcCoreConnectionV1QueryConnectionConsensusStateResponse
     */
    consensus_state?: ConsensusStateAssociatedWithTheChannel;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreConnectionV1QueryConnectionConsensusStateResponse
     */
    client_id?: string;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreConnectionV1QueryConnectionConsensusStateResponse
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreConnectionV1QueryConnectionConsensusStateResponse
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * QueryConnectionResponse is the response type for the Query/Connection RPC method. Besides the connection end, it includes a proof and the height from which the proof was retrieved.
 * @export
 * @interface IbcCoreConnectionV1QueryConnectionResponse
 */
export interface IbcCoreConnectionV1QueryConnectionResponse {
    /**
     * 
     * @type {ConnectionAssociatedWithTheRequestIdentifier}
     * @memberof IbcCoreConnectionV1QueryConnectionResponse
     */
    connection?: ConnectionAssociatedWithTheRequestIdentifier;
    /**
     * 
     * @type {string}
     * @memberof IbcCoreConnectionV1QueryConnectionResponse
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof IbcCoreConnectionV1QueryConnectionResponse
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * QueryConnectionsResponse is the response type for the Query/Connections RPC method.
 * @export
 * @interface IbcCoreConnectionV1QueryConnectionsResponse
 */
export interface IbcCoreConnectionV1QueryConnectionsResponse {
    /**
     * list of stored connections of the chain.
     * @type {Array<InlineResponse20080Connections>}
     * @memberof IbcCoreConnectionV1QueryConnectionsResponse
     */
    connections?: Array<InlineResponse20080Connections>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof IbcCoreConnectionV1QueryConnectionsResponse
     */
    pagination?: PaginationResponse;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof IbcCoreConnectionV1QueryConnectionsResponse
     */
    height?: QueryBlockHeight;
}
/**
 * State defines if a connection is in one of the following states: INIT, TRYOPEN, OPEN or UNINITIALIZED.   - STATE_UNINITIALIZED_UNSPECIFIED: Default State  - STATE_INIT: A connection end has just started the opening handshake.  - STATE_TRYOPEN: A connection end has acknowledged the handshake step on the counterparty chain.  - STATE_OPEN: A connection end has completed the handshake.
 * @export
 * @enum {string}
 */
export enum IbcCoreConnectionV1State {
    UninitializedUnspecified = 'STATE_UNINITIALIZED_UNSPECIFIED',
    Init = 'STATE_INIT',
    Tryopen = 'STATE_TRYOPEN',
    Open = 'STATE_OPEN'
}

/**
 * Version defines the versioning scheme used to negotiate the IBC verison in the connection handshake.
 * @export
 * @interface IbcCoreConnectionV1Version
 */
export interface IbcCoreConnectionV1Version {
    /**
     * 
     * @type {string}
     * @memberof IbcCoreConnectionV1Version
     */
    identifier?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IbcCoreConnectionV1Version
     */
    features?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {InlineResponse2004Tx}
     * @memberof InlineObject
     */
    tx?: InlineResponse2004Tx;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    mode?: string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {InlineResponse2004Tx}
     * @memberof InlineObject1
     */
    tx?: InlineResponse2004Tx;
}
/**
 * 
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
    /**
     * 
     * @type {BankAccountsAddressTransfersBaseReq}
     * @memberof InlineObject10
     */
    base_req?: BankAccountsAddressTransfersBaseReq;
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof InlineObject10
     */
    depositor?: string;
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof InlineObject10
     */
    amount?: Array<InlineResponse2004TxFeeAmount>;
}
/**
 * 
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
    /**
     * 
     * @type {BankAccountsAddressTransfersBaseReq}
     * @memberof InlineObject11
     */
    base_req?: BankAccountsAddressTransfersBaseReq;
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof InlineObject11
     */
    voter?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    option?: string;
}
/**
 * 
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
    /**
     * 
     * @type {BankAccountsAddressTransfersBaseReq}
     * @memberof InlineObject12
     */
    base_req?: BankAccountsAddressTransfersBaseReq;
}
/**
 * 
 * @export
 * @interface InlineObject13
 */
export interface InlineObject13 {
    /**
     * 
     * @type {BankAccountsAddressTransfersBaseReq}
     * @memberof InlineObject13
     */
    base_req?: BankAccountsAddressTransfersBaseReq;
}
/**
 * 
 * @export
 * @interface InlineObject14
 */
export interface InlineObject14 {
    /**
     * 
     * @type {BankAccountsAddressTransfersBaseReq}
     * @memberof InlineObject14
     */
    base_req?: BankAccountsAddressTransfersBaseReq;
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof InlineObject14
     */
    withdraw_address?: string;
}
/**
 * 
 * @export
 * @interface InlineObject15
 */
export interface InlineObject15 {
    /**
     * 
     * @type {BankAccountsAddressTransfersBaseReq}
     * @memberof InlineObject15
     */
    base_req?: BankAccountsAddressTransfersBaseReq;
}
/**
 * BroadcastTxRequest is the request type for the Service.BroadcastTxRequest RPC method.
 * @export
 * @interface InlineObject16
 */
export interface InlineObject16 {
    /**
     * tx_bytes is the raw transaction.
     * @type {string}
     * @memberof InlineObject16
     */
    tx_bytes?: string;
    /**
     * BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.   - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering  - BROADCAST_MODE_BLOCK: BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for the tx to be committed in a block.  - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for a CheckTx execution response only.  - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns immediately.
     * @type {string}
     * @memberof InlineObject16
     */
    mode?: InlineObject16ModeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject16ModeEnum {
    Unspecified = 'BROADCAST_MODE_UNSPECIFIED',
    Block = 'BROADCAST_MODE_BLOCK',
    Sync = 'BROADCAST_MODE_SYNC',
    Async = 'BROADCAST_MODE_ASYNC'
}

/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    tx?: string;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {BankAccountsAddressTransfersBaseReq}
     * @memberof InlineObject3
     */
    base_req?: BankAccountsAddressTransfersBaseReq;
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof InlineObject3
     */
    amount?: Array<InlineResponse2004TxFeeAmount>;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * 
     * @type {BankAccountsAddressTransfersBaseReq}
     * @memberof InlineObject4
     */
    base_req?: BankAccountsAddressTransfersBaseReq;
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof InlineObject4
     */
    delegator_address?: string;
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof InlineObject4
     */
    validator_address?: string;
    /**
     * 
     * @type {InlineResponse2004TxFeeAmount}
     * @memberof InlineObject4
     */
    delegation?: InlineResponse2004TxFeeAmount;
}
/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * 
     * @type {BankAccountsAddressTransfersBaseReq}
     * @memberof InlineObject5
     */
    base_req?: BankAccountsAddressTransfersBaseReq;
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof InlineObject5
     */
    delegator_address?: string;
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof InlineObject5
     */
    validator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    shares?: string;
}
/**
 * 
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * 
     * @type {BankAccountsAddressTransfersBaseReq}
     * @memberof InlineObject6
     */
    base_req?: BankAccountsAddressTransfersBaseReq;
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof InlineObject6
     */
    delegator_address?: string;
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof InlineObject6
     */
    validator_src_addressess?: string;
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof InlineObject6
     */
    validator_dst_address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    shares?: string;
}
/**
 * 
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
    /**
     * 
     * @type {InlineResponse2004Tx}
     * @memberof InlineObject7
     */
    base_req?: InlineResponse2004Tx;
}
/**
 * 
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
    /**
     * 
     * @type {BankAccountsAddressTransfersBaseReq}
     * @memberof InlineObject8
     */
    base_req?: BankAccountsAddressTransfersBaseReq;
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    proposal_type?: string;
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof InlineObject8
     */
    proposer?: string;
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof InlineObject8
     */
    initial_deposit?: Array<InlineResponse2004TxFeeAmount>;
}
/**
 * 
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
    /**
     * 
     * @type {BankAccountsAddressTransfersBaseReq}
     * @memberof InlineObject9
     */
    base_req?: BankAccountsAddressTransfersBaseReq;
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    description?: string;
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof InlineObject9
     */
    proposer?: string;
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof InlineObject9
     */
    deposit?: Array<InlineResponse2004TxFeeAmount>;
    /**
     * 
     * @type {Array<GovProposalsParamChangeChanges>}
     * @memberof InlineObject9
     */
    changes?: Array<GovProposalsParamChangeChanges>;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {InlineResponse200ApplicationVersion}
     * @memberof InlineResponse200
     */
    application_version?: InlineResponse200ApplicationVersion;
    /**
     * 
     * @type {InlineResponse200NodeInfo}
     * @memberof InlineResponse200
     */
    node_info?: InlineResponse200NodeInfo;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2001
     */
    syncing?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010
     */
    delegator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010
     */
    validator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010
     */
    initial_balance?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010
     */
    balance?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20010
     */
    creation_height?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20010
     */
    min_time?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    delegator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    validator_address?: string;
    /**
     * 
     * @type {Array<InlineResponse20011Entries>}
     * @memberof InlineResponse20011
     */
    entries?: Array<InlineResponse20011Entries>;
}
/**
 * 
 * @export
 * @interface InlineResponse20011Entries
 */
export interface InlineResponse20011Entries {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011Entries
     */
    initial_balance?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011Entries
     */
    balance?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011Entries
     */
    creation_height?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011Entries
     */
    min_time?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof InlineResponse20012
     */
    operator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012
     */
    consensus_pubkey?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20012
     */
    jailed?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20012
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012
     */
    tokens?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012
     */
    delegator_shares?: string;
    /**
     * 
     * @type {StakingDelegatorsDelegatorAddrValidatorsDescription}
     * @memberof InlineResponse20012
     */
    description?: StakingDelegatorsDelegatorAddrValidatorsDescription;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012
     */
    bond_height?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20012
     */
    bond_intra_tx_counter?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012
     */
    unbonding_height?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012
     */
    unbonding_time?: string;
    /**
     * 
     * @type {StakingDelegatorsDelegatorAddrValidatorsCommission}
     * @memberof InlineResponse20012
     */
    commission?: StakingDelegatorsDelegatorAddrValidatorsCommission;
}
/**
 * 
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013
     */
    loose_tokens?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013
     */
    bonded_tokens?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013
     */
    inflation_last_time?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013
     */
    inflation?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013
     */
    date_last_commission_reset?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013
     */
    prev_bonded_shares?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014
     */
    inflation_rate_change?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014
     */
    inflation_max?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014
     */
    inflation_min?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014
     */
    goal_bonded?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014
     */
    unbonding_time?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20014
     */
    max_validators?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014
     */
    bond_denom?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015
     */
    start_height?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015
     */
    index_offset?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015
     */
    jailed_until?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015
     */
    missed_blocks_counter?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20016
     */
    max_evidence_age?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20016
     */
    signed_blocks_window?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20016
     */
    min_signed_per_window?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20016
     */
    double_sign_unbond_duration?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20016
     */
    downtime_unbond_duration?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20016
     */
    slash_fraction_double_sign?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20016
     */
    slash_fraction_downtime?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20017
     */
    proposal_id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017
     */
    proposal_type?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017
     */
    proposal_status?: string;
    /**
     * 
     * @type {GovProposalsFinalTallyResult}
     * @memberof InlineResponse20017
     */
    final_tally_result?: GovProposalsFinalTallyResult;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017
     */
    submit_time?: string;
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof InlineResponse20017
     */
    total_deposit?: Array<InlineResponse2004TxFeeAmount>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017
     */
    voting_start_time?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20018
 */
export interface InlineResponse20018 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20018
     */
    proposal_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20018
     */
    proposer?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20019
 */
export interface InlineResponse20019 {
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof InlineResponse20019
     */
    amount?: Array<InlineResponse2004TxFeeAmount>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20019
     */
    proposal_id?: string;
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof InlineResponse20019
     */
    depositor?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {InlineResponse2002BlockMeta}
     * @memberof InlineResponse2002
     */
    block_meta?: InlineResponse2002BlockMeta;
    /**
     * 
     * @type {InlineResponse2002Block}
     * @memberof InlineResponse2002
     */
    block?: InlineResponse2002Block;
}
/**
 * 
 * @export
 * @interface InlineResponse20020
 */
export interface InlineResponse20020 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20020
     */
    voter?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20020
     */
    proposal_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20020
     */
    option?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20021
 */
export interface InlineResponse20021 {
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof InlineResponse20021
     */
    min_deposit?: Array<InlineResponse2004TxFeeAmount>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20021
     */
    max_deposit_period?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20022
 */
export interface InlineResponse20022 {
    /**
     * 
     * @type {Array<InlineResponse20022Rewards>}
     * @memberof InlineResponse20022
     */
    rewards?: Array<InlineResponse20022Rewards>;
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof InlineResponse20022
     */
    total?: Array<InlineResponse2004TxFeeAmount>;
}
/**
 * 
 * @export
 * @interface InlineResponse20022Rewards
 */
export interface InlineResponse20022Rewards {
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof InlineResponse20022Rewards
     */
    validator_address?: string;
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof InlineResponse20022Rewards
     */
    reward?: Array<InlineResponse2004TxFeeAmount>;
}
/**
 * 
 * @export
 * @interface InlineResponse20023
 */
export interface InlineResponse20023 {
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof InlineResponse20023
     */
    operator_address?: string;
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof InlineResponse20023
     */
    self_bond_rewards?: Array<InlineResponse2004TxFeeAmount>;
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof InlineResponse20023
     */
    val_commission?: Array<InlineResponse2004TxFeeAmount>;
}
/**
 * 
 * @export
 * @interface InlineResponse20024
 */
export interface InlineResponse20024 {
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof InlineResponse20024
     */
    total?: Array<InlineResponse2004TxFeeAmount>;
}
/**
 * QueryAccountResponse is the response type for the Query/Account RPC method.
 * @export
 * @interface InlineResponse20025
 */
export interface InlineResponse20025 {
    /**
     * 
     * @type {InlineResponse20025Account}
     * @memberof InlineResponse20025
     */
    account?: InlineResponse20025Account;
}
/**
 * account defines the account of the corresponding address.
 * @export
 * @interface InlineResponse20025Account
 */
export interface InlineResponse20025Account {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof InlineResponse20025Account
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof InlineResponse20025Account
     */
    value?: string;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface InlineResponse20026
 */
export interface InlineResponse20026 {
    /**
     * 
     * @type {InlineResponse20026Params}
     * @memberof InlineResponse20026
     */
    params?: InlineResponse20026Params;
}
/**
 * params defines the parameters of the module.
 * @export
 * @interface InlineResponse20026Params
 */
export interface InlineResponse20026Params {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20026Params
     */
    max_memo_characters?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20026Params
     */
    tx_sig_limit?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20026Params
     */
    tx_size_cost_per_byte?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20026Params
     */
    sig_verify_cost_ed25519?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20026Params
     */
    sig_verify_cost_secp256k1?: string;
}
/**
 * QueryAllBalancesResponse is the response type for the Query/AllBalances RPC method.
 * @export
 * @interface InlineResponse20027
 */
export interface InlineResponse20027 {
    /**
     * balances is the balances of all the coins.
     * @type {Array<InlineResponse20027Balances>}
     * @memberof InlineResponse20027
     */
    balances?: Array<InlineResponse20027Balances>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof InlineResponse20027
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface InlineResponse20027Balances
 */
export interface InlineResponse20027Balances {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20027Balances
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20027Balances
     */
    amount?: string;
}
/**
 * pagination defines the pagination in the response.
 * @export
 * @interface InlineResponse20027Pagination
 */
export interface InlineResponse20027Pagination {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20027Pagination
     */
    next_key?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20027Pagination
     */
    total?: string;
}
/**
 * QueryBalanceResponse is the response type for the Query/Balance RPC method.
 * @export
 * @interface InlineResponse20028
 */
export interface InlineResponse20028 {
    /**
     * 
     * @type {InlineResponse20028Balance}
     * @memberof InlineResponse20028
     */
    balance?: InlineResponse20028Balance;
}
/**
 * balance is the balance of the coin.
 * @export
 * @interface InlineResponse20028Balance
 */
export interface InlineResponse20028Balance {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20028Balance
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20028Balance
     */
    amount?: string;
}
/**
 * QueryParamsResponse defines the response type for querying x/bank parameters.
 * @export
 * @interface InlineResponse20029
 */
export interface InlineResponse20029 {
    /**
     * 
     * @type {InlineResponse20029Params}
     * @memberof InlineResponse20029
     */
    params?: InlineResponse20029Params;
}
/**
 * Params defines the parameters for the bank module.
 * @export
 * @interface InlineResponse20029Params
 */
export interface InlineResponse20029Params {
    /**
     * 
     * @type {Array<InlineResponse20029ParamsSendEnabled>}
     * @memberof InlineResponse20029Params
     */
    send_enabled?: Array<InlineResponse20029ParamsSendEnabled>;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20029Params
     */
    default_send_enabled?: boolean;
}
/**
 * SendEnabled maps coin denom to a send_enabled status (whether a denom is sendable).
 * @export
 * @interface InlineResponse20029ParamsSendEnabled
 */
export interface InlineResponse20029ParamsSendEnabled {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20029ParamsSendEnabled
     */
    denom?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20029ParamsSendEnabled
     */
    enabled?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2002Block
 */
export interface InlineResponse2002Block {
    /**
     * 
     * @type {InlineResponse2002BlockMetaHeader}
     * @memberof InlineResponse2002Block
     */
    header?: InlineResponse2002BlockMetaHeader;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse2002Block
     */
    txs?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse2002Block
     */
    evidence?: Array<string>;
    /**
     * 
     * @type {InlineResponse2002BlockLastCommit}
     * @memberof InlineResponse2002Block
     */
    last_commit?: InlineResponse2002BlockLastCommit;
}
/**
 * 
 * @export
 * @interface InlineResponse2002BlockLastCommit
 */
export interface InlineResponse2002BlockLastCommit {
    /**
     * 
     * @type {InlineResponse2002BlockMetaHeaderLastBlockId}
     * @memberof InlineResponse2002BlockLastCommit
     */
    block_id?: InlineResponse2002BlockMetaHeaderLastBlockId;
    /**
     * 
     * @type {Array<InlineResponse2002BlockLastCommitPrecommits>}
     * @memberof InlineResponse2002BlockLastCommit
     */
    precommits?: Array<InlineResponse2002BlockLastCommitPrecommits>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002BlockLastCommitPrecommits
 */
export interface InlineResponse2002BlockLastCommitPrecommits {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002BlockLastCommitPrecommits
     */
    validator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002BlockLastCommitPrecommits
     */
    validator_index?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002BlockLastCommitPrecommits
     */
    height?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002BlockLastCommitPrecommits
     */
    round?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002BlockLastCommitPrecommits
     */
    timestamp?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002BlockLastCommitPrecommits
     */
    type?: number;
    /**
     * 
     * @type {InlineResponse2002BlockMetaHeaderLastBlockId}
     * @memberof InlineResponse2002BlockLastCommitPrecommits
     */
    block_id?: InlineResponse2002BlockMetaHeaderLastBlockId;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002BlockLastCommitPrecommits
     */
    signature?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2002BlockMeta
 */
export interface InlineResponse2002BlockMeta {
    /**
     * 
     * @type {InlineResponse2002BlockMetaHeader}
     * @memberof InlineResponse2002BlockMeta
     */
    header?: InlineResponse2002BlockMetaHeader;
    /**
     * 
     * @type {InlineResponse2002BlockMetaHeaderLastBlockId}
     * @memberof InlineResponse2002BlockMeta
     */
    block_id?: InlineResponse2002BlockMetaHeaderLastBlockId;
}
/**
 * 
 * @export
 * @interface InlineResponse2002BlockMetaHeader
 */
export interface InlineResponse2002BlockMetaHeader {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002BlockMetaHeader
     */
    chain_id?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002BlockMetaHeader
     */
    height?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002BlockMetaHeader
     */
    time?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002BlockMetaHeader
     */
    num_txs?: number;
    /**
     * 
     * @type {InlineResponse2002BlockMetaHeaderLastBlockId}
     * @memberof InlineResponse2002BlockMetaHeader
     */
    last_block_id?: InlineResponse2002BlockMetaHeaderLastBlockId;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002BlockMetaHeader
     */
    total_txs?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002BlockMetaHeader
     */
    last_commit_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002BlockMetaHeader
     */
    data_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002BlockMetaHeader
     */
    validators_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002BlockMetaHeader
     */
    next_validators_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002BlockMetaHeader
     */
    consensus_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002BlockMetaHeader
     */
    app_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002BlockMetaHeader
     */
    last_results_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002BlockMetaHeader
     */
    evidence_hash?: string;
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof InlineResponse2002BlockMetaHeader
     */
    proposer_address?: string;
    /**
     * 
     * @type {InlineResponse2002BlockMetaHeaderVersion}
     * @memberof InlineResponse2002BlockMetaHeader
     */
    version?: InlineResponse2002BlockMetaHeaderVersion;
}
/**
 * 
 * @export
 * @interface InlineResponse2002BlockMetaHeaderLastBlockId
 */
export interface InlineResponse2002BlockMetaHeaderLastBlockId {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002BlockMetaHeaderLastBlockId
     */
    hash?: string;
    /**
     * 
     * @type {InlineResponse2002BlockMetaHeaderLastBlockIdParts}
     * @memberof InlineResponse2002BlockMetaHeaderLastBlockId
     */
    parts?: InlineResponse2002BlockMetaHeaderLastBlockIdParts;
}
/**
 * 
 * @export
 * @interface InlineResponse2002BlockMetaHeaderLastBlockIdParts
 */
export interface InlineResponse2002BlockMetaHeaderLastBlockIdParts {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002BlockMetaHeaderLastBlockIdParts
     */
    total?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002BlockMetaHeaderLastBlockIdParts
     */
    hash?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2002BlockMetaHeaderVersion
 */
export interface InlineResponse2002BlockMetaHeaderVersion {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002BlockMetaHeaderVersion
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002BlockMetaHeaderVersion
     */
    app?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    block_height?: string;
    /**
     * 
     * @type {Array<InlineResponse2003Validators>}
     * @memberof InlineResponse2003
     */
    validators?: Array<InlineResponse2003Validators>;
}
/**
 * QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method.
 * @export
 * @interface InlineResponse20030
 */
export interface InlineResponse20030 {
    /**
     * 
     * @type {InlineResponse20030Amount}
     * @memberof InlineResponse20030
     */
    amount?: InlineResponse20030Amount;
}
/**
 * amount is the supply of the coin.
 * @export
 * @interface InlineResponse20030Amount
 */
export interface InlineResponse20030Amount {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030Amount
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030Amount
     */
    amount?: string;
}
/**
 * GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method.
 * @export
 * @interface InlineResponse20031
 */
export interface InlineResponse20031 {
    /**
     * 
     * @type {BlockID1}
     * @memberof InlineResponse20031
     */
    block_id?: BlockID1;
    /**
     * 
     * @type {InlineResponse20031Block}
     * @memberof InlineResponse20031
     */
    block?: InlineResponse20031Block;
}
/**
 * 
 * @export
 * @interface InlineResponse20031Block
 */
export interface InlineResponse20031Block {
    /**
     * 
     * @type {InlineResponse20031BlockHeader}
     * @memberof InlineResponse20031Block
     */
    header?: InlineResponse20031BlockHeader;
    /**
     * 
     * @type {DataContainsTheSetOfTransactionsIncludedInTheBlock}
     * @memberof InlineResponse20031Block
     */
    data?: DataContainsTheSetOfTransactionsIncludedInTheBlock;
    /**
     * 
     * @type {InlineResponse20031BlockEvidence}
     * @memberof InlineResponse20031Block
     */
    evidence?: InlineResponse20031BlockEvidence;
    /**
     * 
     * @type {InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit}
     * @memberof InlineResponse20031Block
     */
    last_commit?: InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit;
}
/**
 * 
 * @export
 * @interface InlineResponse20031BlockEvidence
 */
export interface InlineResponse20031BlockEvidence {
    /**
     * 
     * @type {Array<InlineResponse20031BlockEvidenceEvidence>}
     * @memberof InlineResponse20031BlockEvidence
     */
    evidence?: Array<InlineResponse20031BlockEvidenceEvidence>;
}
/**
 * DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.
 * @export
 * @interface InlineResponse20031BlockEvidenceDuplicateVoteEvidence
 */
export interface InlineResponse20031BlockEvidenceDuplicateVoteEvidence {
    /**
     * 
     * @type {InlineResponse20031BlockEvidenceDuplicateVoteEvidenceVoteA}
     * @memberof InlineResponse20031BlockEvidenceDuplicateVoteEvidence
     */
    vote_a?: InlineResponse20031BlockEvidenceDuplicateVoteEvidenceVoteA;
    /**
     * 
     * @type {InlineResponse20031BlockEvidenceDuplicateVoteEvidenceVoteA}
     * @memberof InlineResponse20031BlockEvidenceDuplicateVoteEvidence
     */
    vote_b?: InlineResponse20031BlockEvidenceDuplicateVoteEvidenceVoteA;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockEvidenceDuplicateVoteEvidence
     */
    total_voting_power?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockEvidenceDuplicateVoteEvidence
     */
    validator_power?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockEvidenceDuplicateVoteEvidence
     */
    timestamp?: string;
}
/**
 * Vote represents a prevote, precommit, or commit vote from validators for consensus.
 * @export
 * @interface InlineResponse20031BlockEvidenceDuplicateVoteEvidenceVoteA
 */
export interface InlineResponse20031BlockEvidenceDuplicateVoteEvidenceVoteA {
    /**
     * SignedMsgType is a type of signed message in the consensus.   - SIGNED_MSG_TYPE_PREVOTE: Votes  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
     * @type {string}
     * @memberof InlineResponse20031BlockEvidenceDuplicateVoteEvidenceVoteA
     */
    type?: InlineResponse20031BlockEvidenceDuplicateVoteEvidenceVoteATypeEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockEvidenceDuplicateVoteEvidenceVoteA
     */
    height?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20031BlockEvidenceDuplicateVoteEvidenceVoteA
     */
    round?: number;
    /**
     * 
     * @type {BlockID1}
     * @memberof InlineResponse20031BlockEvidenceDuplicateVoteEvidenceVoteA
     */
    block_id?: BlockID1;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockEvidenceDuplicateVoteEvidenceVoteA
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockEvidenceDuplicateVoteEvidenceVoteA
     */
    validator_address?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20031BlockEvidenceDuplicateVoteEvidenceVoteA
     */
    validator_index?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockEvidenceDuplicateVoteEvidenceVoteA
     */
    signature?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20031BlockEvidenceDuplicateVoteEvidenceVoteATypeEnum {
    Unknown = 'SIGNED_MSG_TYPE_UNKNOWN',
    Prevote = 'SIGNED_MSG_TYPE_PREVOTE',
    Precommit = 'SIGNED_MSG_TYPE_PRECOMMIT',
    Proposal = 'SIGNED_MSG_TYPE_PROPOSAL'
}

/**
 * 
 * @export
 * @interface InlineResponse20031BlockEvidenceEvidence
 */
export interface InlineResponse20031BlockEvidenceEvidence {
    /**
     * 
     * @type {InlineResponse20031BlockEvidenceDuplicateVoteEvidence}
     * @memberof InlineResponse20031BlockEvidenceEvidence
     */
    duplicate_vote_evidence?: InlineResponse20031BlockEvidenceDuplicateVoteEvidence;
    /**
     * 
     * @type {InlineResponse20031BlockEvidenceLightClientAttackEvidence}
     * @memberof InlineResponse20031BlockEvidenceEvidence
     */
    light_client_attack_evidence?: InlineResponse20031BlockEvidenceLightClientAttackEvidence;
}
/**
 * LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.
 * @export
 * @interface InlineResponse20031BlockEvidenceLightClientAttackEvidence
 */
export interface InlineResponse20031BlockEvidenceLightClientAttackEvidence {
    /**
     * 
     * @type {InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlock}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidence
     */
    conflicting_block?: InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlock;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidence
     */
    common_height?: string;
    /**
     * 
     * @type {Array<InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidators>}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidence
     */
    byzantine_validators?: Array<InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidators>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidence
     */
    total_voting_power?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidence
     */
    timestamp?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlock
 */
export interface InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlock {
    /**
     * 
     * @type {InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlock
     */
    signed_header?: InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader;
    /**
     * 
     * @type {InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlock
     */
    validator_set?: InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet;
}
/**
 * 
 * @export
 * @interface InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader
 */
export interface InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader {
    /**
     * 
     * @type {InlineResponse20031BlockHeader}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader
     */
    header?: InlineResponse20031BlockHeader;
    /**
     * 
     * @type {InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader
     */
    commit?: InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit;
}
/**
 * Commit contains the evidence that a block was committed by a set of validators.
 * @export
 * @interface InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit
 */
export interface InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit
     */
    height?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit
     */
    round?: number;
    /**
     * 
     * @type {BlockID1}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit
     */
    block_id?: BlockID1;
    /**
     * 
     * @type {Array<InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignatures>}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit
     */
    signatures?: Array<InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignatures>;
}
/**
 * CommitSig is a part of the Vote included in a Commit.
 * @export
 * @interface InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignatures
 */
export interface InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignatures {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignatures
     */
    block_id_flag?: InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesBlockIdFlagEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignatures
     */
    validator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignatures
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignatures
     */
    signature?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesBlockIdFlagEnum {
    Unknown = 'BLOCK_ID_FLAG_UNKNOWN',
    Absent = 'BLOCK_ID_FLAG_ABSENT',
    Commit = 'BLOCK_ID_FLAG_COMMIT',
    Nil = 'BLOCK_ID_FLAG_NIL'
}

/**
 * 
 * @export
 * @interface InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet
 */
export interface InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet {
    /**
     * 
     * @type {Array<InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidators>}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet
     */
    validators?: Array<InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidators>;
    /**
     * 
     * @type {InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidators}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet
     */
    proposer?: InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidators;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet
     */
    total_voting_power?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidators
 */
export interface InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidators {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidators
     */
    address?: string;
    /**
     * 
     * @type {PublicKeyDefinesTheKeysAvailableForUseWithTendermintValidators}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidators
     */
    pub_key?: PublicKeyDefinesTheKeysAvailableForUseWithTendermintValidators;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidators
     */
    voting_power?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidators
     */
    proposer_priority?: string;
}
/**
 * Header defines the structure of a Tendermint block header.
 * @export
 * @interface InlineResponse20031BlockHeader
 */
export interface InlineResponse20031BlockHeader {
    /**
     * 
     * @type {BasicBlockInfo}
     * @memberof InlineResponse20031BlockHeader
     */
    version?: BasicBlockInfo;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockHeader
     */
    chain_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockHeader
     */
    height?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockHeader
     */
    time?: string;
    /**
     * 
     * @type {PrevBlockInfo}
     * @memberof InlineResponse20031BlockHeader
     */
    last_block_id?: PrevBlockInfo;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockHeader
     */
    last_commit_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockHeader
     */
    data_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockHeader
     */
    validators_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockHeader
     */
    next_validators_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockHeader
     */
    consensus_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockHeader
     */
    app_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockHeader
     */
    last_results_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockHeader
     */
    evidence_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031BlockHeader
     */
    proposer_address?: string;
}
/**
 * GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method.
 * @export
 * @interface InlineResponse20032
 */
export interface InlineResponse20032 {
    /**
     * 
     * @type {BlockID1}
     * @memberof InlineResponse20032
     */
    block_id?: BlockID1;
    /**
     * 
     * @type {InlineResponse20031Block}
     * @memberof InlineResponse20032
     */
    block?: InlineResponse20031Block;
}
/**
 * GetNodeInfoResponse is the request type for the Query/GetNodeInfo RPC method.
 * @export
 * @interface InlineResponse20033
 */
export interface InlineResponse20033 {
    /**
     * 
     * @type {InlineResponse20033DefaultNodeInfo}
     * @memberof InlineResponse20033
     */
    default_node_info?: InlineResponse20033DefaultNodeInfo;
    /**
     * 
     * @type {InlineResponse20033ApplicationVersion}
     * @memberof InlineResponse20033
     */
    application_version?: InlineResponse20033ApplicationVersion;
}
/**
 * VersionInfo is the type for the GetNodeInfoResponse message.
 * @export
 * @interface InlineResponse20033ApplicationVersion
 */
export interface InlineResponse20033ApplicationVersion {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033ApplicationVersion
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033ApplicationVersion
     */
    app_name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033ApplicationVersion
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033ApplicationVersion
     */
    git_commit?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033ApplicationVersion
     */
    build_tags?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033ApplicationVersion
     */
    go_version?: string;
    /**
     * 
     * @type {Array<ModuleIsTheTypeForVersionInfo>}
     * @memberof InlineResponse20033ApplicationVersion
     */
    build_deps?: Array<ModuleIsTheTypeForVersionInfo>;
}
/**
 * 
 * @export
 * @interface InlineResponse20033DefaultNodeInfo
 */
export interface InlineResponse20033DefaultNodeInfo {
    /**
     * 
     * @type {InlineResponse20033DefaultNodeInfoProtocolVersion}
     * @memberof InlineResponse20033DefaultNodeInfo
     */
    protocol_version?: InlineResponse20033DefaultNodeInfoProtocolVersion;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033DefaultNodeInfo
     */
    default_node_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033DefaultNodeInfo
     */
    listen_addr?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033DefaultNodeInfo
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033DefaultNodeInfo
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033DefaultNodeInfo
     */
    channels?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033DefaultNodeInfo
     */
    moniker?: string;
    /**
     * 
     * @type {InlineResponse20033DefaultNodeInfoOther}
     * @memberof InlineResponse20033DefaultNodeInfo
     */
    other?: InlineResponse20033DefaultNodeInfoOther;
}
/**
 * 
 * @export
 * @interface InlineResponse20033DefaultNodeInfoOther
 */
export interface InlineResponse20033DefaultNodeInfoOther {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033DefaultNodeInfoOther
     */
    tx_index?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033DefaultNodeInfoOther
     */
    rpc_address?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20033DefaultNodeInfoProtocolVersion
 */
export interface InlineResponse20033DefaultNodeInfoProtocolVersion {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033DefaultNodeInfoProtocolVersion
     */
    p2p?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033DefaultNodeInfoProtocolVersion
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033DefaultNodeInfoProtocolVersion
     */
    app?: string;
}
/**
 * GetSyncingResponse is the response type for the Query/GetSyncing RPC method.
 * @export
 * @interface InlineResponse20034
 */
export interface InlineResponse20034 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20034
     */
    syncing?: boolean;
}
/**
 * GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method.
 * @export
 * @interface InlineResponse20035
 */
export interface InlineResponse20035 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20035
     */
    block_height?: string;
    /**
     * 
     * @type {Array<InlineResponse20035Validators>}
     * @memberof InlineResponse20035
     */
    validators?: Array<InlineResponse20035Validators>;
    /**
     * 
     * @type {InlineResponse20035Pagination}
     * @memberof InlineResponse20035
     */
    pagination?: InlineResponse20035Pagination;
}
/**
 * pagination defines an pagination for the response.
 * @export
 * @interface InlineResponse20035Pagination
 */
export interface InlineResponse20035Pagination {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20035Pagination
     */
    next_key?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20035Pagination
     */
    total?: string;
}
/**
 * Validator is the type for the validator-set.
 * @export
 * @interface InlineResponse20035Validators
 */
export interface InlineResponse20035Validators {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20035Validators
     */
    address?: string;
    /**
     * 
     * @type {InlineResponseDefaultDetails}
     * @memberof InlineResponse20035Validators
     */
    pub_key?: InlineResponseDefaultDetails;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20035Validators
     */
    voting_power?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20035Validators
     */
    proposer_priority?: string;
}
/**
 * GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method.
 * @export
 * @interface InlineResponse20036
 */
export interface InlineResponse20036 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20036
     */
    block_height?: string;
    /**
     * 
     * @type {Array<InlineResponse20035Validators>}
     * @memberof InlineResponse20036
     */
    validators?: Array<InlineResponse20035Validators>;
    /**
     * 
     * @type {InlineResponse20035Pagination}
     * @memberof InlineResponse20036
     */
    pagination?: InlineResponse20035Pagination;
}
/**
 * QueryCommunityPoolResponse is the response type for the Query/CommunityPool RPC method.
 * @export
 * @interface InlineResponse20037
 */
export interface InlineResponse20037 {
    /**
     * pool defines community pool\'s coins.
     * @type {Array<InlineResponse20037Pool>}
     * @memberof InlineResponse20037
     */
    pool?: Array<InlineResponse20037Pool>;
}
/**
 * DecCoin defines a token with a denomination and a decimal amount.  NOTE: The amount field is an Dec which implements the custom method signatures required by gogoproto.
 * @export
 * @interface InlineResponse20037Pool
 */
export interface InlineResponse20037Pool {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20037Pool
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20037Pool
     */
    amount?: string;
}
/**
 * QueryDelegationTotalRewardsResponse is the response type for the Query/DelegationTotalRewards RPC method.
 * @export
 * @interface InlineResponse20038
 */
export interface InlineResponse20038 {
    /**
     * rewards defines all the rewards accrued by a delegator.
     * @type {Array<InlineResponse20038Rewards>}
     * @memberof InlineResponse20038
     */
    rewards?: Array<InlineResponse20038Rewards>;
    /**
     * total defines the sum of all the rewards.
     * @type {Array<InlineResponse20037Pool>}
     * @memberof InlineResponse20038
     */
    total?: Array<InlineResponse20037Pool>;
}
/**
 * DelegationDelegatorReward represents the properties of a delegator\'s delegation reward.
 * @export
 * @interface InlineResponse20038Rewards
 */
export interface InlineResponse20038Rewards {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20038Rewards
     */
    validator_address?: string;
    /**
     * 
     * @type {Array<InlineResponse20037Pool>}
     * @memberof InlineResponse20038Rewards
     */
    reward?: Array<InlineResponse20037Pool>;
}
/**
 * QueryDelegationRewardsResponse is the response type for the Query/DelegationRewards RPC method.
 * @export
 * @interface InlineResponse20039
 */
export interface InlineResponse20039 {
    /**
     * rewards defines the rewards accrued by a delegation.
     * @type {Array<InlineResponse20037Pool>}
     * @memberof InlineResponse20039
     */
    rewards?: Array<InlineResponse20037Pool>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003Validators
 */
export interface InlineResponse2003Validators {
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof InlineResponse2003Validators
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Validators
     */
    pub_key?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Validators
     */
    voting_power?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Validators
     */
    proposer_priority?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    hash?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2004
     */
    height?: number;
    /**
     * 
     * @type {InlineResponse2004Tx}
     * @memberof InlineResponse2004
     */
    tx?: InlineResponse2004Tx;
    /**
     * 
     * @type {InlineResponse2004Result}
     * @memberof InlineResponse2004
     */
    result?: InlineResponse2004Result;
}
/**
 * QueryDelegatorValidatorsResponse is the response type for the Query/DelegatorValidators RPC method.
 * @export
 * @interface InlineResponse20040
 */
export interface InlineResponse20040 {
    /**
     * validators defines the validators a delegator is delegating for.
     * @type {Array<string>}
     * @memberof InlineResponse20040
     */
    validators?: Array<string>;
}
/**
 * QueryDelegatorWithdrawAddressResponse is the response type for the Query/DelegatorWithdrawAddress RPC method.
 * @export
 * @interface InlineResponse20041
 */
export interface InlineResponse20041 {
    /**
     * withdraw_address defines the delegator address to query for.
     * @type {string}
     * @memberof InlineResponse20041
     */
    withdraw_address?: string;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface InlineResponse20042
 */
export interface InlineResponse20042 {
    /**
     * 
     * @type {InlineResponse20042Params}
     * @memberof InlineResponse20042
     */
    params?: InlineResponse20042Params;
}
/**
 * params defines the parameters of the module.
 * @export
 * @interface InlineResponse20042Params
 */
export interface InlineResponse20042Params {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20042Params
     */
    community_tax?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20042Params
     */
    base_proposer_reward?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20042Params
     */
    bonus_proposer_reward?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20042Params
     */
    withdraw_addr_enabled?: boolean;
}
/**
 * QueryValidatorOutstandingRewardsResponse is the response type for the Query/ValidatorOutstandingRewards RPC method.
 * @export
 * @interface InlineResponse20043
 */
export interface InlineResponse20043 {
    /**
     * 
     * @type {InlineResponse20043Rewards}
     * @memberof InlineResponse20043
     */
    rewards?: InlineResponse20043Rewards;
}
/**
 * ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards for a validator inexpensive to track, allows simple sanity checks.
 * @export
 * @interface InlineResponse20043Rewards
 */
export interface InlineResponse20043Rewards {
    /**
     * 
     * @type {Array<InlineResponse20037Pool>}
     * @memberof InlineResponse20043Rewards
     */
    rewards?: Array<InlineResponse20037Pool>;
}
/**
 * QueryValidatorSlashesResponse is the response type for the Query/ValidatorSlashes RPC method.
 * @export
 * @interface InlineResponse20044
 */
export interface InlineResponse20044 {
    /**
     * slashes defines the slashes the validator received.
     * @type {Array<InlineResponse20044Slashes>}
     * @memberof InlineResponse20044
     */
    slashes?: Array<InlineResponse20044Slashes>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof InlineResponse20044
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * ValidatorSlashEvent represents a validator slash event. Height is implicit within the store key. This is needed to calculate appropriate amount of staking tokens for delegations which are withdrawn after a slash has occurred.
 * @export
 * @interface InlineResponse20044Slashes
 */
export interface InlineResponse20044Slashes {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20044Slashes
     */
    validator_period?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20044Slashes
     */
    fraction?: string;
}
/**
 * QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC method.
 * @export
 * @interface InlineResponse20045
 */
export interface InlineResponse20045 {
    /**
     * evidence returns all evidences.
     * @type {Array<InlineResponseDefaultDetails>}
     * @memberof InlineResponse20045
     */
    evidence?: Array<InlineResponseDefaultDetails>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof InlineResponse20045
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * QueryEvidenceResponse is the response type for the Query/Evidence RPC method.
 * @export
 * @interface InlineResponse20046
 */
export interface InlineResponse20046 {
    /**
     * 
     * @type {InlineResponse20046Evidence}
     * @memberof InlineResponse20046
     */
    evidence?: InlineResponse20046Evidence;
}
/**
 * evidence returns the requested evidence.
 * @export
 * @interface InlineResponse20046Evidence
 */
export interface InlineResponse20046Evidence {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof InlineResponse20046Evidence
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof InlineResponse20046Evidence
     */
    value?: string;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface InlineResponse20047
 */
export interface InlineResponse20047 {
    /**
     * 
     * @type {InlineResponse20047VotingParams}
     * @memberof InlineResponse20047
     */
    voting_params?: InlineResponse20047VotingParams;
    /**
     * 
     * @type {InlineResponse20047DepositParams}
     * @memberof InlineResponse20047
     */
    deposit_params?: InlineResponse20047DepositParams;
    /**
     * 
     * @type {InlineResponse20047TallyParams}
     * @memberof InlineResponse20047
     */
    tally_params?: InlineResponse20047TallyParams;
}
/**
 * deposit_params defines the parameters related to deposit.
 * @export
 * @interface InlineResponse20047DepositParams
 */
export interface InlineResponse20047DepositParams {
    /**
     * Minimum deposit for a proposal to enter voting period.
     * @type {Array<InlineResponse20027Balances>}
     * @memberof InlineResponse20047DepositParams
     */
    min_deposit?: Array<InlineResponse20027Balances>;
    /**
     * Maximum period for Atom holders to deposit on a proposal. Initial value: 2  months.
     * @type {string}
     * @memberof InlineResponse20047DepositParams
     */
    max_deposit_period?: string;
}
/**
 * tally_params defines the parameters related to tally.
 * @export
 * @interface InlineResponse20047TallyParams
 */
export interface InlineResponse20047TallyParams {
    /**
     * Minimum percentage of total stake needed to vote for a result to be  considered valid.
     * @type {string}
     * @memberof InlineResponse20047TallyParams
     */
    quorum?: string;
    /**
     * Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.
     * @type {string}
     * @memberof InlineResponse20047TallyParams
     */
    threshold?: string;
    /**
     * Minimum value of Veto votes to Total votes ratio for proposal to be  vetoed. Default value: 1/3.
     * @type {string}
     * @memberof InlineResponse20047TallyParams
     */
    veto_threshold?: string;
}
/**
 * voting_params defines the parameters related to voting.
 * @export
 * @interface InlineResponse20047VotingParams
 */
export interface InlineResponse20047VotingParams {
    /**
     * Length of the voting period.
     * @type {string}
     * @memberof InlineResponse20047VotingParams
     */
    voting_period?: string;
}
/**
 * QueryProposalsResponse is the response type for the Query/Proposals RPC method.
 * @export
 * @interface InlineResponse20048
 */
export interface InlineResponse20048 {
    /**
     * 
     * @type {Array<InlineResponse20048Proposals>}
     * @memberof InlineResponse20048
     */
    proposals?: Array<InlineResponse20048Proposals>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof InlineResponse20048
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * TallyResult defines a standard tally for a governance proposal.
 * @export
 * @interface InlineResponse20048FinalTallyResult
 */
export interface InlineResponse20048FinalTallyResult {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20048FinalTallyResult
     */
    yes?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20048FinalTallyResult
     */
    abstain?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20048FinalTallyResult
     */
    no?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20048FinalTallyResult
     */
    no_with_veto?: string;
}
/**
 * Proposal defines the core field members of a governance proposal.
 * @export
 * @interface InlineResponse20048Proposals
 */
export interface InlineResponse20048Proposals {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20048Proposals
     */
    proposal_id?: string;
    /**
     * 
     * @type {InlineResponseDefaultDetails}
     * @memberof InlineResponse20048Proposals
     */
    content?: InlineResponseDefaultDetails;
    /**
     * ProposalStatus enumerates the valid statuses of a proposal.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
     * @type {string}
     * @memberof InlineResponse20048Proposals
     */
    status?: InlineResponse20048ProposalsStatusEnum;
    /**
     * 
     * @type {InlineResponse20048FinalTallyResult}
     * @memberof InlineResponse20048Proposals
     */
    final_tally_result?: InlineResponse20048FinalTallyResult;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20048Proposals
     */
    submit_time?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20048Proposals
     */
    deposit_end_time?: string;
    /**
     * 
     * @type {Array<InlineResponse20027Balances>}
     * @memberof InlineResponse20048Proposals
     */
    total_deposit?: Array<InlineResponse20027Balances>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20048Proposals
     */
    voting_start_time?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20048Proposals
     */
    voting_end_time?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20048ProposalsStatusEnum {
    Unspecified = 'PROPOSAL_STATUS_UNSPECIFIED',
    DepositPeriod = 'PROPOSAL_STATUS_DEPOSIT_PERIOD',
    VotingPeriod = 'PROPOSAL_STATUS_VOTING_PERIOD',
    Passed = 'PROPOSAL_STATUS_PASSED',
    Rejected = 'PROPOSAL_STATUS_REJECTED',
    Failed = 'PROPOSAL_STATUS_FAILED'
}

/**
 * QueryProposalResponse is the response type for the Query/Proposal RPC method.
 * @export
 * @interface InlineResponse20049
 */
export interface InlineResponse20049 {
    /**
     * 
     * @type {InlineResponse20048Proposals}
     * @memberof InlineResponse20049
     */
    proposal?: InlineResponse20048Proposals;
}
/**
 * 
 * @export
 * @interface InlineResponse2004Result
 */
export interface InlineResponse2004Result {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Result
     */
    log?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Result
     */
    gas_wanted?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Result
     */
    gas_used?: string;
    /**
     * 
     * @type {Array<InlineResponse2004ResultTags>}
     * @memberof InlineResponse2004Result
     */
    tags?: Array<InlineResponse2004ResultTags>;
}
/**
 * 
 * @export
 * @interface InlineResponse2004ResultTags
 */
export interface InlineResponse2004ResultTags {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004ResultTags
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004ResultTags
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2004Tx
 */
export interface InlineResponse2004Tx {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse2004Tx
     */
    msg?: Array<string>;
    /**
     * 
     * @type {InlineResponse2004TxFee}
     * @memberof InlineResponse2004Tx
     */
    fee?: InlineResponse2004TxFee;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Tx
     */
    memo?: string;
    /**
     * 
     * @type {InlineResponse2004TxSignature}
     * @memberof InlineResponse2004Tx
     */
    signature?: InlineResponse2004TxSignature;
}
/**
 * 
 * @export
 * @interface InlineResponse2004TxFee
 */
export interface InlineResponse2004TxFee {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004TxFee
     */
    gas?: string;
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof InlineResponse2004TxFee
     */
    amount?: Array<InlineResponse2004TxFeeAmount>;
}
/**
 * 
 * @export
 * @interface InlineResponse2004TxFeeAmount
 */
export interface InlineResponse2004TxFeeAmount {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004TxFeeAmount
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004TxFeeAmount
     */
    amount?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2004TxSignature
 */
export interface InlineResponse2004TxSignature {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004TxSignature
     */
    signature?: string;
    /**
     * 
     * @type {InlineResponse2004TxSignaturePubKey}
     * @memberof InlineResponse2004TxSignature
     */
    pub_key?: InlineResponse2004TxSignaturePubKey;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004TxSignature
     */
    account_number?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004TxSignature
     */
    sequence?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2004TxSignaturePubKey
 */
export interface InlineResponse2004TxSignaturePubKey {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004TxSignaturePubKey
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004TxSignaturePubKey
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005
     */
    total_count?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005
     */
    page_number?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005
     */
    page_total?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005
     */
    limit?: number;
    /**
     * 
     * @type {Array<InlineResponse2004>}
     * @memberof InlineResponse2005
     */
    txs?: Array<InlineResponse2004>;
}
/**
 * QueryDepositsResponse is the response type for the Query/Deposits RPC method.
 * @export
 * @interface InlineResponse20050
 */
export interface InlineResponse20050 {
    /**
     * 
     * @type {Array<InlineResponse20050Deposits>}
     * @memberof InlineResponse20050
     */
    deposits?: Array<InlineResponse20050Deposits>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof InlineResponse20050
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * Deposit defines an amount deposited by an account address to an active proposal.
 * @export
 * @interface InlineResponse20050Deposits
 */
export interface InlineResponse20050Deposits {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20050Deposits
     */
    proposal_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20050Deposits
     */
    depositor?: string;
    /**
     * 
     * @type {Array<InlineResponse20027Balances>}
     * @memberof InlineResponse20050Deposits
     */
    amount?: Array<InlineResponse20027Balances>;
}
/**
 * QueryDepositResponse is the response type for the Query/Deposit RPC method.
 * @export
 * @interface InlineResponse20051
 */
export interface InlineResponse20051 {
    /**
     * 
     * @type {InlineResponse20051Deposit}
     * @memberof InlineResponse20051
     */
    deposit?: InlineResponse20051Deposit;
}
/**
 * deposit defines the requested deposit.
 * @export
 * @interface InlineResponse20051Deposit
 */
export interface InlineResponse20051Deposit {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20051Deposit
     */
    proposal_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20051Deposit
     */
    depositor?: string;
    /**
     * 
     * @type {Array<InlineResponse20027Balances>}
     * @memberof InlineResponse20051Deposit
     */
    amount?: Array<InlineResponse20027Balances>;
}
/**
 * QueryTallyResultResponse is the response type for the Query/Tally RPC method.
 * @export
 * @interface InlineResponse20052
 */
export interface InlineResponse20052 {
    /**
     * 
     * @type {InlineResponse20052Tally}
     * @memberof InlineResponse20052
     */
    tally?: InlineResponse20052Tally;
}
/**
 * tally defines the requested tally.
 * @export
 * @interface InlineResponse20052Tally
 */
export interface InlineResponse20052Tally {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20052Tally
     */
    yes?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20052Tally
     */
    abstain?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20052Tally
     */
    no?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20052Tally
     */
    no_with_veto?: string;
}
/**
 * QueryVotesResponse is the response type for the Query/Votes RPC method.
 * @export
 * @interface InlineResponse20053
 */
export interface InlineResponse20053 {
    /**
     * votes defined the queried votes.
     * @type {Array<InlineResponse20053Votes>}
     * @memberof InlineResponse20053
     */
    votes?: Array<InlineResponse20053Votes>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof InlineResponse20053
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * Vote defines a vote on a governance proposal. A Vote consists of a proposal ID, the voter, and the vote option.
 * @export
 * @interface InlineResponse20053Votes
 */
export interface InlineResponse20053Votes {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20053Votes
     */
    proposal_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20053Votes
     */
    voter?: string;
    /**
     * VoteOption enumerates the valid vote options for a given governance proposal.   - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.  - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.  - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.  - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.  - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
     * @type {string}
     * @memberof InlineResponse20053Votes
     */
    option?: InlineResponse20053VotesOptionEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20053VotesOptionEnum {
    Unspecified = 'VOTE_OPTION_UNSPECIFIED',
    Yes = 'VOTE_OPTION_YES',
    Abstain = 'VOTE_OPTION_ABSTAIN',
    No = 'VOTE_OPTION_NO',
    NoWithVeto = 'VOTE_OPTION_NO_WITH_VETO'
}

/**
 * QueryVoteResponse is the response type for the Query/Vote RPC method.
 * @export
 * @interface InlineResponse20054
 */
export interface InlineResponse20054 {
    /**
     * 
     * @type {InlineResponse20054Vote}
     * @memberof InlineResponse20054
     */
    vote?: InlineResponse20054Vote;
}
/**
 * vote defined the queried vote.
 * @export
 * @interface InlineResponse20054Vote
 */
export interface InlineResponse20054Vote {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20054Vote
     */
    proposal_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20054Vote
     */
    voter?: string;
    /**
     * VoteOption enumerates the valid vote options for a given governance proposal.   - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.  - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.  - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.  - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.  - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
     * @type {string}
     * @memberof InlineResponse20054Vote
     */
    option?: InlineResponse20054VoteOptionEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20054VoteOptionEnum {
    Unspecified = 'VOTE_OPTION_UNSPECIFIED',
    Yes = 'VOTE_OPTION_YES',
    Abstain = 'VOTE_OPTION_ABSTAIN',
    No = 'VOTE_OPTION_NO',
    NoWithVeto = 'VOTE_OPTION_NO_WITH_VETO'
}

/**
 * QueryAnnualProvisionsResponse is the response type for the Query/AnnualProvisions RPC method.
 * @export
 * @interface InlineResponse20055
 */
export interface InlineResponse20055 {
    /**
     * annual_provisions is the current minting annual provisions value.
     * @type {string}
     * @memberof InlineResponse20055
     */
    annual_provisions?: string;
}
/**
 * QueryInflationResponse is the response type for the Query/Inflation RPC method.
 * @export
 * @interface InlineResponse20056
 */
export interface InlineResponse20056 {
    /**
     * inflation is the current minting inflation value.
     * @type {string}
     * @memberof InlineResponse20056
     */
    inflation?: string;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface InlineResponse20057
 */
export interface InlineResponse20057 {
    /**
     * 
     * @type {InlineResponse20057Params}
     * @memberof InlineResponse20057
     */
    params?: InlineResponse20057Params;
}
/**
 * params defines the parameters of the module.
 * @export
 * @interface InlineResponse20057Params
 */
export interface InlineResponse20057Params {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20057Params
     */
    mint_denom?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20057Params
     */
    inflation_rate_change?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20057Params
     */
    inflation_max?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20057Params
     */
    inflation_min?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20057Params
     */
    goal_bonded?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20057Params
     */
    blocks_per_year?: string;
}
/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 * @export
 * @interface InlineResponse20058
 */
export interface InlineResponse20058 {
    /**
     * 
     * @type {InlineResponse20058Param}
     * @memberof InlineResponse20058
     */
    param?: InlineResponse20058Param;
}
/**
 * param defines the queried parameter.
 * @export
 * @interface InlineResponse20058Param
 */
export interface InlineResponse20058Param {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20058Param
     */
    subspace?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20058Param
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20058Param
     */
    value?: string;
}
/**
 * QueryDelegatorDelegationsResponse is response type for the Query/DelegatorDelegations RPC method.
 * @export
 * @interface InlineResponse20059
 */
export interface InlineResponse20059 {
    /**
     * delegation_responses defines all the delegations\' info of a delegator.
     * @type {Array<InlineResponse20059DelegationResponses>}
     * @memberof InlineResponse20059
     */
    delegation_responses?: Array<InlineResponse20059DelegationResponses>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof InlineResponse20059
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * Delegation represents the bond with tokens held by an account. It is owned by one delegator, and is associated with the voting power of one validator.
 * @export
 * @interface InlineResponse20059Delegation
 */
export interface InlineResponse20059Delegation {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20059Delegation
     */
    delegator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20059Delegation
     */
    validator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20059Delegation
     */
    shares?: string;
}
/**
 * DelegationResponse is equivalent to Delegation except that it contains a balance in addition to shares which is more suitable for client responses.
 * @export
 * @interface InlineResponse20059DelegationResponses
 */
export interface InlineResponse20059DelegationResponses {
    /**
     * 
     * @type {InlineResponse20059Delegation}
     * @memberof InlineResponse20059DelegationResponses
     */
    delegation?: InlineResponse20059Delegation;
    /**
     * 
     * @type {InlineResponse20027Balances}
     * @memberof InlineResponse20059DelegationResponses
     */
    balance?: InlineResponse20027Balances;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {InlineResponse2006CheckTx}
     * @memberof InlineResponse2006
     */
    check_tx?: InlineResponse2006CheckTx;
    /**
     * 
     * @type {InlineResponse2006DeliverTx}
     * @memberof InlineResponse2006
     */
    deliver_tx?: InlineResponse2006DeliverTx;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    hash?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006
     */
    height?: number;
}
/**
 * QueryRedelegationsResponse is response type for the Query/Redelegations RPC method.
 * @export
 * @interface InlineResponse20060
 */
export interface InlineResponse20060 {
    /**
     * 
     * @type {Array<InlineResponse20060RedelegationResponses>}
     * @memberof InlineResponse20060
     */
    redelegation_responses?: Array<InlineResponse20060RedelegationResponses>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof InlineResponse20060
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * RedelegationEntryResponse is equivalent to a RedelegationEntry except that it contains a balance in addition to shares which is more suitable for client responses.
 * @export
 * @interface InlineResponse20060Entries
 */
export interface InlineResponse20060Entries {
    /**
     * 
     * @type {InlineResponse20060RedelegationEntries}
     * @memberof InlineResponse20060Entries
     */
    redelegation_entry?: InlineResponse20060RedelegationEntries;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20060Entries
     */
    balance?: string;
}
/**
 * Redelegation contains the list of a particular delegator\'s redelegating bonds from a particular source validator to a particular destination validator.
 * @export
 * @interface InlineResponse20060Redelegation
 */
export interface InlineResponse20060Redelegation {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20060Redelegation
     */
    delegator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20060Redelegation
     */
    validator_src_address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20060Redelegation
     */
    validator_dst_address?: string;
    /**
     * 
     * @type {Array<InlineResponse20060RedelegationEntries>}
     * @memberof InlineResponse20060Redelegation
     */
    entries?: Array<InlineResponse20060RedelegationEntries>;
}
/**
 * RedelegationEntry defines a redelegation object with relevant metadata.
 * @export
 * @interface InlineResponse20060RedelegationEntries
 */
export interface InlineResponse20060RedelegationEntries {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20060RedelegationEntries
     */
    creation_height?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20060RedelegationEntries
     */
    completion_time?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20060RedelegationEntries
     */
    initial_balance?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20060RedelegationEntries
     */
    shares_dst?: string;
}
/**
 * RedelegationResponse is equivalent to a Redelegation except that its entries contain a balance in addition to shares which is more suitable for client responses.
 * @export
 * @interface InlineResponse20060RedelegationResponses
 */
export interface InlineResponse20060RedelegationResponses {
    /**
     * 
     * @type {InlineResponse20060Redelegation}
     * @memberof InlineResponse20060RedelegationResponses
     */
    redelegation?: InlineResponse20060Redelegation;
    /**
     * 
     * @type {Array<InlineResponse20060Entries>}
     * @memberof InlineResponse20060RedelegationResponses
     */
    entries?: Array<InlineResponse20060Entries>;
}
/**
 * QueryUnbondingDelegatorDelegationsResponse is response type for the Query/UnbondingDelegatorDelegations RPC method.
 * @export
 * @interface InlineResponse20061
 */
export interface InlineResponse20061 {
    /**
     * 
     * @type {Array<InlineResponse20061UnbondingResponses>}
     * @memberof InlineResponse20061
     */
    unbonding_responses?: Array<InlineResponse20061UnbondingResponses>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof InlineResponse20061
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * UnbondingDelegationEntry defines an unbonding object with relevant metadata.
 * @export
 * @interface InlineResponse20061Entries
 */
export interface InlineResponse20061Entries {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20061Entries
     */
    creation_height?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20061Entries
     */
    completion_time?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20061Entries
     */
    initial_balance?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20061Entries
     */
    balance?: string;
}
/**
 * UnbondingDelegation stores all of a single delegator\'s unbonding bonds for a single validator in an time-ordered list.
 * @export
 * @interface InlineResponse20061UnbondingResponses
 */
export interface InlineResponse20061UnbondingResponses {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20061UnbondingResponses
     */
    delegator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20061UnbondingResponses
     */
    validator_address?: string;
    /**
     * 
     * @type {Array<InlineResponse20061Entries>}
     * @memberof InlineResponse20061UnbondingResponses
     */
    entries?: Array<InlineResponse20061Entries>;
}
/**
 * QueryDelegatorValidatorsResponse is response type for the Query/DelegatorValidators RPC method.
 * @export
 * @interface InlineResponse20062
 */
export interface InlineResponse20062 {
    /**
     * validators defines the the validators\' info of a delegator.
     * @type {Array<InlineResponse20062Validators>}
     * @memberof InlineResponse20062
     */
    validators?: Array<InlineResponse20062Validators>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof InlineResponse20062
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * Commission defines commission parameters for a given validator.
 * @export
 * @interface InlineResponse20062Commission
 */
export interface InlineResponse20062Commission {
    /**
     * 
     * @type {InlineResponse20062CommissionCommissionRates}
     * @memberof InlineResponse20062Commission
     */
    commission_rates?: InlineResponse20062CommissionCommissionRates;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20062Commission
     */
    update_time?: string;
}
/**
 * CommissionRates defines the initial commission rates to be used for creating a validator.
 * @export
 * @interface InlineResponse20062CommissionCommissionRates
 */
export interface InlineResponse20062CommissionCommissionRates {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20062CommissionCommissionRates
     */
    rate?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20062CommissionCommissionRates
     */
    max_rate?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20062CommissionCommissionRates
     */
    max_change_rate?: string;
}
/**
 * Description defines a validator description.
 * @export
 * @interface InlineResponse20062Description
 */
export interface InlineResponse20062Description {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20062Description
     */
    moniker?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20062Description
     */
    identity?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20062Description
     */
    website?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20062Description
     */
    security_contact?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20062Description
     */
    details?: string;
}
/**
 * Validator defines a validator, together with the total amount of the Validator\'s bond shares and their exchange rate to coins. Slashing results in a decrease in the exchange rate, allowing correct calculation of future undelegations without iterating over delegators. When coins are delegated to this validator, the validator is credited with a delegation whose number of bond shares is based on the amount of coins delegated divided by the current exchange rate. Voting power can be calculated as total bonded shares multiplied by exchange rate.
 * @export
 * @interface InlineResponse20062Validators
 */
export interface InlineResponse20062Validators {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20062Validators
     */
    operator_address?: string;
    /**
     * 
     * @type {InlineResponseDefaultDetails}
     * @memberof InlineResponse20062Validators
     */
    consensus_pubkey?: InlineResponseDefaultDetails;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20062Validators
     */
    jailed?: boolean;
    /**
     * BondStatus is the status of a validator.   - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.  - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.  - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.  - BOND_STATUS_BONDED: BONDED defines a validator that is bonded.
     * @type {string}
     * @memberof InlineResponse20062Validators
     */
    status?: InlineResponse20062ValidatorsStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20062Validators
     */
    tokens?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20062Validators
     */
    delegator_shares?: string;
    /**
     * 
     * @type {InlineResponse20062Description}
     * @memberof InlineResponse20062Validators
     */
    description?: InlineResponse20062Description;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20062Validators
     */
    unbonding_height?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20062Validators
     */
    unbonding_time?: string;
    /**
     * 
     * @type {InlineResponse20062Commission}
     * @memberof InlineResponse20062Validators
     */
    commission?: InlineResponse20062Commission;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20062Validators
     */
    min_self_delegation?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20062ValidatorsStatusEnum {
    Unspecified = 'BOND_STATUS_UNSPECIFIED',
    Unbonded = 'BOND_STATUS_UNBONDED',
    Unbonding = 'BOND_STATUS_UNBONDING',
    Bonded = 'BOND_STATUS_BONDED'
}

/**
 * QueryDelegatorValidatorResponse response type for the Query/DelegatorValidator RPC method.
 * @export
 * @interface InlineResponse20063
 */
export interface InlineResponse20063 {
    /**
     * 
     * @type {InlineResponse20063Validator}
     * @memberof InlineResponse20063
     */
    validator?: InlineResponse20063Validator;
}
/**
 * validator defines the the validator info.
 * @export
 * @interface InlineResponse20063Validator
 */
export interface InlineResponse20063Validator {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20063Validator
     */
    operator_address?: string;
    /**
     * 
     * @type {InlineResponseDefaultDetails}
     * @memberof InlineResponse20063Validator
     */
    consensus_pubkey?: InlineResponseDefaultDetails;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20063Validator
     */
    jailed?: boolean;
    /**
     * BondStatus is the status of a validator.   - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.  - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.  - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.  - BOND_STATUS_BONDED: BONDED defines a validator that is bonded.
     * @type {string}
     * @memberof InlineResponse20063Validator
     */
    status?: InlineResponse20063ValidatorStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20063Validator
     */
    tokens?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20063Validator
     */
    delegator_shares?: string;
    /**
     * 
     * @type {InlineResponse20062Description}
     * @memberof InlineResponse20063Validator
     */
    description?: InlineResponse20062Description;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20063Validator
     */
    unbonding_height?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20063Validator
     */
    unbonding_time?: string;
    /**
     * 
     * @type {InlineResponse20062Commission}
     * @memberof InlineResponse20063Validator
     */
    commission?: InlineResponse20062Commission;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20063Validator
     */
    min_self_delegation?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20063ValidatorStatusEnum {
    Unspecified = 'BOND_STATUS_UNSPECIFIED',
    Unbonded = 'BOND_STATUS_UNBONDED',
    Unbonding = 'BOND_STATUS_UNBONDING',
    Bonded = 'BOND_STATUS_BONDED'
}

/**
 * QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC method.
 * @export
 * @interface InlineResponse20064
 */
export interface InlineResponse20064 {
    /**
     * 
     * @type {InlineResponse20064Hist}
     * @memberof InlineResponse20064
     */
    hist?: InlineResponse20064Hist;
}
/**
 * hist defines the historical info at the given height.
 * @export
 * @interface InlineResponse20064Hist
 */
export interface InlineResponse20064Hist {
    /**
     * 
     * @type {InlineResponse20031BlockHeader}
     * @memberof InlineResponse20064Hist
     */
    header?: InlineResponse20031BlockHeader;
    /**
     * 
     * @type {Array<InlineResponse20062Validators>}
     * @memberof InlineResponse20064Hist
     */
    valset?: Array<InlineResponse20062Validators>;
}
/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 * @export
 * @interface InlineResponse20065
 */
export interface InlineResponse20065 {
    /**
     * 
     * @type {InlineResponse20065Params}
     * @memberof InlineResponse20065
     */
    params?: InlineResponse20065Params;
}
/**
 * params holds all the parameters of this module.
 * @export
 * @interface InlineResponse20065Params
 */
export interface InlineResponse20065Params {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20065Params
     */
    unbonding_time?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20065Params
     */
    max_validators?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20065Params
     */
    max_entries?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20065Params
     */
    historical_entries?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20065Params
     */
    bond_denom?: string;
}
/**
 * QueryPoolResponse is response type for the Query/Pool RPC method.
 * @export
 * @interface InlineResponse20066
 */
export interface InlineResponse20066 {
    /**
     * 
     * @type {InlineResponse20066Pool}
     * @memberof InlineResponse20066
     */
    pool?: InlineResponse20066Pool;
}
/**
 * pool defines the pool info.
 * @export
 * @interface InlineResponse20066Pool
 */
export interface InlineResponse20066Pool {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20066Pool
     */
    not_bonded_tokens?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20066Pool
     */
    bonded_tokens?: string;
}
/**
 * QueryDelegationResponse is response type for the Query/Delegation RPC method.
 * @export
 * @interface InlineResponse20067
 */
export interface InlineResponse20067 {
    /**
     * 
     * @type {InlineResponse20067DelegationResponse}
     * @memberof InlineResponse20067
     */
    delegation_response?: InlineResponse20067DelegationResponse;
}
/**
 * delegation_responses defines the delegation info of a delegation.
 * @export
 * @interface InlineResponse20067DelegationResponse
 */
export interface InlineResponse20067DelegationResponse {
    /**
     * 
     * @type {InlineResponse20059Delegation}
     * @memberof InlineResponse20067DelegationResponse
     */
    delegation?: InlineResponse20059Delegation;
    /**
     * 
     * @type {InlineResponse20027Balances}
     * @memberof InlineResponse20067DelegationResponse
     */
    balance?: InlineResponse20027Balances;
}
/**
 * QueryDelegationResponse is response type for the Query/UnbondingDelegation RPC method.
 * @export
 * @interface InlineResponse20068
 */
export interface InlineResponse20068 {
    /**
     * 
     * @type {InlineResponse20068Unbond}
     * @memberof InlineResponse20068
     */
    unbond?: InlineResponse20068Unbond;
}
/**
 * unbond defines the unbonding information of a delegation.
 * @export
 * @interface InlineResponse20068Unbond
 */
export interface InlineResponse20068Unbond {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20068Unbond
     */
    delegator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20068Unbond
     */
    validator_address?: string;
    /**
     * 
     * @type {Array<InlineResponse20061Entries>}
     * @memberof InlineResponse20068Unbond
     */
    entries?: Array<InlineResponse20061Entries>;
}
/**
 * QueryValidatorUnbondingDelegationsResponse is response type for the Query/ValidatorUnbondingDelegations RPC method.
 * @export
 * @interface InlineResponse20069
 */
export interface InlineResponse20069 {
    /**
     * 
     * @type {Array<InlineResponse20061UnbondingResponses>}
     * @memberof InlineResponse20069
     */
    unbonding_responses?: Array<InlineResponse20061UnbondingResponses>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof InlineResponse20069
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse2006CheckTx
 */
export interface InlineResponse2006CheckTx {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006CheckTx
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006CheckTx
     */
    data?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006CheckTx
     */
    gas_used?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006CheckTx
     */
    gas_wanted?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006CheckTx
     */
    info?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006CheckTx
     */
    log?: string;
    /**
     * 
     * @type {Array<InlineResponse2004ResultTags>}
     * @memberof InlineResponse2006CheckTx
     */
    tags?: Array<InlineResponse2004ResultTags>;
}
/**
 * 
 * @export
 * @interface InlineResponse2006DeliverTx
 */
export interface InlineResponse2006DeliverTx {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006DeliverTx
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006DeliverTx
     */
    data?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006DeliverTx
     */
    gas_used?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006DeliverTx
     */
    gas_wanted?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006DeliverTx
     */
    info?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006DeliverTx
     */
    log?: string;
    /**
     * 
     * @type {Array<InlineResponse2004ResultTags>}
     * @memberof InlineResponse2006DeliverTx
     */
    tags?: Array<InlineResponse2004ResultTags>;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    tx?: string;
}
/**
 * SimulateResponse is the response type for the Service.SimulateRPC method.
 * @export
 * @interface InlineResponse20070
 */
export interface InlineResponse20070 {
    /**
     * 
     * @type {InlineResponse20070GasInfo}
     * @memberof InlineResponse20070
     */
    gas_info?: InlineResponse20070GasInfo;
    /**
     * 
     * @type {InlineResponse20070Result}
     * @memberof InlineResponse20070
     */
    result?: InlineResponse20070Result;
}
/**
 * gas_info is the information about gas used in the simulation.
 * @export
 * @interface InlineResponse20070GasInfo
 */
export interface InlineResponse20070GasInfo {
    /**
     * GasWanted is the maximum units of work we allow this tx to perform.
     * @type {string}
     * @memberof InlineResponse20070GasInfo
     */
    gas_wanted?: string;
    /**
     * GasUsed is the amount of gas actually consumed.
     * @type {string}
     * @memberof InlineResponse20070GasInfo
     */
    gas_used?: string;
}
/**
 * result is the result of the simulation.
 * @export
 * @interface InlineResponse20070Result
 */
export interface InlineResponse20070Result {
    /**
     * Data is any data returned from message or handler execution. It MUST be length prefixed in order to separate data from multiple message executions.
     * @type {string}
     * @memberof InlineResponse20070Result
     */
    data?: string;
    /**
     * Log contains the log information from message or handler execution.
     * @type {string}
     * @memberof InlineResponse20070Result
     */
    log?: string;
    /**
     * Events contains a slice of Event objects that were emitted during message or handler execution.
     * @type {Array<InlineResponse20070ResultEvents>}
     * @memberof InlineResponse20070Result
     */
    events?: Array<InlineResponse20070ResultEvents>;
}
/**
 * EventAttribute is a single key-value pair, associated with an event.
 * @export
 * @interface InlineResponse20070ResultAttributes
 */
export interface InlineResponse20070ResultAttributes {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20070ResultAttributes
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20070ResultAttributes
     */
    value?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20070ResultAttributes
     */
    index?: boolean;
}
/**
 * Event allows application developers to attach additional information to ResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx. Later, transactions may be queried using these events.
 * @export
 * @interface InlineResponse20070ResultEvents
 */
export interface InlineResponse20070ResultEvents {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20070ResultEvents
     */
    type?: string;
    /**
     * 
     * @type {Array<InlineResponse20070ResultAttributes>}
     * @memberof InlineResponse20070ResultEvents
     */
    attributes?: Array<InlineResponse20070ResultAttributes>;
}
/**
 * BroadcastTxResponse is the response type for the Service.BroadcastTx method.
 * @export
 * @interface InlineResponse20071
 */
export interface InlineResponse20071 {
    /**
     * 
     * @type {InlineResponse20071TxResponse}
     * @memberof InlineResponse20071
     */
    tx_response?: InlineResponse20071TxResponse;
}
/**
 * tx_response is the queried TxResponses.
 * @export
 * @interface InlineResponse20071TxResponse
 */
export interface InlineResponse20071TxResponse {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20071TxResponse
     */
    height?: string;
    /**
     * The transaction hash.
     * @type {string}
     * @memberof InlineResponse20071TxResponse
     */
    txhash?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20071TxResponse
     */
    codespace?: string;
    /**
     * Response code.
     * @type {number}
     * @memberof InlineResponse20071TxResponse
     */
    code?: number;
    /**
     * Result bytes, if any.
     * @type {string}
     * @memberof InlineResponse20071TxResponse
     */
    data?: string;
    /**
     * The output of the application\'s logger (raw string). May be non-deterministic.
     * @type {string}
     * @memberof InlineResponse20071TxResponse
     */
    raw_log?: string;
    /**
     * The output of the application\'s logger (typed). May be non-deterministic.
     * @type {Array<InlineResponse20071TxResponseLogs>}
     * @memberof InlineResponse20071TxResponse
     */
    logs?: Array<InlineResponse20071TxResponseLogs>;
    /**
     * Additional information. May be non-deterministic.
     * @type {string}
     * @memberof InlineResponse20071TxResponse
     */
    info?: string;
    /**
     * Amount of gas requested for transaction.
     * @type {string}
     * @memberof InlineResponse20071TxResponse
     */
    gas_wanted?: string;
    /**
     * Amount of gas consumed by transaction.
     * @type {string}
     * @memberof InlineResponse20071TxResponse
     */
    gas_used?: string;
    /**
     * 
     * @type {InlineResponse20071TxResponseTx}
     * @memberof InlineResponse20071TxResponse
     */
    tx?: InlineResponse20071TxResponseTx;
    /**
     * Time of the previous block. For heights > 1, it\'s the weighted median of the timestamps of the valid votes in the block.LastCommit. For height == 1, it\'s genesis time.
     * @type {string}
     * @memberof InlineResponse20071TxResponse
     */
    timestamp?: string;
}
/**
 * Attribute defines an attribute wrapper where the key and value are strings instead of raw bytes.
 * @export
 * @interface InlineResponse20071TxResponseAttributes
 */
export interface InlineResponse20071TxResponseAttributes {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20071TxResponseAttributes
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20071TxResponseAttributes
     */
    value?: string;
}
/**
 * StringEvent defines en Event object wrapper where all the attributes contain key/value pairs that are strings instead of raw bytes.
 * @export
 * @interface InlineResponse20071TxResponseEvents
 */
export interface InlineResponse20071TxResponseEvents {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20071TxResponseEvents
     */
    type?: string;
    /**
     * 
     * @type {Array<InlineResponse20071TxResponseAttributes>}
     * @memberof InlineResponse20071TxResponseEvents
     */
    attributes?: Array<InlineResponse20071TxResponseAttributes>;
}
/**
 * ABCIMessageLog defines a structure containing an indexed tx ABCI message log.
 * @export
 * @interface InlineResponse20071TxResponseLogs
 */
export interface InlineResponse20071TxResponseLogs {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20071TxResponseLogs
     */
    msg_index?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20071TxResponseLogs
     */
    log?: string;
    /**
     * Events contains a slice of Event objects that were emitted during some execution.
     * @type {Array<InlineResponse20071TxResponseEvents>}
     * @memberof InlineResponse20071TxResponseLogs
     */
    events?: Array<InlineResponse20071TxResponseEvents>;
}
/**
 * The request transaction bytes.
 * @export
 * @interface InlineResponse20071TxResponseTx
 */
export interface InlineResponse20071TxResponseTx {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof InlineResponse20071TxResponseTx
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof InlineResponse20071TxResponseTx
     */
    value?: string;
}
/**
 * QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC method.
 * @export
 * @interface InlineResponse20072
 */
export interface InlineResponse20072 {
    /**
     * height is the block height at which the plan was applied.
     * @type {string}
     * @memberof InlineResponse20072
     */
    height?: string;
}
/**
 * QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC method.
 * @export
 * @interface InlineResponse20073
 */
export interface InlineResponse20073 {
    /**
     * 
     * @type {InlineResponse20073Plan}
     * @memberof InlineResponse20073
     */
    plan?: InlineResponse20073Plan;
}
/**
 * plan is the current upgrade plan.
 * @export
 * @interface InlineResponse20073Plan
 */
export interface InlineResponse20073Plan {
    /**
     * Sets the name for the upgrade. This name will be used by the upgraded version of the software to apply any special \"on-upgrade\" commands during the first BeginBlock method after the upgrade is applied. It is also used to detect whether a software version can handle a given upgrade. If no upgrade handler with this name has been set in the software, it will be assumed that the software is out-of-date when the upgrade Time or Height is reached and the software will exit.
     * @type {string}
     * @memberof InlineResponse20073Plan
     */
    name?: string;
    /**
     * The time after which the upgrade must be performed. Leave set to its zero value to use a pre-defined Height instead.
     * @type {string}
     * @memberof InlineResponse20073Plan
     */
    time?: string;
    /**
     * The height at which the upgrade must be performed. Only used if Time is not set.
     * @type {string}
     * @memberof InlineResponse20073Plan
     */
    height?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20073Plan
     */
    info?: string;
    /**
     * 
     * @type {IBCEnabledChainsCanOptInToIncludingTheUpgradedClientStateInItsUpgradePlanThisWillMakeTheChainCommitToTheCorrectUpgradedSelfClientStateBeforeTheUpgradeOccursSoThatConnectingChainsCanVerifyThatTheNewUpgradedClientIsValidByVerifyingAProofOnThePreviousVersionOfTheChainThisWillAllowIBCConnectionsToPersistSmoothlyAcrossPlannedChainUpgrades}
     * @memberof InlineResponse20073Plan
     */
    upgraded_client_state?: IBCEnabledChainsCanOptInToIncludingTheUpgradedClientStateInItsUpgradePlanThisWillMakeTheChainCommitToTheCorrectUpgradedSelfClientStateBeforeTheUpgradeOccursSoThatConnectingChainsCanVerifyThatTheNewUpgradedClientIsValidByVerifyingAProofOnThePreviousVersionOfTheChainThisWillAllowIBCConnectionsToPersistSmoothlyAcrossPlannedChainUpgrades;
}
/**
 * QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState RPC method.
 * @export
 * @interface InlineResponse20074
 */
export interface InlineResponse20074 {
    /**
     * 
     * @type {InlineResponseDefaultDetails}
     * @memberof InlineResponse20074
     */
    upgraded_consensus_state?: InlineResponseDefaultDetails;
}
/**
 * QueryChannelsResponse is the response type for the Query/Channels RPC method.
 * @export
 * @interface InlineResponse20075
 */
export interface InlineResponse20075 {
    /**
     * list of stored channels of the chain.
     * @type {Array<InlineResponse20075Channels>}
     * @memberof InlineResponse20075
     */
    channels?: Array<InlineResponse20075Channels>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof InlineResponse20075
     */
    pagination?: PaginationResponse;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof InlineResponse20075
     */
    height?: QueryBlockHeight;
}
/**
 * IdentifiedChannel defines a channel with additional port and channel identifier fields.
 * @export
 * @interface InlineResponse20075Channels
 */
export interface InlineResponse20075Channels {
    /**
     * State defines if a channel is in one of the following states: CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.   - STATE_UNINITIALIZED_UNSPECIFIED: Default State  - STATE_INIT: A channel has just started the opening handshake.  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.  - STATE_OPEN: A channel has completed the handshake. Open channels are ready to send and receive packets.  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive packets.
     * @type {string}
     * @memberof InlineResponse20075Channels
     */
    state?: InlineResponse20075ChannelsStateEnum;
    /**
     * - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in which they were sent.  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
     * @type {string}
     * @memberof InlineResponse20075Channels
     */
    ordering?: InlineResponse20075ChannelsOrderingEnum;
    /**
     * 
     * @type {CounterpartyChannelEnd}
     * @memberof InlineResponse20075Channels
     */
    counterparty?: CounterpartyChannelEnd;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse20075Channels
     */
    connection_hops?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20075Channels
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20075Channels
     */
    port_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20075Channels
     */
    channel_id?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20075ChannelsStateEnum {
    UninitializedUnspecified = 'STATE_UNINITIALIZED_UNSPECIFIED',
    Init = 'STATE_INIT',
    Tryopen = 'STATE_TRYOPEN',
    Open = 'STATE_OPEN',
    Closed = 'STATE_CLOSED'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20075ChannelsOrderingEnum {
    NoneUnspecified = 'ORDER_NONE_UNSPECIFIED',
    Unordered = 'ORDER_UNORDERED',
    Ordered = 'ORDER_ORDERED'
}

/**
 * QueryChannelResponse is the response type for the Query/Channel RPC method. Besides the Channel end, it includes a proof and the height from which the proof was retrieved.
 * @export
 * @interface InlineResponse20076
 */
export interface InlineResponse20076 {
    /**
     * 
     * @type {ChannelAssociatedWithTheRequestIdentifiers}
     * @memberof InlineResponse20076
     */
    channel?: ChannelAssociatedWithTheRequestIdentifiers;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20076
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof InlineResponse20076
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * QueryClientParamsResponse is the response type for the Query/ClientParams RPC method.
 * @export
 * @interface InlineResponse20077
 */
export interface InlineResponse20077 {
    /**
     * 
     * @type {InlineResponse20077Params}
     * @memberof InlineResponse20077
     */
    params?: InlineResponse20077Params;
}
/**
 * params defines the parameters of the module.
 * @export
 * @interface InlineResponse20077Params
 */
export interface InlineResponse20077Params {
    /**
     * allowed_clients defines the list of allowed client state types.
     * @type {Array<string>}
     * @memberof InlineResponse20077Params
     */
    allowed_clients?: Array<string>;
}
/**
 * QueryClientStatesResponse is the response type for the Query/ClientStates RPC method.
 * @export
 * @interface InlineResponse20078
 */
export interface InlineResponse20078 {
    /**
     * list of stored ClientStates of the chain.
     * @type {Array<InlineResponse20078ClientStates>}
     * @memberof InlineResponse20078
     */
    client_states?: Array<InlineResponse20078ClientStates>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof InlineResponse20078
     */
    pagination?: PaginationResponse;
}
/**
 * IdentifiedClientState defines a client state with an additional client identifier field.
 * @export
 * @interface InlineResponse20078ClientStates
 */
export interface InlineResponse20078ClientStates {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20078ClientStates
     */
    client_id?: string;
    /**
     * 
     * @type {ClientState}
     * @memberof InlineResponse20078ClientStates
     */
    client_state?: ClientState;
}
/**
 * QueryClientStateResponse is the response type for the Query/ClientState RPC method. Besides the client state, it includes a proof and the height from which the proof was retrieved.
 * @export
 * @interface InlineResponse20079
 */
export interface InlineResponse20079 {
    /**
     * 
     * @type {ClientStateAssociatedWithTheRequestIdentifier}
     * @memberof InlineResponse20079
     */
    client_state?: ClientStateAssociatedWithTheRequestIdentifier;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20079
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof InlineResponse20079
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008
     */
    type?: string;
    /**
     * 
     * @type {InlineResponse2008Value}
     * @memberof InlineResponse2008
     */
    value?: InlineResponse2008Value;
}
/**
 * QueryConnectionsResponse is the response type for the Query/Connections RPC method.
 * @export
 * @interface InlineResponse20080
 */
export interface InlineResponse20080 {
    /**
     * list of stored connections of the chain.
     * @type {Array<InlineResponse20080Connections>}
     * @memberof InlineResponse20080
     */
    connections?: Array<InlineResponse20080Connections>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof InlineResponse20080
     */
    pagination?: PaginationResponse;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof InlineResponse20080
     */
    height?: QueryBlockHeight;
}
/**
 * IdentifiedConnection defines a connection with additional connection identifier field.
 * @export
 * @interface InlineResponse20080Connections
 */
export interface InlineResponse20080Connections {
    /**
     * connection identifier.
     * @type {string}
     * @memberof InlineResponse20080Connections
     */
    id?: string;
    /**
     * client associated with this connection.
     * @type {string}
     * @memberof InlineResponse20080Connections
     */
    client_id?: string;
    /**
     * 
     * @type {Array<InlineResponse20080Versions>}
     * @memberof InlineResponse20080Connections
     */
    versions?: Array<InlineResponse20080Versions>;
    /**
     * current state of the connection end.
     * @type {string}
     * @memberof InlineResponse20080Connections
     */
    state?: InlineResponse20080ConnectionsStateEnum;
    /**
     * 
     * @type {InlineResponse20080Counterparty}
     * @memberof InlineResponse20080Connections
     */
    counterparty?: InlineResponse20080Counterparty;
    /**
     * delay period associated with this connection.
     * @type {string}
     * @memberof InlineResponse20080Connections
     */
    delay_period?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20080ConnectionsStateEnum {
    UninitializedUnspecified = 'STATE_UNINITIALIZED_UNSPECIFIED',
    Init = 'STATE_INIT',
    Tryopen = 'STATE_TRYOPEN',
    Open = 'STATE_OPEN'
}

/**
 * counterparty chain associated with this connection.
 * @export
 * @interface InlineResponse20080Counterparty
 */
export interface InlineResponse20080Counterparty {
    /**
     * identifies the client on the counterparty chain associated with a given connection.
     * @type {string}
     * @memberof InlineResponse20080Counterparty
     */
    client_id?: string;
    /**
     * identifies the connection end on the counterparty chain associated with a given connection.
     * @type {string}
     * @memberof InlineResponse20080Counterparty
     */
    connection_id?: string;
    /**
     * 
     * @type {MerklePrefixIsMerklePathPrefixedToTheKeyTheConstructedKeyFromThePathAndTheKeyWillBeAppendPathKeyPathAppendPathKeyPrefixKey}
     * @memberof InlineResponse20080Counterparty
     */
    prefix?: MerklePrefixIsMerklePathPrefixedToTheKeyTheConstructedKeyFromThePathAndTheKeyWillBeAppendPathKeyPathAppendPathKeyPrefixKey;
}
/**
 * Version defines the versioning scheme used to negotiate the IBC verison in the connection handshake.
 * @export
 * @interface InlineResponse20080Versions
 */
export interface InlineResponse20080Versions {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20080Versions
     */
    identifier?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse20080Versions
     */
    features?: Array<string>;
}
/**
 * QueryConnectionResponse is the response type for the Query/Connection RPC method. Besides the connection end, it includes a proof and the height from which the proof was retrieved.
 * @export
 * @interface InlineResponse20081
 */
export interface InlineResponse20081 {
    /**
     * 
     * @type {ConnectionAssociatedWithTheRequestIdentifier}
     * @memberof InlineResponse20081
     */
    connection?: ConnectionAssociatedWithTheRequestIdentifier;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20081
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof InlineResponse20081
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * QueryConnectionsResponse is the response type for the Query/DenomTraces RPC method.
 * @export
 * @interface InlineResponse20082
 */
export interface InlineResponse20082 {
    /**
     * denom_traces returns all denominations trace information.
     * @type {Array<InlineResponse20082DenomTraces>}
     * @memberof InlineResponse20082
     */
    denom_traces?: Array<InlineResponse20082DenomTraces>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof InlineResponse20082
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * DenomTrace contains the base denomination for ICS20 fungible tokens and the source tracing information path.
 * @export
 * @interface InlineResponse20082DenomTraces
 */
export interface InlineResponse20082DenomTraces {
    /**
     * path defines the chain of port/channel identifiers used for tracing the source of the fungible token.
     * @type {string}
     * @memberof InlineResponse20082DenomTraces
     */
    path?: string;
    /**
     * base denomination of the relayed fungible token.
     * @type {string}
     * @memberof InlineResponse20082DenomTraces
     */
    base_denom?: string;
}
/**
 * QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC method.
 * @export
 * @interface InlineResponse20083
 */
export interface InlineResponse20083 {
    /**
     * 
     * @type {InlineResponse20083DenomTrace}
     * @memberof InlineResponse20083
     */
    denom_trace?: InlineResponse20083DenomTrace;
}
/**
 * denom_trace returns the requested denomination trace information.
 * @export
 * @interface InlineResponse20083DenomTrace
 */
export interface InlineResponse20083DenomTrace {
    /**
     * path defines the chain of port/channel identifiers used for tracing the source of the fungible token.
     * @type {string}
     * @memberof InlineResponse20083DenomTrace
     */
    path?: string;
    /**
     * base denomination of the relayed fungible token.
     * @type {string}
     * @memberof InlineResponse20083DenomTrace
     */
    base_denom?: string;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface InlineResponse20084
 */
export interface InlineResponse20084 {
    /**
     * 
     * @type {InlineResponse20084Params}
     * @memberof InlineResponse20084
     */
    params?: InlineResponse20084Params;
}
/**
 * params defines the parameters of the module.
 * @export
 * @interface InlineResponse20084Params
 */
export interface InlineResponse20084Params {
    /**
     * send_enabled enables or disables all cross-chain token transfers from this chain.
     * @type {boolean}
     * @memberof InlineResponse20084Params
     */
    send_enabled?: boolean;
    /**
     * receive_enabled enables or disables all cross-chain token transfers to this chain.
     * @type {boolean}
     * @memberof InlineResponse20084Params
     */
    receive_enabled?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2008Value
 */
export interface InlineResponse2008Value {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008Value
     */
    account_number?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008Value
     */
    address?: string;
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof InlineResponse2008Value
     */
    coins?: Array<InlineResponse2004TxFeeAmount>;
    /**
     * 
     * @type {InlineResponse2008ValuePublicKey}
     * @memberof InlineResponse2008Value
     */
    public_key?: InlineResponse2008ValuePublicKey;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008Value
     */
    sequence?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2008ValuePublicKey
 */
export interface InlineResponse2008ValuePublicKey {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008ValuePublicKey
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008ValuePublicKey
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2009
     */
    delegator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2009
     */
    validator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2009
     */
    shares?: string;
    /**
     * 
     * @type {InlineResponse2004TxFeeAmount}
     * @memberof InlineResponse2009
     */
    balance?: InlineResponse2004TxFeeAmount;
}
/**
 * 
 * @export
 * @interface InlineResponse200ApplicationVersion
 */
export interface InlineResponse200ApplicationVersion {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200ApplicationVersion
     */
    build_tags?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200ApplicationVersion
     */
    client_name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200ApplicationVersion
     */
    commit?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200ApplicationVersion
     */
    go?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200ApplicationVersion
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200ApplicationVersion
     */
    server_name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200ApplicationVersion
     */
    version?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200NodeInfo
 */
export interface InlineResponse200NodeInfo {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200NodeInfo
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200NodeInfo
     */
    moniker?: string;
    /**
     * 
     * @type {InlineResponse200NodeInfoProtocolVersion}
     * @memberof InlineResponse200NodeInfo
     */
    protocol_version?: InlineResponse200NodeInfoProtocolVersion;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200NodeInfo
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200NodeInfo
     */
    channels?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200NodeInfo
     */
    listen_addr?: string;
    /**
     * Tendermint version
     * @type {string}
     * @memberof InlineResponse200NodeInfo
     */
    version?: string;
    /**
     * 
     * @type {InlineResponse200NodeInfoOther}
     * @memberof InlineResponse200NodeInfo
     */
    other?: InlineResponse200NodeInfoOther;
}
/**
 * more information on versions
 * @export
 * @interface InlineResponse200NodeInfoOther
 */
export interface InlineResponse200NodeInfoOther {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200NodeInfoOther
     */
    tx_index?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200NodeInfoOther
     */
    rpc_address?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200NodeInfoProtocolVersion
 */
export interface InlineResponse200NodeInfoProtocolVersion {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200NodeInfoProtocolVersion
     */
    p2p?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200NodeInfoProtocolVersion
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200NodeInfoProtocolVersion
     */
    app?: string;
}
/**
 * 
 * @export
 * @interface InlineResponseDefault
 */
export interface InlineResponseDefault {
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponseDefault
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault
     */
    message?: string;
    /**
     * 
     * @type {Array<InlineResponseDefaultDetails>}
     * @memberof InlineResponseDefault
     */
    details?: Array<InlineResponseDefaultDetails>;
}
/**
 * 
 * @export
 * @interface InlineResponseDefault1
 */
export interface InlineResponseDefault1 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault1
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponseDefault1
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault1
     */
    message?: string;
    /**
     * 
     * @type {Array<InlineResponseDefault1Details>}
     * @memberof InlineResponseDefault1
     */
    details?: Array<InlineResponseDefault1Details>;
}
/**
 * 
 * @export
 * @interface InlineResponseDefault1Details
 */
export interface InlineResponseDefault1Details {
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault1Details
     */
    type_url?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault1Details
     */
    value?: string;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface InlineResponseDefaultDetails
 */
export interface InlineResponseDefaultDetails {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof InlineResponseDefaultDetails
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof InlineResponseDefaultDetails
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface KVPair
 */
export interface KVPair {
    /**
     * 
     * @type {string}
     * @memberof KVPair
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof KVPair
     */
    value?: string;
}
/**
 * commitment merkle prefix of the counterparty chain.
 * @export
 * @interface MerklePrefixIsMerklePathPrefixedToTheKeyTheConstructedKeyFromThePathAndTheKeyWillBeAppendPathKeyPathAppendPathKeyPrefixKey
 */
export interface MerklePrefixIsMerklePathPrefixedToTheKeyTheConstructedKeyFromThePathAndTheKeyWillBeAppendPathKeyPathAppendPathKeyPrefixKey {
    /**
     * 
     * @type {string}
     * @memberof MerklePrefixIsMerklePathPrefixedToTheKeyTheConstructedKeyFromThePathAndTheKeyWillBeAppendPathKeyPathAppendPathKeyPrefixKey
     */
    key_prefix?: string;
}
/**
 * 
 * @export
 * @interface ModuleIsTheTypeForVersionInfo
 */
export interface ModuleIsTheTypeForVersionInfo {
    /**
     * 
     * @type {string}
     * @memberof ModuleIsTheTypeForVersionInfo
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleIsTheTypeForVersionInfo
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleIsTheTypeForVersionInfo
     */
    sum?: string;
}
/**
 * 
 * @export
 * @interface PaginatedQueryTxs
 */
export interface PaginatedQueryTxs {
    /**
     * 
     * @type {number}
     * @memberof PaginatedQueryTxs
     */
    total_count?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedQueryTxs
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedQueryTxs
     */
    page_number?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedQueryTxs
     */
    page_total?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedQueryTxs
     */
    limit?: number;
    /**
     * 
     * @type {Array<InlineResponse2004>}
     * @memberof PaginatedQueryTxs
     */
    txs?: Array<InlineResponse2004>;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the corresponding request message has used PageRequest.   message SomeResponse {          repeated Bar results = 1;          PageResponse page = 2;  }
 * @export
 * @interface PaginationResponse
 */
export interface PaginationResponse {
    /**
     * 
     * @type {string}
     * @memberof PaginationResponse
     */
    next_key?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationResponse
     */
    total?: string;
}
/**
 * 
 * @export
 * @interface ParamChange
 */
export interface ParamChange {
    /**
     * 
     * @type {string}
     * @memberof ParamChange
     */
    subspace?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamChange
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamChange
     */
    subkey?: string;
    /**
     * 
     * @type {object}
     * @memberof ParamChange
     */
    value?: object;
}
/**
 * 
 * @export
 * @interface PartsetHeader
 */
export interface PartsetHeader {
    /**
     * 
     * @type {number}
     * @memberof PartsetHeader
     */
    total?: number;
    /**
     * 
     * @type {string}
     * @memberof PartsetHeader
     */
    hash?: string;
}
/**
 * 
 * @export
 * @interface PrevBlockInfo
 */
export interface PrevBlockInfo {
    /**
     * 
     * @type {string}
     * @memberof PrevBlockInfo
     */
    hash?: string;
    /**
     * 
     * @type {PartsetHeader}
     * @memberof PrevBlockInfo
     */
    part_set_header?: PartsetHeader;
}
/**
 * 
 * @export
 * @interface Proposer
 */
export interface Proposer {
    /**
     * 
     * @type {string}
     * @memberof Proposer
     */
    proposal_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Proposer
     */
    proposer?: string;
}
/**
 * 
 * @export
 * @interface PublicKey
 */
export interface PublicKey {
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface PublicKeyDefinesTheKeysAvailableForUseWithTendermintValidators
 */
export interface PublicKeyDefinesTheKeysAvailableForUseWithTendermintValidators {
    /**
     * 
     * @type {string}
     * @memberof PublicKeyDefinesTheKeysAvailableForUseWithTendermintValidators
     */
    ed25519?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyDefinesTheKeysAvailableForUseWithTendermintValidators
     */
    secp256k1?: string;
}
/**
 * Normally the RevisionHeight is incremented at each height while keeping RevisionNumber the same. However some consensus algorithms may choose to reset the height in certain conditions e.g. hard forks, state-machine breaking changes In these cases, the RevisionNumber is incremented so that height continues to be monitonically increasing even as the RevisionHeight gets reset
 * @export
 * @interface QueryBlockHeight
 */
export interface QueryBlockHeight {
    /**
     * 
     * @type {string}
     * @memberof QueryBlockHeight
     */
    revision_number?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryBlockHeight
     */
    revision_height?: string;
}
/**
 * 
 * @export
 * @interface QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod
 */
export interface QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod {
    /**
     * 
     * @type {ClientStateAssociatedWithTheChannel}
     * @memberof QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod
     */
    identified_client_state?: ClientStateAssociatedWithTheChannel;
    /**
     * 
     * @type {string}
     * @memberof QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod1
 */
export interface QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod1 {
    /**
     * 
     * @type {ConsensusStateAssociatedWithTheChannel}
     * @memberof QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod1
     */
    consensus_state?: ConsensusStateAssociatedWithTheChannel;
    /**
     * 
     * @type {string}
     * @memberof QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod1
     */
    client_id?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod1
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod1
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface QueryClientConnectionsResponseIsTheResponseTypeForTheQueryClientConnectionsRPCMethod
 */
export interface QueryClientConnectionsResponseIsTheResponseTypeForTheQueryClientConnectionsRPCMethod {
    /**
     * slice of all the connection paths associated with a client.
     * @type {Array<string>}
     * @memberof QueryClientConnectionsResponseIsTheResponseTypeForTheQueryClientConnectionsRPCMethod
     */
    connection_paths?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof QueryClientConnectionsResponseIsTheResponseTypeForTheQueryClientConnectionsRPCMethod
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasGenerated}
     * @memberof QueryClientConnectionsResponseIsTheResponseTypeForTheQueryClientConnectionsRPCMethod
     */
    proof_height?: HeightAtWhichTheProofWasGenerated;
}
/**
 * 
 * @export
 * @interface QueryConnectionChannelsResponseIsTheResponseTypeForTheQueryQueryConnectionChannelsRPCMethod
 */
export interface QueryConnectionChannelsResponseIsTheResponseTypeForTheQueryQueryConnectionChannelsRPCMethod {
    /**
     * list of channels associated with a connection.
     * @type {Array<InlineResponse20075Channels>}
     * @memberof QueryConnectionChannelsResponseIsTheResponseTypeForTheQueryQueryConnectionChannelsRPCMethod
     */
    channels?: Array<InlineResponse20075Channels>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof QueryConnectionChannelsResponseIsTheResponseTypeForTheQueryQueryConnectionChannelsRPCMethod
     */
    pagination?: PaginationResponse;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof QueryConnectionChannelsResponseIsTheResponseTypeForTheQueryQueryConnectionChannelsRPCMethod
     */
    height?: QueryBlockHeight;
}
/**
 * 
 * @export
 * @interface QueryConnectionClientStateResponseIsTheResponseTypeForTheQueryConnectionClientStateRPCMethod
 */
export interface QueryConnectionClientStateResponseIsTheResponseTypeForTheQueryConnectionClientStateRPCMethod {
    /**
     * 
     * @type {ClientStateAssociatedWithTheChannel}
     * @memberof QueryConnectionClientStateResponseIsTheResponseTypeForTheQueryConnectionClientStateRPCMethod
     */
    identified_client_state?: ClientStateAssociatedWithTheChannel;
    /**
     * 
     * @type {string}
     * @memberof QueryConnectionClientStateResponseIsTheResponseTypeForTheQueryConnectionClientStateRPCMethod
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof QueryConnectionClientStateResponseIsTheResponseTypeForTheQueryConnectionClientStateRPCMethod
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface QueryConnectionConsensusStateResponseIsTheResponseTypeForTheQueryConnectionConsensusStateRPCMethod
 */
export interface QueryConnectionConsensusStateResponseIsTheResponseTypeForTheQueryConnectionConsensusStateRPCMethod {
    /**
     * 
     * @type {ConsensusStateAssociatedWithTheChannel}
     * @memberof QueryConnectionConsensusStateResponseIsTheResponseTypeForTheQueryConnectionConsensusStateRPCMethod
     */
    consensus_state?: ConsensusStateAssociatedWithTheChannel;
    /**
     * 
     * @type {string}
     * @memberof QueryConnectionConsensusStateResponseIsTheResponseTypeForTheQueryConnectionConsensusStateRPCMethod
     */
    client_id?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryConnectionConsensusStateResponseIsTheResponseTypeForTheQueryConnectionConsensusStateRPCMethod
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof QueryConnectionConsensusStateResponseIsTheResponseTypeForTheQueryConnectionConsensusStateRPCMethod
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface QueryConsensusStateResponseIsTheResponseTypeForTheQueryConsensusStateRPCMethod
 */
export interface QueryConsensusStateResponseIsTheResponseTypeForTheQueryConsensusStateRPCMethod {
    /**
     * 
     * @type {ConsensusStateAssociatedWithTheClientIdentifierAtTheGivenHeight}
     * @memberof QueryConsensusStateResponseIsTheResponseTypeForTheQueryConsensusStateRPCMethod
     */
    consensus_state?: ConsensusStateAssociatedWithTheClientIdentifierAtTheGivenHeight;
    /**
     * 
     * @type {string}
     * @memberof QueryConsensusStateResponseIsTheResponseTypeForTheQueryConsensusStateRPCMethod
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof QueryConsensusStateResponseIsTheResponseTypeForTheQueryConsensusStateRPCMethod
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethod
 */
export interface QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethod {
    /**
     * 
     * @type {Array<QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethodConsensusStates>}
     * @memberof QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethod
     */
    consensus_states?: Array<QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethodConsensusStates>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethod
     */
    pagination?: PaginationResponse;
}
/**
 * ConsensusStateWithHeight defines a consensus state with an additional height field.
 * @export
 * @interface QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethodConsensusStates
 */
export interface QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethodConsensusStates {
    /**
     * 
     * @type {ConsensusStateHeight}
     * @memberof QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethodConsensusStates
     */
    height?: ConsensusStateHeight;
    /**
     * 
     * @type {ConsensusState}
     * @memberof QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethodConsensusStates
     */
    consensus_state?: ConsensusState;
}
/**
 * 
 * @export
 * @interface QueryPacketAcknowledgementResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
 */
export interface QueryPacketAcknowledgementResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved {
    /**
     * 
     * @type {string}
     * @memberof QueryPacketAcknowledgementResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
     */
    acknowledgement?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryPacketAcknowledgementResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof QueryPacketAcknowledgementResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethod
 */
export interface QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethod {
    /**
     * 
     * @type {Array<QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgements>}
     * @memberof QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethod
     */
    acknowledgements?: Array<QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgements>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethod
     */
    pagination?: PaginationResponse;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethod
     */
    height?: QueryBlockHeight;
}
/**
 * PacketState defines the generic type necessary to retrieve and store packet commitments, acknowledgements, and receipts. Caller is responsible for knowing the context necessary to interpret this state as a commitment, acknowledgement, or a receipt.
 * @export
 * @interface QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgements
 */
export interface QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgements {
    /**
     * channel port identifier.
     * @type {string}
     * @memberof QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgements
     */
    port_id?: string;
    /**
     * channel unique identifier.
     * @type {string}
     * @memberof QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgements
     */
    channel_id?: string;
    /**
     * packet sequence.
     * @type {string}
     * @memberof QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgements
     */
    sequence?: string;
    /**
     * embedded data that represents packet state.
     * @type {string}
     * @memberof QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgements
     */
    data?: string;
}
/**
 * 
 * @export
 * @interface QueryPacketCommitmentResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
 */
export interface QueryPacketCommitmentResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved {
    /**
     * 
     * @type {string}
     * @memberof QueryPacketCommitmentResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
     */
    commitment?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryPacketCommitmentResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof QueryPacketCommitmentResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface QueryPacketCommitmentsResponseIsTheRequestTypeForTheQueryQueryPacketCommitmentsRPCMethod
 */
export interface QueryPacketCommitmentsResponseIsTheRequestTypeForTheQueryQueryPacketCommitmentsRPCMethod {
    /**
     * 
     * @type {Array<QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgements>}
     * @memberof QueryPacketCommitmentsResponseIsTheRequestTypeForTheQueryQueryPacketCommitmentsRPCMethod
     */
    commitments?: Array<QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethodAcknowledgements>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof QueryPacketCommitmentsResponseIsTheRequestTypeForTheQueryQueryPacketCommitmentsRPCMethod
     */
    pagination?: PaginationResponse;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof QueryPacketCommitmentsResponseIsTheRequestTypeForTheQueryQueryPacketCommitmentsRPCMethod
     */
    height?: QueryBlockHeight;
}
/**
 * 
 * @export
 * @interface QueryPacketReceiptResponseDefinesTheClientQueryResponseForAPacketReceiptWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
 */
export interface QueryPacketReceiptResponseDefinesTheClientQueryResponseForAPacketReceiptWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved {
    /**
     * 
     * @type {boolean}
     * @memberof QueryPacketReceiptResponseDefinesTheClientQueryResponseForAPacketReceiptWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
     */
    received?: boolean;
    /**
     * 
     * @type {string}
     * @memberof QueryPacketReceiptResponseDefinesTheClientQueryResponseForAPacketReceiptWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof QueryPacketReceiptResponseDefinesTheClientQueryResponseForAPacketReceiptWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethod
 */
export interface QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethod {
    /**
     * 
     * @type {QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams}
     * @memberof QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethod
     */
    params?: QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams;
}
/**
 * Params represents the parameters used for by the slashing module.
 * @export
 * @interface QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams
 */
export interface QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams {
    /**
     * 
     * @type {string}
     * @memberof QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams
     */
    signed_blocks_window?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams
     */
    min_signed_per_window?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams
     */
    downtime_jail_duration?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams
     */
    slash_fraction_double_sign?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams
     */
    slash_fraction_downtime?: string;
}
/**
 * 
 * @export
 * @interface QuerySequenceResponseIsTheRequestTypeForTheQueryQueryNextSequenceReceiveResponseRPCMethod
 */
export interface QuerySequenceResponseIsTheRequestTypeForTheQueryQueryNextSequenceReceiveResponseRPCMethod {
    /**
     * 
     * @type {string}
     * @memberof QuerySequenceResponseIsTheRequestTypeForTheQueryQueryNextSequenceReceiveResponseRPCMethod
     */
    next_sequence_receive?: string;
    /**
     * 
     * @type {string}
     * @memberof QuerySequenceResponseIsTheRequestTypeForTheQueryQueryNextSequenceReceiveResponseRPCMethod
     */
    proof?: string;
    /**
     * 
     * @type {HeightAtWhichTheProofWasRetrieved}
     * @memberof QuerySequenceResponseIsTheRequestTypeForTheQueryQueryNextSequenceReceiveResponseRPCMethod
     */
    proof_height?: HeightAtWhichTheProofWasRetrieved;
}
/**
 * 
 * @export
 * @interface QuerySigningInfoResponseIsTheResponseTypeForTheQuerySigningInfoRPCMethod
 */
export interface QuerySigningInfoResponseIsTheResponseTypeForTheQuerySigningInfoRPCMethod {
    /**
     * 
     * @type {ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress}
     * @memberof QuerySigningInfoResponseIsTheResponseTypeForTheQuerySigningInfoRPCMethod
     */
    val_signing_info?: ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress;
}
/**
 * 
 * @export
 * @interface QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethod
 */
export interface QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethod {
    /**
     * 
     * @type {Array<QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodInfo>}
     * @memberof QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethod
     */
    info?: Array<QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodInfo>;
    /**
     * 
     * @type {QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination}
     * @memberof QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethod
     */
    pagination?: QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination;
}
/**
 * ValidatorSigningInfo defines a validator\'s signing info for monitoring their liveness activity.
 * @export
 * @interface QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodInfo
 */
export interface QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodInfo {
    /**
     * 
     * @type {string}
     * @memberof QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodInfo
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodInfo
     */
    start_height?: string;
    /**
     * 
     * @type {string}
     * @memberof QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodInfo
     */
    index_offset?: string;
    /**
     * 
     * @type {string}
     * @memberof QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodInfo
     */
    jailed_until?: string;
    /**
     * 
     * @type {boolean}
     * @memberof QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodInfo
     */
    tombstoned?: boolean;
    /**
     * 
     * @type {string}
     * @memberof QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodInfo
     */
    missed_blocks_counter?: string;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the corresponding request message has used PageRequest.   message SomeResponse {          repeated Bar results = 1;          PageResponse page = 2;  }
 * @export
 * @interface QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination
 */
export interface QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination {
    /**
     * 
     * @type {string}
     * @memberof QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination
     */
    next_key?: string;
    /**
     * 
     * @type {string}
     * @memberof QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination
     */
    total?: string;
}
/**
 * 
 * @export
 * @interface QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCMethod
 */
export interface QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCMethod {
    /**
     * 
     * @type {Array<InlineResponse20027Balances>}
     * @memberof QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCMethod
     */
    supply?: Array<InlineResponse20027Balances>;
}
/**
 * 
 * @export
 * @interface QueryUnreceivedAcksResponseIsTheResponseTypeForTheQueryUnreceivedAcksRPCMethod
 */
export interface QueryUnreceivedAcksResponseIsTheResponseTypeForTheQueryUnreceivedAcksRPCMethod {
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryUnreceivedAcksResponseIsTheResponseTypeForTheQueryUnreceivedAcksRPCMethod
     */
    sequences?: Array<string>;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof QueryUnreceivedAcksResponseIsTheResponseTypeForTheQueryUnreceivedAcksRPCMethod
     */
    height?: QueryBlockHeight;
}
/**
 * 
 * @export
 * @interface QueryUnreceivedPacketsResponseIsTheResponseTypeForTheQueryUnreceivedPacketCommitmentsRPCMethod
 */
export interface QueryUnreceivedPacketsResponseIsTheResponseTypeForTheQueryUnreceivedPacketCommitmentsRPCMethod {
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryUnreceivedPacketsResponseIsTheResponseTypeForTheQueryUnreceivedPacketCommitmentsRPCMethod
     */
    sequences?: Array<string>;
    /**
     * 
     * @type {QueryBlockHeight}
     * @memberof QueryUnreceivedPacketsResponseIsTheResponseTypeForTheQueryUnreceivedPacketCommitmentsRPCMethod
     */
    height?: QueryBlockHeight;
}
/**
 * 
 * @export
 * @interface QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethod
 */
export interface QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethod {
    /**
     * 
     * @type {QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethodCommission}
     * @memberof QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethod
     */
    commission?: QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethodCommission;
}
/**
 * commission defines the commision the validator received.
 * @export
 * @interface QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethodCommission
 */
export interface QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethodCommission {
    /**
     * 
     * @type {Array<InlineResponse20037Pool>}
     * @memberof QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethodCommission
     */
    commission?: Array<InlineResponse20037Pool>;
}
/**
 * 
 * @export
 * @interface QueryValidatorDelegationsResponseIsResponseTypeForTheQueryValidatorDelegationsRPCMethod
 */
export interface QueryValidatorDelegationsResponseIsResponseTypeForTheQueryValidatorDelegationsRPCMethod {
    /**
     * 
     * @type {Array<InlineResponse20059DelegationResponses>}
     * @memberof QueryValidatorDelegationsResponseIsResponseTypeForTheQueryValidatorDelegationsRPCMethod
     */
    delegation_responses?: Array<InlineResponse20059DelegationResponses>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof QueryValidatorDelegationsResponseIsResponseTypeForTheQueryValidatorDelegationsRPCMethod
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * 
 * @export
 * @interface QueryValidatorResponseIsResponseTypeForTheQueryValidatorRPCMethod
 */
export interface QueryValidatorResponseIsResponseTypeForTheQueryValidatorRPCMethod {
    /**
     * 
     * @type {InlineResponse20063Validator}
     * @memberof QueryValidatorResponseIsResponseTypeForTheQueryValidatorRPCMethod
     */
    validator?: InlineResponse20063Validator;
}
/**
 * 
 * @export
 * @interface QueryValidatorsResponseIsResponseTypeForTheQueryValidatorsRPCMethod
 */
export interface QueryValidatorsResponseIsResponseTypeForTheQueryValidatorsRPCMethod {
    /**
     * validators contains all the queried validators.
     * @type {Array<InlineResponse20062Validators>}
     * @memberof QueryValidatorsResponseIsResponseTypeForTheQueryValidatorsRPCMethod
     */
    validators?: Array<InlineResponse20062Validators>;
    /**
     * 
     * @type {InlineResponse20027Pagination}
     * @memberof QueryValidatorsResponseIsResponseTypeForTheQueryValidatorsRPCMethod
     */
    pagination?: InlineResponse20027Pagination;
}
/**
 * 
 * @export
 * @interface Redelegation
 */
export interface Redelegation {
    /**
     * 
     * @type {string}
     * @memberof Redelegation
     */
    delegator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof Redelegation
     */
    validator_src_address?: string;
    /**
     * 
     * @type {string}
     * @memberof Redelegation
     */
    validator_dst_address?: string;
    /**
     * 
     * @type {Array<Redelegation>}
     * @memberof Redelegation
     */
    entries?: Array<Redelegation>;
}
/**
 * 
 * @export
 * @interface RedelegationEntry
 */
export interface RedelegationEntry {
    /**
     * 
     * @type {number}
     * @memberof RedelegationEntry
     */
    creation_height?: number;
    /**
     * 
     * @type {number}
     * @memberof RedelegationEntry
     */
    completion_time?: number;
    /**
     * 
     * @type {string}
     * @memberof RedelegationEntry
     */
    initial_balance?: string;
    /**
     * 
     * @type {string}
     * @memberof RedelegationEntry
     */
    balance?: string;
    /**
     * 
     * @type {string}
     * @memberof RedelegationEntry
     */
    shares_dst?: string;
}
/**
 * 
 * @export
 * @interface SigningInfo
 */
export interface SigningInfo {
    /**
     * 
     * @type {string}
     * @memberof SigningInfo
     */
    start_height?: string;
    /**
     * 
     * @type {string}
     * @memberof SigningInfo
     */
    index_offset?: string;
    /**
     * 
     * @type {string}
     * @memberof SigningInfo
     */
    jailed_until?: string;
    /**
     * 
     * @type {string}
     * @memberof SigningInfo
     */
    missed_blocks_counter?: string;
}
/**
 * 
 * @export
 * @interface SingleRepresentsASingleSigner
 */
export interface SingleRepresentsASingleSigner {
    /**
     * SignMode represents a signing mode with its own security guarantees.   - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be rejected  - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is verified with raw bytes from Tx  - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some human-readable textual representation on top of the binary representation from SIGN_MODE_DIRECT  - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses Amino JSON and will be removed in the future
     * @type {string}
     * @memberof SingleRepresentsASingleSigner
     */
    mode?: SingleRepresentsASingleSignerModeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SingleRepresentsASingleSignerModeEnum {
    Unspecified = 'SIGN_MODE_UNSPECIFIED',
    Direct = 'SIGN_MODE_DIRECT',
    Textual = 'SIGN_MODE_TEXTUAL',
    LegacyAminoJson = 'SIGN_MODE_LEGACY_AMINO_JSON'
}

/**
 * 
 * @export
 * @interface StakingDelegatorsDelegatorAddrValidatorsCommission
 */
export interface StakingDelegatorsDelegatorAddrValidatorsCommission {
    /**
     * 
     * @type {string}
     * @memberof StakingDelegatorsDelegatorAddrValidatorsCommission
     */
    rate?: string;
    /**
     * 
     * @type {string}
     * @memberof StakingDelegatorsDelegatorAddrValidatorsCommission
     */
    max_rate?: string;
    /**
     * 
     * @type {string}
     * @memberof StakingDelegatorsDelegatorAddrValidatorsCommission
     */
    max_change_rate?: string;
    /**
     * 
     * @type {string}
     * @memberof StakingDelegatorsDelegatorAddrValidatorsCommission
     */
    update_time?: string;
}
/**
 * 
 * @export
 * @interface StakingDelegatorsDelegatorAddrValidatorsDescription
 */
export interface StakingDelegatorsDelegatorAddrValidatorsDescription {
    /**
     * 
     * @type {string}
     * @memberof StakingDelegatorsDelegatorAddrValidatorsDescription
     */
    moniker?: string;
    /**
     * 
     * @type {string}
     * @memberof StakingDelegatorsDelegatorAddrValidatorsDescription
     */
    identity?: string;
    /**
     * 
     * @type {string}
     * @memberof StakingDelegatorsDelegatorAddrValidatorsDescription
     */
    website?: string;
    /**
     * 
     * @type {string}
     * @memberof StakingDelegatorsDelegatorAddrValidatorsDescription
     */
    security_contact?: string;
    /**
     * 
     * @type {string}
     * @memberof StakingDelegatorsDelegatorAddrValidatorsDescription
     */
    details?: string;
}
/**
 * 
 * @export
 * @interface StdTx
 */
export interface StdTx {
    /**
     * 
     * @type {Array<string>}
     * @memberof StdTx
     */
    msg?: Array<string>;
    /**
     * 
     * @type {InlineResponse2004TxFee}
     * @memberof StdTx
     */
    fee?: InlineResponse2004TxFee;
    /**
     * 
     * @type {string}
     * @memberof StdTx
     */
    memo?: string;
    /**
     * 
     * @type {InlineResponse2004TxSignature}
     * @memberof StdTx
     */
    signature?: InlineResponse2004TxSignature;
}
/**
 * 
 * @export
 * @interface Supply
 */
export interface Supply {
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof Supply
     */
    total?: Array<InlineResponse2004TxFeeAmount>;
}
/**
 * 
 * @export
 * @interface TallyResult
 */
export interface TallyResult {
    /**
     * 
     * @type {string}
     * @memberof TallyResult
     */
    yes?: string;
    /**
     * 
     * @type {string}
     * @memberof TallyResult
     */
    abstain?: string;
    /**
     * 
     * @type {string}
     * @memberof TallyResult
     */
    no?: string;
    /**
     * 
     * @type {string}
     * @memberof TallyResult
     */
    no_with_veto?: string;
}
/**
 * Event allows application developers to attach additional information to ResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx. Later, transactions may be queried using these events.
 * @export
 * @interface TendermintAbciEvent
 */
export interface TendermintAbciEvent {
    /**
     * 
     * @type {string}
     * @memberof TendermintAbciEvent
     */
    type?: string;
    /**
     * 
     * @type {Array<InlineResponse20070ResultAttributes>}
     * @memberof TendermintAbciEvent
     */
    attributes?: Array<InlineResponse20070ResultAttributes>;
}
/**
 * EventAttribute is a single key-value pair, associated with an event.
 * @export
 * @interface TendermintAbciEventAttribute
 */
export interface TendermintAbciEventAttribute {
    /**
     * 
     * @type {string}
     * @memberof TendermintAbciEventAttribute
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintAbciEventAttribute
     */
    value?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TendermintAbciEventAttribute
     */
    index?: boolean;
}
/**
 * 
 * @export
 * @interface TendermintCryptoPublicKey
 */
export interface TendermintCryptoPublicKey {
    /**
     * 
     * @type {string}
     * @memberof TendermintCryptoPublicKey
     */
    ed25519?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintCryptoPublicKey
     */
    secp256k1?: string;
}
/**
 * 
 * @export
 * @interface TendermintP2pDefaultNodeInfo
 */
export interface TendermintP2pDefaultNodeInfo {
    /**
     * 
     * @type {InlineResponse20033DefaultNodeInfoProtocolVersion}
     * @memberof TendermintP2pDefaultNodeInfo
     */
    protocol_version?: InlineResponse20033DefaultNodeInfoProtocolVersion;
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pDefaultNodeInfo
     */
    default_node_id?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pDefaultNodeInfo
     */
    listen_addr?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pDefaultNodeInfo
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pDefaultNodeInfo
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pDefaultNodeInfo
     */
    channels?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pDefaultNodeInfo
     */
    moniker?: string;
    /**
     * 
     * @type {InlineResponse20033DefaultNodeInfoOther}
     * @memberof TendermintP2pDefaultNodeInfo
     */
    other?: InlineResponse20033DefaultNodeInfoOther;
}
/**
 * 
 * @export
 * @interface TendermintP2pDefaultNodeInfoOther
 */
export interface TendermintP2pDefaultNodeInfoOther {
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pDefaultNodeInfoOther
     */
    tx_index?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pDefaultNodeInfoOther
     */
    rpc_address?: string;
}
/**
 * 
 * @export
 * @interface TendermintP2pProtocolVersion
 */
export interface TendermintP2pProtocolVersion {
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pProtocolVersion
     */
    p2p?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pProtocolVersion
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pProtocolVersion
     */
    app?: string;
}
/**
 * 
 * @export
 * @interface TendermintTypesBlock
 */
export interface TendermintTypesBlock {
    /**
     * 
     * @type {InlineResponse20031BlockHeader}
     * @memberof TendermintTypesBlock
     */
    header?: InlineResponse20031BlockHeader;
    /**
     * 
     * @type {DataContainsTheSetOfTransactionsIncludedInTheBlock}
     * @memberof TendermintTypesBlock
     */
    data?: DataContainsTheSetOfTransactionsIncludedInTheBlock;
    /**
     * 
     * @type {InlineResponse20031BlockEvidence}
     * @memberof TendermintTypesBlock
     */
    evidence?: InlineResponse20031BlockEvidence;
    /**
     * 
     * @type {InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit}
     * @memberof TendermintTypesBlock
     */
    last_commit?: InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit;
}
/**
 * 
 * @export
 * @interface TendermintTypesBlockID
 */
export interface TendermintTypesBlockID {
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesBlockID
     */
    hash?: string;
    /**
     * 
     * @type {PartsetHeader}
     * @memberof TendermintTypesBlockID
     */
    part_set_header?: PartsetHeader;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TendermintTypesBlockIDFlag {
    Unknown = 'BLOCK_ID_FLAG_UNKNOWN',
    Absent = 'BLOCK_ID_FLAG_ABSENT',
    Commit = 'BLOCK_ID_FLAG_COMMIT',
    Nil = 'BLOCK_ID_FLAG_NIL'
}

/**
 * Commit contains the evidence that a block was committed by a set of validators.
 * @export
 * @interface TendermintTypesCommit
 */
export interface TendermintTypesCommit {
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesCommit
     */
    height?: string;
    /**
     * 
     * @type {number}
     * @memberof TendermintTypesCommit
     */
    round?: number;
    /**
     * 
     * @type {BlockID1}
     * @memberof TendermintTypesCommit
     */
    block_id?: BlockID1;
    /**
     * 
     * @type {Array<InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignatures>}
     * @memberof TendermintTypesCommit
     */
    signatures?: Array<InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignatures>;
}
/**
 * CommitSig is a part of the Vote included in a Commit.
 * @export
 * @interface TendermintTypesCommitSig
 */
export interface TendermintTypesCommitSig {
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesCommitSig
     */
    block_id_flag?: TendermintTypesCommitSigBlockIdFlagEnum;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesCommitSig
     */
    validator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesCommitSig
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesCommitSig
     */
    signature?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TendermintTypesCommitSigBlockIdFlagEnum {
    Unknown = 'BLOCK_ID_FLAG_UNKNOWN',
    Absent = 'BLOCK_ID_FLAG_ABSENT',
    Commit = 'BLOCK_ID_FLAG_COMMIT',
    Nil = 'BLOCK_ID_FLAG_NIL'
}

/**
 * 
 * @export
 * @interface TendermintTypesData
 */
export interface TendermintTypesData {
    /**
     * Txs that will be applied by state @ block.Height+1. NOTE: not all txs here are valid.  We\'re just agreeing on the order first. This means that block.AppHash does not include these txs.
     * @type {Array<string>}
     * @memberof TendermintTypesData
     */
    txs?: Array<string>;
}
/**
 * DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.
 * @export
 * @interface TendermintTypesDuplicateVoteEvidence
 */
export interface TendermintTypesDuplicateVoteEvidence {
    /**
     * 
     * @type {InlineResponse20031BlockEvidenceDuplicateVoteEvidenceVoteA}
     * @memberof TendermintTypesDuplicateVoteEvidence
     */
    vote_a?: InlineResponse20031BlockEvidenceDuplicateVoteEvidenceVoteA;
    /**
     * 
     * @type {InlineResponse20031BlockEvidenceDuplicateVoteEvidenceVoteA}
     * @memberof TendermintTypesDuplicateVoteEvidence
     */
    vote_b?: InlineResponse20031BlockEvidenceDuplicateVoteEvidenceVoteA;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesDuplicateVoteEvidence
     */
    total_voting_power?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesDuplicateVoteEvidence
     */
    validator_power?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesDuplicateVoteEvidence
     */
    timestamp?: string;
}
/**
 * 
 * @export
 * @interface TendermintTypesEvidence
 */
export interface TendermintTypesEvidence {
    /**
     * 
     * @type {InlineResponse20031BlockEvidenceDuplicateVoteEvidence}
     * @memberof TendermintTypesEvidence
     */
    duplicate_vote_evidence?: InlineResponse20031BlockEvidenceDuplicateVoteEvidence;
    /**
     * 
     * @type {InlineResponse20031BlockEvidenceLightClientAttackEvidence}
     * @memberof TendermintTypesEvidence
     */
    light_client_attack_evidence?: InlineResponse20031BlockEvidenceLightClientAttackEvidence;
}
/**
 * 
 * @export
 * @interface TendermintTypesEvidenceList
 */
export interface TendermintTypesEvidenceList {
    /**
     * 
     * @type {Array<InlineResponse20031BlockEvidenceEvidence>}
     * @memberof TendermintTypesEvidenceList
     */
    evidence?: Array<InlineResponse20031BlockEvidenceEvidence>;
}
/**
 * Header defines the structure of a Tendermint block header.
 * @export
 * @interface TendermintTypesHeader
 */
export interface TendermintTypesHeader {
    /**
     * 
     * @type {BasicBlockInfo}
     * @memberof TendermintTypesHeader
     */
    version?: BasicBlockInfo;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    chain_id?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    height?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    time?: string;
    /**
     * 
     * @type {PrevBlockInfo}
     * @memberof TendermintTypesHeader
     */
    last_block_id?: PrevBlockInfo;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    last_commit_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    data_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    validators_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    next_validators_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    consensus_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    app_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    last_results_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    evidence_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    proposer_address?: string;
}
/**
 * 
 * @export
 * @interface TendermintTypesLightBlock
 */
export interface TendermintTypesLightBlock {
    /**
     * 
     * @type {InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader}
     * @memberof TendermintTypesLightBlock
     */
    signed_header?: InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader;
    /**
     * 
     * @type {InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet}
     * @memberof TendermintTypesLightBlock
     */
    validator_set?: InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet;
}
/**
 * LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.
 * @export
 * @interface TendermintTypesLightClientAttackEvidence
 */
export interface TendermintTypesLightClientAttackEvidence {
    /**
     * 
     * @type {InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlock}
     * @memberof TendermintTypesLightClientAttackEvidence
     */
    conflicting_block?: InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlock;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesLightClientAttackEvidence
     */
    common_height?: string;
    /**
     * 
     * @type {Array<InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidators>}
     * @memberof TendermintTypesLightClientAttackEvidence
     */
    byzantine_validators?: Array<InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidators>;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesLightClientAttackEvidence
     */
    total_voting_power?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesLightClientAttackEvidence
     */
    timestamp?: string;
}
/**
 * 
 * @export
 * @interface TendermintTypesPartSetHeader
 */
export interface TendermintTypesPartSetHeader {
    /**
     * 
     * @type {number}
     * @memberof TendermintTypesPartSetHeader
     */
    total?: number;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesPartSetHeader
     */
    hash?: string;
}
/**
 * 
 * @export
 * @interface TendermintTypesSignedHeader
 */
export interface TendermintTypesSignedHeader {
    /**
     * 
     * @type {InlineResponse20031BlockHeader}
     * @memberof TendermintTypesSignedHeader
     */
    header?: InlineResponse20031BlockHeader;
    /**
     * 
     * @type {InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit}
     * @memberof TendermintTypesSignedHeader
     */
    commit?: InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit;
}
/**
 * SignedMsgType is a type of signed message in the consensus.   - SIGNED_MSG_TYPE_PREVOTE: Votes  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
 * @export
 * @enum {string}
 */
export enum TendermintTypesSignedMsgType {
    Unknown = 'SIGNED_MSG_TYPE_UNKNOWN',
    Prevote = 'SIGNED_MSG_TYPE_PREVOTE',
    Precommit = 'SIGNED_MSG_TYPE_PRECOMMIT',
    Proposal = 'SIGNED_MSG_TYPE_PROPOSAL'
}

/**
 * 
 * @export
 * @interface TendermintTypesValidator
 */
export interface TendermintTypesValidator {
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesValidator
     */
    address?: string;
    /**
     * 
     * @type {PublicKeyDefinesTheKeysAvailableForUseWithTendermintValidators}
     * @memberof TendermintTypesValidator
     */
    pub_key?: PublicKeyDefinesTheKeysAvailableForUseWithTendermintValidators;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesValidator
     */
    voting_power?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesValidator
     */
    proposer_priority?: string;
}
/**
 * 
 * @export
 * @interface TendermintTypesValidatorSet
 */
export interface TendermintTypesValidatorSet {
    /**
     * 
     * @type {Array<InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidators>}
     * @memberof TendermintTypesValidatorSet
     */
    validators?: Array<InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidators>;
    /**
     * 
     * @type {InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidators}
     * @memberof TendermintTypesValidatorSet
     */
    proposer?: InlineResponse20031BlockEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidators;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesValidatorSet
     */
    total_voting_power?: string;
}
/**
 * Vote represents a prevote, precommit, or commit vote from validators for consensus.
 * @export
 * @interface TendermintTypesVote
 */
export interface TendermintTypesVote {
    /**
     * SignedMsgType is a type of signed message in the consensus.   - SIGNED_MSG_TYPE_PREVOTE: Votes  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
     * @type {string}
     * @memberof TendermintTypesVote
     */
    type?: TendermintTypesVoteTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesVote
     */
    height?: string;
    /**
     * 
     * @type {number}
     * @memberof TendermintTypesVote
     */
    round?: number;
    /**
     * 
     * @type {BlockID1}
     * @memberof TendermintTypesVote
     */
    block_id?: BlockID1;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesVote
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesVote
     */
    validator_address?: string;
    /**
     * 
     * @type {number}
     * @memberof TendermintTypesVote
     */
    validator_index?: number;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesVote
     */
    signature?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TendermintTypesVoteTypeEnum {
    Unknown = 'SIGNED_MSG_TYPE_UNKNOWN',
    Prevote = 'SIGNED_MSG_TYPE_PREVOTE',
    Precommit = 'SIGNED_MSG_TYPE_PRECOMMIT',
    Proposal = 'SIGNED_MSG_TYPE_PROPOSAL'
}

/**
 * 
 * @export
 * @interface TendermintValidator
 */
export interface TendermintValidator {
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof TendermintValidator
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintValidator
     */
    pub_key?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintValidator
     */
    voting_power?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintValidator
     */
    proposer_priority?: string;
}
/**
 * Consensus captures the consensus rules for processing a block in the blockchain, including all blockchain data structures and the rules of the application\'s state transition machine.
 * @export
 * @interface TendermintVersionConsensus
 */
export interface TendermintVersionConsensus {
    /**
     * 
     * @type {string}
     * @memberof TendermintVersionConsensus
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintVersionConsensus
     */
    app?: string;
}
/**
 * 
 * @export
 * @interface TextProposal
 */
export interface TextProposal {
    /**
     * 
     * @type {number}
     * @memberof TextProposal
     */
    proposal_id?: number;
    /**
     * 
     * @type {string}
     * @memberof TextProposal
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof TextProposal
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof TextProposal
     */
    proposal_type?: string;
    /**
     * 
     * @type {string}
     * @memberof TextProposal
     */
    proposal_status?: string;
    /**
     * 
     * @type {GovProposalsFinalTallyResult}
     * @memberof TextProposal
     */
    final_tally_result?: GovProposalsFinalTallyResult;
    /**
     * 
     * @type {string}
     * @memberof TextProposal
     */
    submit_time?: string;
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof TextProposal
     */
    total_deposit?: Array<InlineResponse2004TxFeeAmount>;
    /**
     * 
     * @type {string}
     * @memberof TextProposal
     */
    voting_start_time?: string;
}
/**
 * 
 * @export
 * @interface TxQuery
 */
export interface TxQuery {
    /**
     * 
     * @type {string}
     * @memberof TxQuery
     */
    hash?: string;
    /**
     * 
     * @type {number}
     * @memberof TxQuery
     */
    height?: number;
    /**
     * 
     * @type {InlineResponse2004Tx}
     * @memberof TxQuery
     */
    tx?: InlineResponse2004Tx;
    /**
     * 
     * @type {InlineResponse2004Result}
     * @memberof TxQuery
     */
    result?: InlineResponse2004Result;
}
/**
 * 
 * @export
 * @interface UnbondingDelegation
 */
export interface UnbondingDelegation {
    /**
     * 
     * @type {string}
     * @memberof UnbondingDelegation
     */
    delegator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof UnbondingDelegation
     */
    validator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof UnbondingDelegation
     */
    initial_balance?: string;
    /**
     * 
     * @type {string}
     * @memberof UnbondingDelegation
     */
    balance?: string;
    /**
     * 
     * @type {number}
     * @memberof UnbondingDelegation
     */
    creation_height?: number;
    /**
     * 
     * @type {number}
     * @memberof UnbondingDelegation
     */
    min_time?: number;
}
/**
 * 
 * @export
 * @interface UnbondingDelegationPair
 */
export interface UnbondingDelegationPair {
    /**
     * 
     * @type {string}
     * @memberof UnbondingDelegationPair
     */
    delegator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof UnbondingDelegationPair
     */
    validator_address?: string;
    /**
     * 
     * @type {Array<InlineResponse20011Entries>}
     * @memberof UnbondingDelegationPair
     */
    entries?: Array<InlineResponse20011Entries>;
}
/**
 * 
 * @export
 * @interface UnbondingEntries
 */
export interface UnbondingEntries {
    /**
     * 
     * @type {string}
     * @memberof UnbondingEntries
     */
    initial_balance?: string;
    /**
     * 
     * @type {string}
     * @memberof UnbondingEntries
     */
    balance?: string;
    /**
     * 
     * @type {string}
     * @memberof UnbondingEntries
     */
    creation_height?: string;
    /**
     * 
     * @type {string}
     * @memberof UnbondingEntries
     */
    min_time?: string;
}
/**
 * ValidatorSigningInfo defines a validator\'s signing info for monitoring their liveness activity.
 * @export
 * @interface ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress
 */
export interface ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress {
    /**
     * 
     * @type {string}
     * @memberof ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress
     */
    start_height?: string;
    /**
     * 
     * @type {string}
     * @memberof ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress
     */
    index_offset?: string;
    /**
     * 
     * @type {string}
     * @memberof ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress
     */
    jailed_until?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress
     */
    tombstoned?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress
     */
    missed_blocks_counter?: string;
}
/**
 * 
 * @export
 * @interface Validator
 */
export interface Validator {
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof Validator
     */
    operator_address?: string;
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    consensus_pubkey?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Validator
     */
    jailed?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Validator
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    tokens?: string;
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    delegator_shares?: string;
    /**
     * 
     * @type {StakingDelegatorsDelegatorAddrValidatorsDescription}
     * @memberof Validator
     */
    description?: StakingDelegatorsDelegatorAddrValidatorsDescription;
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    bond_height?: string;
    /**
     * 
     * @type {number}
     * @memberof Validator
     */
    bond_intra_tx_counter?: number;
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    unbonding_height?: string;
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    unbonding_time?: string;
    /**
     * 
     * @type {StakingDelegatorsDelegatorAddrValidatorsCommission}
     * @memberof Validator
     */
    commission?: StakingDelegatorsDelegatorAddrValidatorsCommission;
}
/**
 * 
 * @export
 * @interface ValidatorDistInfo
 */
export interface ValidatorDistInfo {
    /**
     * bech32 encoded address
     * @type {string}
     * @memberof ValidatorDistInfo
     */
    operator_address?: string;
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof ValidatorDistInfo
     */
    self_bond_rewards?: Array<InlineResponse2004TxFeeAmount>;
    /**
     * 
     * @type {Array<InlineResponse2004TxFeeAmount>}
     * @memberof ValidatorDistInfo
     */
    val_commission?: Array<InlineResponse2004TxFeeAmount>;
}
/**
 * 
 * @export
 * @interface Vote
 */
export interface Vote {
    /**
     * 
     * @type {string}
     * @memberof Vote
     */
    voter?: string;
    /**
     * 
     * @type {string}
     * @memberof Vote
     */
    proposal_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Vote
     */
    option?: string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the account information on blockchain
         * @param {string} address Account address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAccountsAddressGet: async (address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling authAccountsAddressGet.');
            }
            const localVarPath = `/auth/accounts/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the account information on blockchain
         * @param {string} address Account address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authAccountsAddressGet(address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authAccountsAddressGet(address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get the account information on blockchain
         * @param {string} address Account address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAccountsAddressGet(address: string, options?: any): AxiosPromise<InlineResponse2008> {
            return AuthApiFp(configuration).authAccountsAddressGet(address, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Get the account information on blockchain
     * @param {string} address Account address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authAccountsAddressGet(address: string, options?: any) {
        return AuthApiFp(this.configuration).authAccountsAddressGet(address, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BankApi - axios parameter creator
 * @export
 */
export const BankApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send coins from one account to another
         * @param {string} address Account address in bech32 format
         * @param {InlineObject3} account 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsAddressTransfersPost: async (address: string, account: InlineObject3, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling bankAccountsAddressTransfersPost.');
            }
            // verify required parameter 'account' is not null or undefined
            if (account === null || account === undefined) {
                throw new RequiredError('account','Required parameter account was null or undefined when calling bankAccountsAddressTransfersPost.');
            }
            const localVarPath = `/bank/accounts/{address}/transfers`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof account !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(account !== undefined ? account : {})
                : (account || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the account balances
         * @param {string} address Account address in bech32 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankBalancesAddressGet: async (address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling bankBalancesAddressGet.');
            }
            const localVarPath = `/bank/balances/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankApi - functional programming interface
 * @export
 */
export const BankApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send coins from one account to another
         * @param {string} address Account address in bech32 format
         * @param {InlineObject3} account 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankAccountsAddressTransfersPost(address: string, account: InlineObject3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004Tx>> {
            const localVarAxiosArgs = await BankApiAxiosParamCreator(configuration).bankAccountsAddressTransfersPost(address, account, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the account balances
         * @param {string} address Account address in bech32 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankBalancesAddressGet(address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2004TxFeeAmount>>> {
            const localVarAxiosArgs = await BankApiAxiosParamCreator(configuration).bankBalancesAddressGet(address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BankApi - factory interface
 * @export
 */
export const BankApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Send coins from one account to another
         * @param {string} address Account address in bech32 format
         * @param {InlineObject3} account 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsAddressTransfersPost(address: string, account: InlineObject3, options?: any): AxiosPromise<InlineResponse2004Tx> {
            return BankApiFp(configuration).bankAccountsAddressTransfersPost(address, account, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the account balances
         * @param {string} address Account address in bech32 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankBalancesAddressGet(address: string, options?: any): AxiosPromise<Array<InlineResponse2004TxFeeAmount>> {
            return BankApiFp(configuration).bankBalancesAddressGet(address, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankApi - object-oriented interface
 * @export
 * @class BankApi
 * @extends {BaseAPI}
 */
export class BankApi extends BaseAPI {
    /**
     * 
     * @summary Send coins from one account to another
     * @param {string} address Account address in bech32 format
     * @param {InlineObject3} account 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankApi
     */
    public bankAccountsAddressTransfersPost(address: string, account: InlineObject3, options?: any) {
        return BankApiFp(this.configuration).bankAccountsAddressTransfersPost(address, account, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the account balances
     * @param {string} address Account address in bech32 format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankApi
     */
    public bankBalancesAddressGet(address: string, options?: any) {
        return BankApiFp(this.configuration).bankBalancesAddressGet(address, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DistributionApi - axios parameter creator
 * @export
 */
export const DistributionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Community pool parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionCommunityPoolGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/distribution/community_pool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the sum of all the rewards earned by delegations by a single delegator
         * @summary Get the total rewards balance from all delegations
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsGet: async (delegatorAddr: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrRewardsGet.');
            }
            const localVarPath = `/distribution/delegators/{delegatorAddr}/rewards`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Withdraw all the delegator\'s delegation rewards
         * @summary Withdraw all the delegator\'s delegation rewards
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject12} [withdrawRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsPost: async (delegatorAddr: string, withdrawRequestBody?: InlineObject12, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrRewardsPost.');
            }
            const localVarPath = `/distribution/delegators/{delegatorAddr}/rewards`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof withdrawRequestBody !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(withdrawRequestBody !== undefined ? withdrawRequestBody : {})
                : (withdrawRequestBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Query a single delegation reward by a delegator
         * @summary Query a delegation reward
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet: async (delegatorAddr: string, validatorAddr: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet.');
            }
            // verify required parameter 'validatorAddr' is not null or undefined
            if (validatorAddr === null || validatorAddr === undefined) {
                throw new RequiredError('validatorAddr','Required parameter validatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet.');
            }
            const localVarPath = `/distribution/delegators/{delegatorAddr}/rewards/{validatorAddr}`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)))
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Withdraw a delegator\'s delegation reward from a single validator
         * @summary Withdraw a delegation reward
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {InlineObject13} [withdrawRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost: async (delegatorAddr: string, validatorAddr: string, withdrawRequestBody?: InlineObject13, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost.');
            }
            // verify required parameter 'validatorAddr' is not null or undefined
            if (validatorAddr === null || validatorAddr === undefined) {
                throw new RequiredError('validatorAddr','Required parameter validatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost.');
            }
            const localVarPath = `/distribution/delegators/{delegatorAddr}/rewards/{validatorAddr}`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)))
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof withdrawRequestBody !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(withdrawRequestBody !== undefined ? withdrawRequestBody : {})
                : (withdrawRequestBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the delegations\' rewards withdrawal address. This is the address in which the user will receive the reward funds
         * @summary Get the rewards withdrawal address
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrWithdrawAddressGet: async (delegatorAddr: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrWithdrawAddressGet.');
            }
            const localVarPath = `/distribution/delegators/{delegatorAddr}/withdraw_address`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace the delegations\' rewards withdrawal address for a new one.
         * @summary Replace the rewards withdrawal address
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject14} [withdrawRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrWithdrawAddressPost: async (delegatorAddr: string, withdrawRequestBody?: InlineObject14, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrWithdrawAddressPost.');
            }
            const localVarPath = `/distribution/delegators/{delegatorAddr}/withdraw_address`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof withdrawRequestBody !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(withdrawRequestBody !== undefined ? withdrawRequestBody : {})
                : (withdrawRequestBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fee distribution parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionParametersGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/distribution/parameters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Query the distribution information of a single validator
         * @summary Validator distribution information
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrGet: async (validatorAddr: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddr' is not null or undefined
            if (validatorAddr === null || validatorAddr === undefined) {
                throw new RequiredError('validatorAddr','Required parameter validatorAddr was null or undefined when calling distributionValidatorsValidatorAddrGet.');
            }
            const localVarPath = `/distribution/validators/{validatorAddr}`
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fee distribution outstanding rewards of a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrOutstandingRewardsGet: async (validatorAddr: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddr' is not null or undefined
            if (validatorAddr === null || validatorAddr === undefined) {
                throw new RequiredError('validatorAddr','Required parameter validatorAddr was null or undefined when calling distributionValidatorsValidatorAddrOutstandingRewardsGet.');
            }
            const localVarPath = `/distribution/validators/{validatorAddr}/outstanding_rewards`
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Query the commission and self-delegation rewards of validator.
         * @summary Commission and self-delegation rewards of a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrRewardsGet: async (validatorAddr: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddr' is not null or undefined
            if (validatorAddr === null || validatorAddr === undefined) {
                throw new RequiredError('validatorAddr','Required parameter validatorAddr was null or undefined when calling distributionValidatorsValidatorAddrRewardsGet.');
            }
            const localVarPath = `/distribution/validators/{validatorAddr}/rewards`
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Withdraw the validator\'s self-delegation and commissions rewards
         * @summary Withdraw the validator\'s rewards
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {InlineObject15} [withdrawRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrRewardsPost: async (validatorAddr: string, withdrawRequestBody?: InlineObject15, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddr' is not null or undefined
            if (validatorAddr === null || validatorAddr === undefined) {
                throw new RequiredError('validatorAddr','Required parameter validatorAddr was null or undefined when calling distributionValidatorsValidatorAddrRewardsPost.');
            }
            const localVarPath = `/distribution/validators/{validatorAddr}/rewards`
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof withdrawRequestBody !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(withdrawRequestBody !== undefined ? withdrawRequestBody : {})
                : (withdrawRequestBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DistributionApi - functional programming interface
 * @export
 */
export const DistributionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Community pool parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async distributionCommunityPoolGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2004TxFeeAmount>>> {
            const localVarAxiosArgs = await DistributionApiAxiosParamCreator(configuration).distributionCommunityPoolGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the sum of all the rewards earned by delegations by a single delegator
         * @summary Get the total rewards balance from all delegations
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async distributionDelegatorsDelegatorAddrRewardsGet(delegatorAddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await DistributionApiAxiosParamCreator(configuration).distributionDelegatorsDelegatorAddrRewardsGet(delegatorAddr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Withdraw all the delegator\'s delegation rewards
         * @summary Withdraw all the delegator\'s delegation rewards
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject12} [withdrawRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async distributionDelegatorsDelegatorAddrRewardsPost(delegatorAddr: string, withdrawRequestBody?: InlineObject12, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004Tx>> {
            const localVarAxiosArgs = await DistributionApiAxiosParamCreator(configuration).distributionDelegatorsDelegatorAddrRewardsPost(delegatorAddr, withdrawRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Query a single delegation reward by a delegator
         * @summary Query a delegation reward
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(delegatorAddr: string, validatorAddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2004TxFeeAmount>>> {
            const localVarAxiosArgs = await DistributionApiAxiosParamCreator(configuration).distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(delegatorAddr, validatorAddr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Withdraw a delegator\'s delegation reward from a single validator
         * @summary Withdraw a delegation reward
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {InlineObject13} [withdrawRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(delegatorAddr: string, validatorAddr: string, withdrawRequestBody?: InlineObject13, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004Tx>> {
            const localVarAxiosArgs = await DistributionApiAxiosParamCreator(configuration).distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(delegatorAddr, validatorAddr, withdrawRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the delegations\' rewards withdrawal address. This is the address in which the user will receive the reward funds
         * @summary Get the rewards withdrawal address
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async distributionDelegatorsDelegatorAddrWithdrawAddressGet(delegatorAddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await DistributionApiAxiosParamCreator(configuration).distributionDelegatorsDelegatorAddrWithdrawAddressGet(delegatorAddr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace the delegations\' rewards withdrawal address for a new one.
         * @summary Replace the rewards withdrawal address
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject14} [withdrawRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async distributionDelegatorsDelegatorAddrWithdrawAddressPost(delegatorAddr: string, withdrawRequestBody?: InlineObject14, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004Tx>> {
            const localVarAxiosArgs = await DistributionApiAxiosParamCreator(configuration).distributionDelegatorsDelegatorAddrWithdrawAddressPost(delegatorAddr, withdrawRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Fee distribution parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async distributionParametersGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DistributionApiAxiosParamCreator(configuration).distributionParametersGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Query the distribution information of a single validator
         * @summary Validator distribution information
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async distributionValidatorsValidatorAddrGet(validatorAddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20023>> {
            const localVarAxiosArgs = await DistributionApiAxiosParamCreator(configuration).distributionValidatorsValidatorAddrGet(validatorAddr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Fee distribution outstanding rewards of a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async distributionValidatorsValidatorAddrOutstandingRewardsGet(validatorAddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2004TxFeeAmount>>> {
            const localVarAxiosArgs = await DistributionApiAxiosParamCreator(configuration).distributionValidatorsValidatorAddrOutstandingRewardsGet(validatorAddr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Query the commission and self-delegation rewards of validator.
         * @summary Commission and self-delegation rewards of a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async distributionValidatorsValidatorAddrRewardsGet(validatorAddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2004TxFeeAmount>>> {
            const localVarAxiosArgs = await DistributionApiAxiosParamCreator(configuration).distributionValidatorsValidatorAddrRewardsGet(validatorAddr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Withdraw the validator\'s self-delegation and commissions rewards
         * @summary Withdraw the validator\'s rewards
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {InlineObject15} [withdrawRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async distributionValidatorsValidatorAddrRewardsPost(validatorAddr: string, withdrawRequestBody?: InlineObject15, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004Tx>> {
            const localVarAxiosArgs = await DistributionApiAxiosParamCreator(configuration).distributionValidatorsValidatorAddrRewardsPost(validatorAddr, withdrawRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DistributionApi - factory interface
 * @export
 */
export const DistributionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Community pool parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionCommunityPoolGet(options?: any): AxiosPromise<Array<InlineResponse2004TxFeeAmount>> {
            return DistributionApiFp(configuration).distributionCommunityPoolGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the sum of all the rewards earned by delegations by a single delegator
         * @summary Get the total rewards balance from all delegations
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsGet(delegatorAddr: string, options?: any): AxiosPromise<InlineResponse20022> {
            return DistributionApiFp(configuration).distributionDelegatorsDelegatorAddrRewardsGet(delegatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * Withdraw all the delegator\'s delegation rewards
         * @summary Withdraw all the delegator\'s delegation rewards
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject12} [withdrawRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsPost(delegatorAddr: string, withdrawRequestBody?: InlineObject12, options?: any): AxiosPromise<InlineResponse2004Tx> {
            return DistributionApiFp(configuration).distributionDelegatorsDelegatorAddrRewardsPost(delegatorAddr, withdrawRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Query a single delegation reward by a delegator
         * @summary Query a delegation reward
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(delegatorAddr: string, validatorAddr: string, options?: any): AxiosPromise<Array<InlineResponse2004TxFeeAmount>> {
            return DistributionApiFp(configuration).distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(delegatorAddr, validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * Withdraw a delegator\'s delegation reward from a single validator
         * @summary Withdraw a delegation reward
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {InlineObject13} [withdrawRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(delegatorAddr: string, validatorAddr: string, withdrawRequestBody?: InlineObject13, options?: any): AxiosPromise<InlineResponse2004Tx> {
            return DistributionApiFp(configuration).distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(delegatorAddr, validatorAddr, withdrawRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the delegations\' rewards withdrawal address. This is the address in which the user will receive the reward funds
         * @summary Get the rewards withdrawal address
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrWithdrawAddressGet(delegatorAddr: string, options?: any): AxiosPromise<string> {
            return DistributionApiFp(configuration).distributionDelegatorsDelegatorAddrWithdrawAddressGet(delegatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace the delegations\' rewards withdrawal address for a new one.
         * @summary Replace the rewards withdrawal address
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject14} [withdrawRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrWithdrawAddressPost(delegatorAddr: string, withdrawRequestBody?: InlineObject14, options?: any): AxiosPromise<InlineResponse2004Tx> {
            return DistributionApiFp(configuration).distributionDelegatorsDelegatorAddrWithdrawAddressPost(delegatorAddr, withdrawRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fee distribution parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionParametersGet(options?: any): AxiosPromise<object> {
            return DistributionApiFp(configuration).distributionParametersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Query the distribution information of a single validator
         * @summary Validator distribution information
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrGet(validatorAddr: string, options?: any): AxiosPromise<InlineResponse20023> {
            return DistributionApiFp(configuration).distributionValidatorsValidatorAddrGet(validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fee distribution outstanding rewards of a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrOutstandingRewardsGet(validatorAddr: string, options?: any): AxiosPromise<Array<InlineResponse2004TxFeeAmount>> {
            return DistributionApiFp(configuration).distributionValidatorsValidatorAddrOutstandingRewardsGet(validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * Query the commission and self-delegation rewards of validator.
         * @summary Commission and self-delegation rewards of a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrRewardsGet(validatorAddr: string, options?: any): AxiosPromise<Array<InlineResponse2004TxFeeAmount>> {
            return DistributionApiFp(configuration).distributionValidatorsValidatorAddrRewardsGet(validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * Withdraw the validator\'s self-delegation and commissions rewards
         * @summary Withdraw the validator\'s rewards
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {InlineObject15} [withdrawRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrRewardsPost(validatorAddr: string, withdrawRequestBody?: InlineObject15, options?: any): AxiosPromise<InlineResponse2004Tx> {
            return DistributionApiFp(configuration).distributionValidatorsValidatorAddrRewardsPost(validatorAddr, withdrawRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DistributionApi - object-oriented interface
 * @export
 * @class DistributionApi
 * @extends {BaseAPI}
 */
export class DistributionApi extends BaseAPI {
    /**
     * 
     * @summary Community pool parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    public distributionCommunityPoolGet(options?: any) {
        return DistributionApiFp(this.configuration).distributionCommunityPoolGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the sum of all the rewards earned by delegations by a single delegator
     * @summary Get the total rewards balance from all delegations
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    public distributionDelegatorsDelegatorAddrRewardsGet(delegatorAddr: string, options?: any) {
        return DistributionApiFp(this.configuration).distributionDelegatorsDelegatorAddrRewardsGet(delegatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Withdraw all the delegator\'s delegation rewards
     * @summary Withdraw all the delegator\'s delegation rewards
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {InlineObject12} [withdrawRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    public distributionDelegatorsDelegatorAddrRewardsPost(delegatorAddr: string, withdrawRequestBody?: InlineObject12, options?: any) {
        return DistributionApiFp(this.configuration).distributionDelegatorsDelegatorAddrRewardsPost(delegatorAddr, withdrawRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query a single delegation reward by a delegator
     * @summary Query a delegation reward
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    public distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(delegatorAddr: string, validatorAddr: string, options?: any) {
        return DistributionApiFp(this.configuration).distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(delegatorAddr, validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Withdraw a delegator\'s delegation reward from a single validator
     * @summary Withdraw a delegation reward
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {InlineObject13} [withdrawRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    public distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(delegatorAddr: string, validatorAddr: string, withdrawRequestBody?: InlineObject13, options?: any) {
        return DistributionApiFp(this.configuration).distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(delegatorAddr, validatorAddr, withdrawRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the delegations\' rewards withdrawal address. This is the address in which the user will receive the reward funds
     * @summary Get the rewards withdrawal address
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    public distributionDelegatorsDelegatorAddrWithdrawAddressGet(delegatorAddr: string, options?: any) {
        return DistributionApiFp(this.configuration).distributionDelegatorsDelegatorAddrWithdrawAddressGet(delegatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace the delegations\' rewards withdrawal address for a new one.
     * @summary Replace the rewards withdrawal address
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {InlineObject14} [withdrawRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    public distributionDelegatorsDelegatorAddrWithdrawAddressPost(delegatorAddr: string, withdrawRequestBody?: InlineObject14, options?: any) {
        return DistributionApiFp(this.configuration).distributionDelegatorsDelegatorAddrWithdrawAddressPost(delegatorAddr, withdrawRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fee distribution parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    public distributionParametersGet(options?: any) {
        return DistributionApiFp(this.configuration).distributionParametersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query the distribution information of a single validator
     * @summary Validator distribution information
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    public distributionValidatorsValidatorAddrGet(validatorAddr: string, options?: any) {
        return DistributionApiFp(this.configuration).distributionValidatorsValidatorAddrGet(validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fee distribution outstanding rewards of a single validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    public distributionValidatorsValidatorAddrOutstandingRewardsGet(validatorAddr: string, options?: any) {
        return DistributionApiFp(this.configuration).distributionValidatorsValidatorAddrOutstandingRewardsGet(validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query the commission and self-delegation rewards of validator.
     * @summary Commission and self-delegation rewards of a single validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    public distributionValidatorsValidatorAddrRewardsGet(validatorAddr: string, options?: any) {
        return DistributionApiFp(this.configuration).distributionValidatorsValidatorAddrRewardsGet(validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Withdraw the validator\'s self-delegation and commissions rewards
     * @summary Withdraw the validator\'s rewards
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {InlineObject15} [withdrawRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    public distributionValidatorsValidatorAddrRewardsPost(validatorAddr: string, withdrawRequestBody?: InlineObject15, options?: any) {
        return DistributionApiFp(this.configuration).distributionValidatorsValidatorAddrRewardsPost(validatorAddr, withdrawRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GaiaRESTApi - axios parameter creator
 * @export
 */
export const GaiaRESTApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Information about the connected node
         * @summary The properties of the connected node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodeInfoGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/node_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GaiaRESTApi - functional programming interface
 * @export
 */
export const GaiaRESTApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Information about the connected node
         * @summary The properties of the connected node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nodeInfoGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await GaiaRESTApiAxiosParamCreator(configuration).nodeInfoGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GaiaRESTApi - factory interface
 * @export
 */
export const GaiaRESTApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Information about the connected node
         * @summary The properties of the connected node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodeInfoGet(options?: any): AxiosPromise<InlineResponse200> {
            return GaiaRESTApiFp(configuration).nodeInfoGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GaiaRESTApi - object-oriented interface
 * @export
 * @class GaiaRESTApi
 * @extends {BaseAPI}
 */
export class GaiaRESTApi extends BaseAPI {
    /**
     * Information about the connected node
     * @summary The properties of the connected node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GaiaRESTApi
     */
    public nodeInfoGet(options?: any) {
        return GaiaRESTApiFp(this.configuration).nodeInfoGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GovernanceApi - axios parameter creator
 * @export
 */
export const GovernanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Query governance deposit parameters. The max_deposit_period units are in nanoseconds.
         * @summary Query governance deposit parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParametersDepositGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/gov/parameters/deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Query governance tally parameters
         * @summary Query governance tally parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParametersTallyingGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/gov/parameters/tallying`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Query governance voting parameters. The voting_period units are in nanoseconds.
         * @summary Query governance voting parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParametersVotingGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/gov/parameters/voting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Query proposals information with parameters
         * @summary Query proposals
         * @param {string} [voter] voter address
         * @param {string} [depositor] depositor address
         * @param {string} [status] proposal status, valid values can be &#x60;\&quot;deposit_period\&quot;&#x60;, &#x60;\&quot;voting_period\&quot;&#x60;, &#x60;\&quot;passed\&quot;&#x60;, &#x60;\&quot;rejected\&quot;&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsGet: async (voter?: string, depositor?: string, status?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/gov/proposals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (voter !== undefined) {
                localVarQueryParameter['voter'] = voter;
            }

            if (depositor !== undefined) {
                localVarQueryParameter['depositor'] = depositor;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a parameter change proposal transaction
         * @summary Generate a parameter change proposal transaction
         * @param {InlineObject9} postProposalBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsParamChangePost: async (postProposalBody: InlineObject9, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'postProposalBody' is not null or undefined
            if (postProposalBody === null || postProposalBody === undefined) {
                throw new RequiredError('postProposalBody','Required parameter postProposalBody was null or undefined when calling govProposalsParamChangePost.');
            }
            const localVarPath = `/gov/proposals/param_change`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof postProposalBody !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(postProposalBody !== undefined ? postProposalBody : {})
                : (postProposalBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Send transaction to submit a proposal
         * @summary Submit a proposal
         * @param {InlineObject8} postProposalBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsPost: async (postProposalBody: InlineObject8, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'postProposalBody' is not null or undefined
            if (postProposalBody === null || postProposalBody === undefined) {
                throw new RequiredError('postProposalBody','Required parameter postProposalBody was null or undefined when calling govProposalsPost.');
            }
            const localVarPath = `/gov/proposals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof postProposalBody !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(postProposalBody !== undefined ? postProposalBody : {})
                : (postProposalBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Query deposit by proposalId and depositor address
         * @summary Query deposit
         * @param {string} proposalId proposal id
         * @param {string} depositor Bech32 depositor address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsDepositorGet: async (proposalId: string, depositor: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            if (proposalId === null || proposalId === undefined) {
                throw new RequiredError('proposalId','Required parameter proposalId was null or undefined when calling govProposalsProposalIdDepositsDepositorGet.');
            }
            // verify required parameter 'depositor' is not null or undefined
            if (depositor === null || depositor === undefined) {
                throw new RequiredError('depositor','Required parameter depositor was null or undefined when calling govProposalsProposalIdDepositsDepositorGet.');
            }
            const localVarPath = `/gov/proposals/{proposalId}/deposits/{depositor}`
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)))
                .replace(`{${"depositor"}}`, encodeURIComponent(String(depositor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Query deposits by proposalId
         * @summary Query deposits
         * @param {string} proposalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsGet: async (proposalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            if (proposalId === null || proposalId === undefined) {
                throw new RequiredError('proposalId','Required parameter proposalId was null or undefined when calling govProposalsProposalIdDepositsGet.');
            }
            const localVarPath = `/gov/proposals/{proposalId}/deposits`
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Send transaction to deposit tokens to a proposal
         * @summary Deposit tokens to a proposal
         * @param {string} proposalId proposal id
         * @param {InlineObject10} postDepositBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsPost: async (proposalId: string, postDepositBody: InlineObject10, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            if (proposalId === null || proposalId === undefined) {
                throw new RequiredError('proposalId','Required parameter proposalId was null or undefined when calling govProposalsProposalIdDepositsPost.');
            }
            // verify required parameter 'postDepositBody' is not null or undefined
            if (postDepositBody === null || postDepositBody === undefined) {
                throw new RequiredError('postDepositBody','Required parameter postDepositBody was null or undefined when calling govProposalsProposalIdDepositsPost.');
            }
            const localVarPath = `/gov/proposals/{proposalId}/deposits`
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof postDepositBody !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(postDepositBody !== undefined ? postDepositBody : {})
                : (postDepositBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Query a proposal by id
         * @summary Query a proposal
         * @param {string} proposalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdGet: async (proposalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            if (proposalId === null || proposalId === undefined) {
                throw new RequiredError('proposalId','Required parameter proposalId was null or undefined when calling govProposalsProposalIdGet.');
            }
            const localVarPath = `/gov/proposals/{proposalId}`
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Query for the proposer for a proposal
         * @summary Query proposer
         * @param {string} proposalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdProposerGet: async (proposalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            if (proposalId === null || proposalId === undefined) {
                throw new RequiredError('proposalId','Required parameter proposalId was null or undefined when calling govProposalsProposalIdProposerGet.');
            }
            const localVarPath = `/gov/proposals/{proposalId}/proposer`
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a proposal\'s tally result at the current time. If the proposal is pending deposits (i.e status \'DepositPeriod\') it returns an empty tally result.
         * @summary Get a proposal\'s tally result at the current time
         * @param {string} proposalId proposal id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdTallyGet: async (proposalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            if (proposalId === null || proposalId === undefined) {
                throw new RequiredError('proposalId','Required parameter proposalId was null or undefined when calling govProposalsProposalIdTallyGet.');
            }
            const localVarPath = `/gov/proposals/{proposalId}/tally`
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Query voters information by proposalId
         * @summary Query voters
         * @param {string} proposalId proposal id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesGet: async (proposalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            if (proposalId === null || proposalId === undefined) {
                throw new RequiredError('proposalId','Required parameter proposalId was null or undefined when calling govProposalsProposalIdVotesGet.');
            }
            const localVarPath = `/gov/proposals/{proposalId}/votes`
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Send transaction to vote a proposal
         * @summary Vote a proposal
         * @param {string} proposalId proposal id
         * @param {InlineObject11} postVoteBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesPost: async (proposalId: string, postVoteBody: InlineObject11, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            if (proposalId === null || proposalId === undefined) {
                throw new RequiredError('proposalId','Required parameter proposalId was null or undefined when calling govProposalsProposalIdVotesPost.');
            }
            // verify required parameter 'postVoteBody' is not null or undefined
            if (postVoteBody === null || postVoteBody === undefined) {
                throw new RequiredError('postVoteBody','Required parameter postVoteBody was null or undefined when calling govProposalsProposalIdVotesPost.');
            }
            const localVarPath = `/gov/proposals/{proposalId}/votes`
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof postVoteBody !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(postVoteBody !== undefined ? postVoteBody : {})
                : (postVoteBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Query vote information by proposal Id and voter address
         * @summary Query vote
         * @param {string} proposalId proposal id
         * @param {string} voter Bech32 voter address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesVoterGet: async (proposalId: string, voter: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            if (proposalId === null || proposalId === undefined) {
                throw new RequiredError('proposalId','Required parameter proposalId was null or undefined when calling govProposalsProposalIdVotesVoterGet.');
            }
            // verify required parameter 'voter' is not null or undefined
            if (voter === null || voter === undefined) {
                throw new RequiredError('voter','Required parameter voter was null or undefined when calling govProposalsProposalIdVotesVoterGet.');
            }
            const localVarPath = `/gov/proposals/{proposalId}/votes/{voter}`
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)))
                .replace(`{${"voter"}}`, encodeURIComponent(String(voter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GovernanceApi - functional programming interface
 * @export
 */
export const GovernanceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Query governance deposit parameters. The max_deposit_period units are in nanoseconds.
         * @summary Query governance deposit parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govParametersDepositGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20021>> {
            const localVarAxiosArgs = await GovernanceApiAxiosParamCreator(configuration).govParametersDepositGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Query governance tally parameters
         * @summary Query governance tally parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govParametersTallyingGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await GovernanceApiAxiosParamCreator(configuration).govParametersTallyingGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Query governance voting parameters. The voting_period units are in nanoseconds.
         * @summary Query governance voting parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govParametersVotingGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await GovernanceApiAxiosParamCreator(configuration).govParametersVotingGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Query proposals information with parameters
         * @summary Query proposals
         * @param {string} [voter] voter address
         * @param {string} [depositor] depositor address
         * @param {string} [status] proposal status, valid values can be &#x60;\&quot;deposit_period\&quot;&#x60;, &#x60;\&quot;voting_period\&quot;&#x60;, &#x60;\&quot;passed\&quot;&#x60;, &#x60;\&quot;rejected\&quot;&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govProposalsGet(voter?: string, depositor?: string, status?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20017>>> {
            const localVarAxiosArgs = await GovernanceApiAxiosParamCreator(configuration).govProposalsGet(voter, depositor, status, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Generate a parameter change proposal transaction
         * @summary Generate a parameter change proposal transaction
         * @param {InlineObject9} postProposalBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govProposalsParamChangePost(postProposalBody: InlineObject9, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004Tx>> {
            const localVarAxiosArgs = await GovernanceApiAxiosParamCreator(configuration).govProposalsParamChangePost(postProposalBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Send transaction to submit a proposal
         * @summary Submit a proposal
         * @param {InlineObject8} postProposalBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govProposalsPost(postProposalBody: InlineObject8, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004Tx>> {
            const localVarAxiosArgs = await GovernanceApiAxiosParamCreator(configuration).govProposalsPost(postProposalBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Query deposit by proposalId and depositor address
         * @summary Query deposit
         * @param {string} proposalId proposal id
         * @param {string} depositor Bech32 depositor address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govProposalsProposalIdDepositsDepositorGet(proposalId: string, depositor: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20019>> {
            const localVarAxiosArgs = await GovernanceApiAxiosParamCreator(configuration).govProposalsProposalIdDepositsDepositorGet(proposalId, depositor, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Query deposits by proposalId
         * @summary Query deposits
         * @param {string} proposalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govProposalsProposalIdDepositsGet(proposalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20019>>> {
            const localVarAxiosArgs = await GovernanceApiAxiosParamCreator(configuration).govProposalsProposalIdDepositsGet(proposalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Send transaction to deposit tokens to a proposal
         * @summary Deposit tokens to a proposal
         * @param {string} proposalId proposal id
         * @param {InlineObject10} postDepositBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govProposalsProposalIdDepositsPost(proposalId: string, postDepositBody: InlineObject10, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004Tx>> {
            const localVarAxiosArgs = await GovernanceApiAxiosParamCreator(configuration).govProposalsProposalIdDepositsPost(proposalId, postDepositBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Query a proposal by id
         * @summary Query a proposal
         * @param {string} proposalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govProposalsProposalIdGet(proposalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20017>> {
            const localVarAxiosArgs = await GovernanceApiAxiosParamCreator(configuration).govProposalsProposalIdGet(proposalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Query for the proposer for a proposal
         * @summary Query proposer
         * @param {string} proposalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govProposalsProposalIdProposerGet(proposalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20018>> {
            const localVarAxiosArgs = await GovernanceApiAxiosParamCreator(configuration).govProposalsProposalIdProposerGet(proposalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a proposal\'s tally result at the current time. If the proposal is pending deposits (i.e status \'DepositPeriod\') it returns an empty tally result.
         * @summary Get a proposal\'s tally result at the current time
         * @param {string} proposalId proposal id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govProposalsProposalIdTallyGet(proposalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GovProposalsFinalTallyResult>> {
            const localVarAxiosArgs = await GovernanceApiAxiosParamCreator(configuration).govProposalsProposalIdTallyGet(proposalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Query voters information by proposalId
         * @summary Query voters
         * @param {string} proposalId proposal id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govProposalsProposalIdVotesGet(proposalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20020>>> {
            const localVarAxiosArgs = await GovernanceApiAxiosParamCreator(configuration).govProposalsProposalIdVotesGet(proposalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Send transaction to vote a proposal
         * @summary Vote a proposal
         * @param {string} proposalId proposal id
         * @param {InlineObject11} postVoteBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govProposalsProposalIdVotesPost(proposalId: string, postVoteBody: InlineObject11, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004Tx>> {
            const localVarAxiosArgs = await GovernanceApiAxiosParamCreator(configuration).govProposalsProposalIdVotesPost(proposalId, postVoteBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Query vote information by proposal Id and voter address
         * @summary Query vote
         * @param {string} proposalId proposal id
         * @param {string} voter Bech32 voter address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govProposalsProposalIdVotesVoterGet(proposalId: string, voter: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20020>> {
            const localVarAxiosArgs = await GovernanceApiAxiosParamCreator(configuration).govProposalsProposalIdVotesVoterGet(proposalId, voter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GovernanceApi - factory interface
 * @export
 */
export const GovernanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Query governance deposit parameters. The max_deposit_period units are in nanoseconds.
         * @summary Query governance deposit parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParametersDepositGet(options?: any): AxiosPromise<InlineResponse20021> {
            return GovernanceApiFp(configuration).govParametersDepositGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Query governance tally parameters
         * @summary Query governance tally parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParametersTallyingGet(options?: any): AxiosPromise<object> {
            return GovernanceApiFp(configuration).govParametersTallyingGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Query governance voting parameters. The voting_period units are in nanoseconds.
         * @summary Query governance voting parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParametersVotingGet(options?: any): AxiosPromise<object> {
            return GovernanceApiFp(configuration).govParametersVotingGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Query proposals information with parameters
         * @summary Query proposals
         * @param {string} [voter] voter address
         * @param {string} [depositor] depositor address
         * @param {string} [status] proposal status, valid values can be &#x60;\&quot;deposit_period\&quot;&#x60;, &#x60;\&quot;voting_period\&quot;&#x60;, &#x60;\&quot;passed\&quot;&#x60;, &#x60;\&quot;rejected\&quot;&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsGet(voter?: string, depositor?: string, status?: string, options?: any): AxiosPromise<Array<InlineResponse20017>> {
            return GovernanceApiFp(configuration).govProposalsGet(voter, depositor, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a parameter change proposal transaction
         * @summary Generate a parameter change proposal transaction
         * @param {InlineObject9} postProposalBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsParamChangePost(postProposalBody: InlineObject9, options?: any): AxiosPromise<InlineResponse2004Tx> {
            return GovernanceApiFp(configuration).govProposalsParamChangePost(postProposalBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Send transaction to submit a proposal
         * @summary Submit a proposal
         * @param {InlineObject8} postProposalBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsPost(postProposalBody: InlineObject8, options?: any): AxiosPromise<InlineResponse2004Tx> {
            return GovernanceApiFp(configuration).govProposalsPost(postProposalBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Query deposit by proposalId and depositor address
         * @summary Query deposit
         * @param {string} proposalId proposal id
         * @param {string} depositor Bech32 depositor address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsDepositorGet(proposalId: string, depositor: string, options?: any): AxiosPromise<InlineResponse20019> {
            return GovernanceApiFp(configuration).govProposalsProposalIdDepositsDepositorGet(proposalId, depositor, options).then((request) => request(axios, basePath));
        },
        /**
         * Query deposits by proposalId
         * @summary Query deposits
         * @param {string} proposalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsGet(proposalId: string, options?: any): AxiosPromise<Array<InlineResponse20019>> {
            return GovernanceApiFp(configuration).govProposalsProposalIdDepositsGet(proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Send transaction to deposit tokens to a proposal
         * @summary Deposit tokens to a proposal
         * @param {string} proposalId proposal id
         * @param {InlineObject10} postDepositBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsPost(proposalId: string, postDepositBody: InlineObject10, options?: any): AxiosPromise<InlineResponse2004Tx> {
            return GovernanceApiFp(configuration).govProposalsProposalIdDepositsPost(proposalId, postDepositBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Query a proposal by id
         * @summary Query a proposal
         * @param {string} proposalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdGet(proposalId: string, options?: any): AxiosPromise<InlineResponse20017> {
            return GovernanceApiFp(configuration).govProposalsProposalIdGet(proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Query for the proposer for a proposal
         * @summary Query proposer
         * @param {string} proposalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdProposerGet(proposalId: string, options?: any): AxiosPromise<InlineResponse20018> {
            return GovernanceApiFp(configuration).govProposalsProposalIdProposerGet(proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a proposal\'s tally result at the current time. If the proposal is pending deposits (i.e status \'DepositPeriod\') it returns an empty tally result.
         * @summary Get a proposal\'s tally result at the current time
         * @param {string} proposalId proposal id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdTallyGet(proposalId: string, options?: any): AxiosPromise<GovProposalsFinalTallyResult> {
            return GovernanceApiFp(configuration).govProposalsProposalIdTallyGet(proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Query voters information by proposalId
         * @summary Query voters
         * @param {string} proposalId proposal id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesGet(proposalId: string, options?: any): AxiosPromise<Array<InlineResponse20020>> {
            return GovernanceApiFp(configuration).govProposalsProposalIdVotesGet(proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Send transaction to vote a proposal
         * @summary Vote a proposal
         * @param {string} proposalId proposal id
         * @param {InlineObject11} postVoteBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesPost(proposalId: string, postVoteBody: InlineObject11, options?: any): AxiosPromise<InlineResponse2004Tx> {
            return GovernanceApiFp(configuration).govProposalsProposalIdVotesPost(proposalId, postVoteBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Query vote information by proposal Id and voter address
         * @summary Query vote
         * @param {string} proposalId proposal id
         * @param {string} voter Bech32 voter address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesVoterGet(proposalId: string, voter: string, options?: any): AxiosPromise<InlineResponse20020> {
            return GovernanceApiFp(configuration).govProposalsProposalIdVotesVoterGet(proposalId, voter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GovernanceApi - object-oriented interface
 * @export
 * @class GovernanceApi
 * @extends {BaseAPI}
 */
export class GovernanceApi extends BaseAPI {
    /**
     * Query governance deposit parameters. The max_deposit_period units are in nanoseconds.
     * @summary Query governance deposit parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    public govParametersDepositGet(options?: any) {
        return GovernanceApiFp(this.configuration).govParametersDepositGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query governance tally parameters
     * @summary Query governance tally parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    public govParametersTallyingGet(options?: any) {
        return GovernanceApiFp(this.configuration).govParametersTallyingGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query governance voting parameters. The voting_period units are in nanoseconds.
     * @summary Query governance voting parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    public govParametersVotingGet(options?: any) {
        return GovernanceApiFp(this.configuration).govParametersVotingGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query proposals information with parameters
     * @summary Query proposals
     * @param {string} [voter] voter address
     * @param {string} [depositor] depositor address
     * @param {string} [status] proposal status, valid values can be &#x60;\&quot;deposit_period\&quot;&#x60;, &#x60;\&quot;voting_period\&quot;&#x60;, &#x60;\&quot;passed\&quot;&#x60;, &#x60;\&quot;rejected\&quot;&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    public govProposalsGet(voter?: string, depositor?: string, status?: string, options?: any) {
        return GovernanceApiFp(this.configuration).govProposalsGet(voter, depositor, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a parameter change proposal transaction
     * @summary Generate a parameter change proposal transaction
     * @param {InlineObject9} postProposalBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    public govProposalsParamChangePost(postProposalBody: InlineObject9, options?: any) {
        return GovernanceApiFp(this.configuration).govProposalsParamChangePost(postProposalBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send transaction to submit a proposal
     * @summary Submit a proposal
     * @param {InlineObject8} postProposalBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    public govProposalsPost(postProposalBody: InlineObject8, options?: any) {
        return GovernanceApiFp(this.configuration).govProposalsPost(postProposalBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query deposit by proposalId and depositor address
     * @summary Query deposit
     * @param {string} proposalId proposal id
     * @param {string} depositor Bech32 depositor address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    public govProposalsProposalIdDepositsDepositorGet(proposalId: string, depositor: string, options?: any) {
        return GovernanceApiFp(this.configuration).govProposalsProposalIdDepositsDepositorGet(proposalId, depositor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query deposits by proposalId
     * @summary Query deposits
     * @param {string} proposalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    public govProposalsProposalIdDepositsGet(proposalId: string, options?: any) {
        return GovernanceApiFp(this.configuration).govProposalsProposalIdDepositsGet(proposalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send transaction to deposit tokens to a proposal
     * @summary Deposit tokens to a proposal
     * @param {string} proposalId proposal id
     * @param {InlineObject10} postDepositBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    public govProposalsProposalIdDepositsPost(proposalId: string, postDepositBody: InlineObject10, options?: any) {
        return GovernanceApiFp(this.configuration).govProposalsProposalIdDepositsPost(proposalId, postDepositBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query a proposal by id
     * @summary Query a proposal
     * @param {string} proposalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    public govProposalsProposalIdGet(proposalId: string, options?: any) {
        return GovernanceApiFp(this.configuration).govProposalsProposalIdGet(proposalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query for the proposer for a proposal
     * @summary Query proposer
     * @param {string} proposalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    public govProposalsProposalIdProposerGet(proposalId: string, options?: any) {
        return GovernanceApiFp(this.configuration).govProposalsProposalIdProposerGet(proposalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a proposal\'s tally result at the current time. If the proposal is pending deposits (i.e status \'DepositPeriod\') it returns an empty tally result.
     * @summary Get a proposal\'s tally result at the current time
     * @param {string} proposalId proposal id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    public govProposalsProposalIdTallyGet(proposalId: string, options?: any) {
        return GovernanceApiFp(this.configuration).govProposalsProposalIdTallyGet(proposalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query voters information by proposalId
     * @summary Query voters
     * @param {string} proposalId proposal id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    public govProposalsProposalIdVotesGet(proposalId: string, options?: any) {
        return GovernanceApiFp(this.configuration).govProposalsProposalIdVotesGet(proposalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send transaction to vote a proposal
     * @summary Vote a proposal
     * @param {string} proposalId proposal id
     * @param {InlineObject11} postVoteBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    public govProposalsProposalIdVotesPost(proposalId: string, postVoteBody: InlineObject11, options?: any) {
        return GovernanceApiFp(this.configuration).govProposalsProposalIdVotesPost(proposalId, postVoteBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query vote information by proposal Id and voter address
     * @summary Query vote
     * @param {string} proposalId proposal id
     * @param {string} voter Bech32 voter address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    public govProposalsProposalIdVotesVoterGet(proposalId: string, voter: string, options?: any) {
        return GovernanceApiFp(this.configuration).govProposalsProposalIdVotesVoterGet(proposalId, voter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MintApi - axios parameter creator
 * @export
 */
export const MintApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Current minting annual provisions value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintingAnnualProvisionsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/minting/annual-provisions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Current minting inflation value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintingInflationGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/minting/inflation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Minting module parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintingParametersGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/minting/parameters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MintApi - functional programming interface
 * @export
 */
export const MintApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Current minting annual provisions value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mintingAnnualProvisionsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await MintApiAxiosParamCreator(configuration).mintingAnnualProvisionsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Current minting inflation value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mintingInflationGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await MintApiAxiosParamCreator(configuration).mintingInflationGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Minting module parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mintingParametersGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await MintApiAxiosParamCreator(configuration).mintingParametersGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MintApi - factory interface
 * @export
 */
export const MintApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Current minting annual provisions value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintingAnnualProvisionsGet(options?: any): AxiosPromise<string> {
            return MintApiFp(configuration).mintingAnnualProvisionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Current minting inflation value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintingInflationGet(options?: any): AxiosPromise<string> {
            return MintApiFp(configuration).mintingInflationGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Minting module parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintingParametersGet(options?: any): AxiosPromise<object> {
            return MintApiFp(configuration).mintingParametersGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MintApi - object-oriented interface
 * @export
 * @class MintApi
 * @extends {BaseAPI}
 */
export class MintApi extends BaseAPI {
    /**
     * 
     * @summary Current minting annual provisions value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MintApi
     */
    public mintingAnnualProvisionsGet(options?: any) {
        return MintApiFp(this.configuration).mintingAnnualProvisionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Current minting inflation value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MintApi
     */
    public mintingInflationGet(options?: any) {
        return MintApiFp(this.configuration).mintingInflationGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Minting module parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MintApi
     */
    public mintingParametersGet(options?: any) {
        return MintApiFp(this.configuration).mintingParametersGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Account returns account details based on address.
         * @param {string} address address defines the address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        account: async (address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling account.');
            }
            const localVarPath = `/cosmos/auth/v1beta1/accounts/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary AllBalances queries the balance of all coins for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allBalances: async (address: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling allBalances.');
            }
            const localVarPath = `/cosmos/bank/v1beta1/balances/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary AllEvidence queries all evidence.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allEvidence: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/evidence/v1beta1/evidence`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary AnnualProvisions current minting annual provisions value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annualProvisions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/mint/v1beta1/annual_provisions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary AppliedPlan queries a previously applied upgrade plan by its name.
         * @param {string} name name is the name of the applied plan to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appliedPlan: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling appliedPlan.');
            }
            const localVarPath = `/cosmos/upgrade/v1beta1/applied_plan/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Params queries all parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authParams: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/auth/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Balance queries the balance of a single coin for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} denom denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balance: async (address: string, denom: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling balance.');
            }
            // verify required parameter 'denom' is not null or undefined
            if (denom === null || denom === undefined) {
                throw new RequiredError('denom','Required parameter denom was null or undefined when calling balance.');
            }
            const localVarPath = `/cosmos/bank/v1beta1/balances/{address}/{denom}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)))
                .replace(`{${"denom"}}`, encodeURIComponent(String(denom)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Params queries the parameters of x/bank module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankParams: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/bank/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Channel queries an IBC Channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channel: async (channelId: string, portId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling channel.');
            }
            // verify required parameter 'portId' is not null or undefined
            if (portId === null || portId === undefined) {
                throw new RequiredError('portId','Required parameter portId was null or undefined when calling channel.');
            }
            const localVarPath = `/ibc/core/channel/v1beta1/channels/{channel_id}/ports/{port_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ChannelClientState queries for the client state for the channel associated with the provided channel identifiers.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelClientState: async (channelId: string, portId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling channelClientState.');
            }
            // verify required parameter 'portId' is not null or undefined
            if (portId === null || portId === undefined) {
                throw new RequiredError('portId','Required parameter portId was null or undefined when calling channelClientState.');
            }
            const localVarPath = `/ibc/core/channel/v1beta1/channels/{channel_id}/ports/{port_id}/client_state`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ChannelConsensusState queries for the consensus state for the channel associated with the provided channel identifiers.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} revisionNumber revision number of the consensus state
         * @param {string} revisionHeight revision height of the consensus state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelConsensusState: async (channelId: string, portId: string, revisionNumber: string, revisionHeight: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling channelConsensusState.');
            }
            // verify required parameter 'portId' is not null or undefined
            if (portId === null || portId === undefined) {
                throw new RequiredError('portId','Required parameter portId was null or undefined when calling channelConsensusState.');
            }
            // verify required parameter 'revisionNumber' is not null or undefined
            if (revisionNumber === null || revisionNumber === undefined) {
                throw new RequiredError('revisionNumber','Required parameter revisionNumber was null or undefined when calling channelConsensusState.');
            }
            // verify required parameter 'revisionHeight' is not null or undefined
            if (revisionHeight === null || revisionHeight === undefined) {
                throw new RequiredError('revisionHeight','Required parameter revisionHeight was null or undefined when calling channelConsensusState.');
            }
            const localVarPath = `/ibc/core/channel/v1beta1/channels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_number}/height/{revision_height}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)))
                .replace(`{${"revision_number"}}`, encodeURIComponent(String(revisionNumber)))
                .replace(`{${"revision_height"}}`, encodeURIComponent(String(revisionHeight)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Channels queries all the IBC channels of a chain.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channels: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ibc/core/channel/v1beta1/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ClientConnections queries the connection paths associated with a client state.
         * @param {string} clientId client identifier associated with a connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientConnections: async (clientId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling clientConnections.');
            }
            const localVarPath = `/ibc/core/connection/v1beta1/client_connections/{client_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ClientParams queries all parameters of the ibc client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientParams: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ibc/client/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ClientState queries an IBC light client.
         * @param {string} clientId client state unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientState: async (clientId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling clientState.');
            }
            const localVarPath = `/ibc/core/client/v1beta1/client_states/{client_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ClientStates queries all the IBC light clients of a chain.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientStates: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ibc/core/client/v1beta1/client_states`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary CommunityPool queries the community pool coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityPool: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/distribution/v1beta1/community_pool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Connection queries an IBC connection end.
         * @param {string} connectionId connection unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connection: async (connectionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            if (connectionId === null || connectionId === undefined) {
                throw new RequiredError('connectionId','Required parameter connectionId was null or undefined when calling connection.');
            }
            const localVarPath = `/ibc/core/connection/v1beta1/connections/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ConnectionChannels queries all the channels associated with a connection end.
         * @param {string} connection connection unique identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionChannels: async (connection: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'connection' is not null or undefined
            if (connection === null || connection === undefined) {
                throw new RequiredError('connection','Required parameter connection was null or undefined when calling connectionChannels.');
            }
            const localVarPath = `/ibc/core/channel/v1beta1/connections/{connection}/channels`
                .replace(`{${"connection"}}`, encodeURIComponent(String(connection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ConnectionClientState queries the client state associated with the connection.
         * @param {string} connectionId connection identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionClientState: async (connectionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            if (connectionId === null || connectionId === undefined) {
                throw new RequiredError('connectionId','Required parameter connectionId was null or undefined when calling connectionClientState.');
            }
            const localVarPath = `/ibc/core/connection/v1beta1/connections/{connection_id}/client_state`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ConnectionConsensusState queries the consensus state associated with the connection.
         * @param {string} connectionId connection identifier
         * @param {string} revisionNumber 
         * @param {string} revisionHeight 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionConsensusState: async (connectionId: string, revisionNumber: string, revisionHeight: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            if (connectionId === null || connectionId === undefined) {
                throw new RequiredError('connectionId','Required parameter connectionId was null or undefined when calling connectionConsensusState.');
            }
            // verify required parameter 'revisionNumber' is not null or undefined
            if (revisionNumber === null || revisionNumber === undefined) {
                throw new RequiredError('revisionNumber','Required parameter revisionNumber was null or undefined when calling connectionConsensusState.');
            }
            // verify required parameter 'revisionHeight' is not null or undefined
            if (revisionHeight === null || revisionHeight === undefined) {
                throw new RequiredError('revisionHeight','Required parameter revisionHeight was null or undefined when calling connectionConsensusState.');
            }
            const localVarPath = `/ibc/core/connection/v1beta1/connections/{connection_id}/consensus_state/revision/{revision_number}/height/{revision_height}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)))
                .replace(`{${"revision_number"}}`, encodeURIComponent(String(revisionNumber)))
                .replace(`{${"revision_height"}}`, encodeURIComponent(String(revisionHeight)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Connections queries all the IBC connections of a chain.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connections: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ibc/core/connection/v1beta1/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ConsensusState queries a consensus state associated with a client state at a given height.
         * @param {string} clientId client identifier
         * @param {string} revisionNumber consensus state revision number
         * @param {string} revisionHeight consensus state revision height
         * @param {boolean} [latestHeight] latest_height overrrides the height field and queries the latest stored ConsensusState.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consensusState: async (clientId: string, revisionNumber: string, revisionHeight: string, latestHeight?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling consensusState.');
            }
            // verify required parameter 'revisionNumber' is not null or undefined
            if (revisionNumber === null || revisionNumber === undefined) {
                throw new RequiredError('revisionNumber','Required parameter revisionNumber was null or undefined when calling consensusState.');
            }
            // verify required parameter 'revisionHeight' is not null or undefined
            if (revisionHeight === null || revisionHeight === undefined) {
                throw new RequiredError('revisionHeight','Required parameter revisionHeight was null or undefined when calling consensusState.');
            }
            const localVarPath = `/ibc/core/client/v1beta1/consensus_states/{client_id}/revision/{revision_number}/height/{revision_height}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)))
                .replace(`{${"revision_number"}}`, encodeURIComponent(String(revisionNumber)))
                .replace(`{${"revision_height"}}`, encodeURIComponent(String(revisionHeight)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (latestHeight !== undefined) {
                localVarQueryParameter['latest_height'] = latestHeight;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ConsensusStates queries all the consensus state associated with a given client.
         * @param {string} clientId client identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consensusStates: async (clientId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling consensusStates.');
            }
            const localVarPath = `/ibc/core/client/v1beta1/consensus_states/{client_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary CurrentPlan queries the current upgrade plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentPlan: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/upgrade/v1beta1/current_plan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delegation queries delegate info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegation: async (validatorAddr: string, delegatorAddr: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddr' is not null or undefined
            if (validatorAddr === null || validatorAddr === undefined) {
                throw new RequiredError('validatorAddr','Required parameter validatorAddr was null or undefined when calling delegation.');
            }
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling delegation.');
            }
            const localVarPath = `/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}`
                .replace(`{${"validator_addr"}}`, encodeURIComponent(String(validatorAddr)))
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DelegationRewards queries the total rewards accrued by a delegation.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegationRewards: async (delegatorAddress: string, validatorAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddress' is not null or undefined
            if (delegatorAddress === null || delegatorAddress === undefined) {
                throw new RequiredError('delegatorAddress','Required parameter delegatorAddress was null or undefined when calling delegationRewards.');
            }
            // verify required parameter 'validatorAddress' is not null or undefined
            if (validatorAddress === null || validatorAddress === undefined) {
                throw new RequiredError('validatorAddress','Required parameter validatorAddress was null or undefined when calling delegationRewards.');
            }
            const localVarPath = `/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}`
                .replace(`{${"delegator_address"}}`, encodeURIComponent(String(delegatorAddress)))
                .replace(`{${"validator_address"}}`, encodeURIComponent(String(validatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DelegationTotalRewards queries the total rewards accrued by a each validator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegationTotalRewards: async (delegatorAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddress' is not null or undefined
            if (delegatorAddress === null || delegatorAddress === undefined) {
                throw new RequiredError('delegatorAddress','Required parameter delegatorAddress was null or undefined when calling delegationTotalRewards.');
            }
            const localVarPath = `/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards`
                .replace(`{${"delegator_address"}}`, encodeURIComponent(String(delegatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DelegatorDelegations queries all delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorDelegations: async (delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling delegatorDelegations.');
            }
            const localVarPath = `/cosmos/staking/v1beta1/delegations/{delegator_addr}`
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DelegatorUnbondingDelegations queries all unbonding delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorUnbondingDelegations: async (delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling delegatorUnbondingDelegations.');
            }
            const localVarPath = `/cosmos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations`
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DelegatorValidator queries validator info for given delegator validator pair.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorValidator: async (delegatorAddr: string, validatorAddr: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling delegatorValidator.');
            }
            // verify required parameter 'validatorAddr' is not null or undefined
            if (validatorAddr === null || validatorAddr === undefined) {
                throw new RequiredError('validatorAddr','Required parameter validatorAddr was null or undefined when calling delegatorValidator.');
            }
            const localVarPath = `/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators/{validator_addr}`
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)))
                .replace(`{${"validator_addr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DelegatorValidators queries the validators of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorValidators: async (delegatorAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddress' is not null or undefined
            if (delegatorAddress === null || delegatorAddress === undefined) {
                throw new RequiredError('delegatorAddress','Required parameter delegatorAddress was null or undefined when calling delegatorValidators.');
            }
            const localVarPath = `/cosmos/distribution/v1beta1/delegators/{delegator_address}/validators`
                .replace(`{${"delegator_address"}}`, encodeURIComponent(String(delegatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DelegatorWithdrawAddress queries withdraw address of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorWithdrawAddress: async (delegatorAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddress' is not null or undefined
            if (delegatorAddress === null || delegatorAddress === undefined) {
                throw new RequiredError('delegatorAddress','Required parameter delegatorAddress was null or undefined when calling delegatorWithdrawAddress.');
            }
            const localVarPath = `/cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address`
                .replace(`{${"delegator_address"}}`, encodeURIComponent(String(delegatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DenomTrace queries a denomination trace information.
         * @param {string} hash hash (in hex format) of the denomination trace information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomTrace: async (hash: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling denomTrace.');
            }
            const localVarPath = `/ibc/applications/transfer/v1beta1/denom_traces/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DenomTraces queries all denomination traces.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomTraces: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ibc/applications/transfer/v1beta1/denom_traces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deposit queries single deposit information based proposalID, depositAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} depositor depositor defines the deposit addresses from the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit: async (proposalId: string, depositor: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            if (proposalId === null || proposalId === undefined) {
                throw new RequiredError('proposalId','Required parameter proposalId was null or undefined when calling deposit.');
            }
            // verify required parameter 'depositor' is not null or undefined
            if (depositor === null || depositor === undefined) {
                throw new RequiredError('depositor','Required parameter depositor was null or undefined when calling deposit.');
            }
            const localVarPath = `/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)))
                .replace(`{${"depositor"}}`, encodeURIComponent(String(depositor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deposits queries all deposits of a single proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposits: async (proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            if (proposalId === null || proposalId === undefined) {
                throw new RequiredError('proposalId','Required parameter proposalId was null or undefined when calling deposits.');
            }
            const localVarPath = `/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Params queries params of the distribution module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionParams: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/distribution/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Evidence queries evidence based on evidence hash.
         * @param {string} evidenceHash evidence_hash defines the hash of the requested evidence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evidence: async (evidenceHash: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'evidenceHash' is not null or undefined
            if (evidenceHash === null || evidenceHash === undefined) {
                throw new RequiredError('evidenceHash','Required parameter evidenceHash was null or undefined when calling evidence.');
            }
            const localVarPath = `/cosmos/evidence/v1beta1/evidence/{evidence_hash}`
                .replace(`{${"evidence_hash"}}`, encodeURIComponent(String(evidenceHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Params queries all parameters of the gov module.
         * @param {string} paramsType params_type defines which parameters to query for, can be one of \&quot;voting\&quot;, \&quot;tallying\&quot; or \&quot;deposit\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParams: async (paramsType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paramsType' is not null or undefined
            if (paramsType === null || paramsType === undefined) {
                throw new RequiredError('paramsType','Required parameter paramsType was null or undefined when calling govParams.');
            }
            const localVarPath = `/cosmos/gov/v1beta1/params/{params_type}`
                .replace(`{${"params_type"}}`, encodeURIComponent(String(paramsType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary HistoricalInfo queries the historical info for given height.
         * @param {string} height height defines at which height to query the historical info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicalInfo: async (height: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            if (height === null || height === undefined) {
                throw new RequiredError('height','Required parameter height was null or undefined when calling historicalInfo.');
            }
            const localVarPath = `/cosmos/staking/v1beta1/historical_info/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Params queries all parameters of the ibc-transfer module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iBCTransferParams: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ibc/applications/transfer/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inflation returns the current minting inflation value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inflation: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/mint/v1beta1/inflation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Params returns the total set of minting parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintParams: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/mint/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary NextSequenceReceive returns the next receive sequence for a given channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nextSequenceReceive: async (channelId: string, portId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling nextSequenceReceive.');
            }
            // verify required parameter 'portId' is not null or undefined
            if (portId === null || portId === undefined) {
                throw new RequiredError('portId','Required parameter portId was null or undefined when calling nextSequenceReceive.');
            }
            const localVarPath = `/ibc/core/channel/v1beta1/channels/{channel_id}/ports/{port_id}/next_sequence`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PacketAcknowledgement queries a stored packet acknowledgement hash.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} sequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packetAcknowledgement: async (channelId: string, portId: string, sequence: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling packetAcknowledgement.');
            }
            // verify required parameter 'portId' is not null or undefined
            if (portId === null || portId === undefined) {
                throw new RequiredError('portId','Required parameter portId was null or undefined when calling packetAcknowledgement.');
            }
            // verify required parameter 'sequence' is not null or undefined
            if (sequence === null || sequence === undefined) {
                throw new RequiredError('sequence','Required parameter sequence was null or undefined when calling packetAcknowledgement.');
            }
            const localVarPath = `/ibc/core/channel/v1beta1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)))
                .replace(`{${"sequence"}}`, encodeURIComponent(String(sequence)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PacketAcknowledgements returns all the packet acknowledgements associated with a channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packetAcknowledgements: async (channelId: string, portId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling packetAcknowledgements.');
            }
            // verify required parameter 'portId' is not null or undefined
            if (portId === null || portId === undefined) {
                throw new RequiredError('portId','Required parameter portId was null or undefined when calling packetAcknowledgements.');
            }
            const localVarPath = `/ibc/core/channel/v1beta1/channels/{channel_id}/ports/{port_id}/packet_acknowledgements`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PacketCommitment queries a stored packet commitment hash.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} sequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packetCommitment: async (channelId: string, portId: string, sequence: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling packetCommitment.');
            }
            // verify required parameter 'portId' is not null or undefined
            if (portId === null || portId === undefined) {
                throw new RequiredError('portId','Required parameter portId was null or undefined when calling packetCommitment.');
            }
            // verify required parameter 'sequence' is not null or undefined
            if (sequence === null || sequence === undefined) {
                throw new RequiredError('sequence','Required parameter sequence was null or undefined when calling packetCommitment.');
            }
            const localVarPath = `/ibc/core/channel/v1beta1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)))
                .replace(`{${"sequence"}}`, encodeURIComponent(String(sequence)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PacketCommitments returns all the packet commitments hashes associated with a channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packetCommitments: async (channelId: string, portId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling packetCommitments.');
            }
            // verify required parameter 'portId' is not null or undefined
            if (portId === null || portId === undefined) {
                throw new RequiredError('portId','Required parameter portId was null or undefined when calling packetCommitments.');
            }
            const localVarPath = `/ibc/core/channel/v1beta1/channels/{channel_id}/ports/{port_id}/packet_commitments`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PacketReceipt queries if a given packet sequence has been received on the queried chain
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} sequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packetReceipt: async (channelId: string, portId: string, sequence: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling packetReceipt.');
            }
            // verify required parameter 'portId' is not null or undefined
            if (portId === null || portId === undefined) {
                throw new RequiredError('portId','Required parameter portId was null or undefined when calling packetReceipt.');
            }
            // verify required parameter 'sequence' is not null or undefined
            if (sequence === null || sequence === undefined) {
                throw new RequiredError('sequence','Required parameter sequence was null or undefined when calling packetReceipt.');
            }
            const localVarPath = `/ibc/core/channel/v1beta1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)))
                .replace(`{${"sequence"}}`, encodeURIComponent(String(sequence)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Params queries a specific parameter of a module, given its subspace and key.
         * @param {string} [subspace] subspace defines the module to query the parameter for.
         * @param {string} [key] key defines the key of the parameter in the subspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        params: async (subspace?: string, key?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/params/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (subspace !== undefined) {
                localVarQueryParameter['subspace'] = subspace;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pool queries the pool info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pool: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/staking/v1beta1/pool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Proposal queries proposal details based on ProposalID.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proposal: async (proposalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            if (proposalId === null || proposalId === undefined) {
                throw new RequiredError('proposalId','Required parameter proposalId was null or undefined when calling proposal.');
            }
            const localVarPath = `/cosmos/gov/v1beta1/proposals/{proposal_id}`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Proposals queries all proposals based on given status.
         * @param {'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED'} [proposalStatus] proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
         * @param {string} [voter] voter defines the voter address for the proposals.
         * @param {string} [depositor] depositor defines the deposit addresses from the proposals.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proposals: async (proposalStatus?: 'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED', voter?: string, depositor?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/gov/v1beta1/proposals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (proposalStatus !== undefined) {
                localVarQueryParameter['proposal_status'] = proposalStatus;
            }

            if (voter !== undefined) {
                localVarQueryParameter['voter'] = voter;
            }

            if (depositor !== undefined) {
                localVarQueryParameter['depositor'] = depositor;
            }

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redelegations queries redelegations of given address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [srcValidatorAddr] src_validator_addr defines the validator address to redelegate from.
         * @param {string} [dstValidatorAddr] dst_validator_addr defines the validator address to redelegate to.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redelegations: async (delegatorAddr: string, srcValidatorAddr?: string, dstValidatorAddr?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling redelegations.');
            }
            const localVarPath = `/cosmos/staking/v1beta1/delegators/{delegator_addr}/redelegations`
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (srcValidatorAddr !== undefined) {
                localVarQueryParameter['src_validator_addr'] = srcValidatorAddr;
            }

            if (dstValidatorAddr !== undefined) {
                localVarQueryParameter['dst_validator_addr'] = dstValidatorAddr;
            }

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary SigningInfo queries the signing info of given cons address
         * @param {string} consAddress cons_address is the address to query signing info of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signingInfo: async (consAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consAddress' is not null or undefined
            if (consAddress === null || consAddress === undefined) {
                throw new RequiredError('consAddress','Required parameter consAddress was null or undefined when calling signingInfo.');
            }
            const localVarPath = `/cosmos/slashing/v1beta1/signing_infos/{cons_address}`
                .replace(`{${"cons_address"}}`, encodeURIComponent(String(consAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary SigningInfos queries signing info of all validators
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signingInfos: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/slashing/v1beta1/signing_infos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Params queries the parameters of slashing module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingParams: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/slashing/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DelegatorValidators queries all validators info for given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorValidators: async (delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling stakingDelegatorValidators.');
            }
            const localVarPath = `/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators`
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Parameters queries the staking parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingParams: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/staking/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary SupplyOf queries the supply of a single coin.
         * @param {string} denom denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplyOf: async (denom: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'denom' is not null or undefined
            if (denom === null || denom === undefined) {
                throw new RequiredError('denom','Required parameter denom was null or undefined when calling supplyOf.');
            }
            const localVarPath = `/cosmos/bank/v1beta1/supply/{denom}`
                .replace(`{${"denom"}}`, encodeURIComponent(String(denom)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary TallyResult queries the tally of a proposal vote.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tallyResult: async (proposalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            if (proposalId === null || proposalId === undefined) {
                throw new RequiredError('proposalId','Required parameter proposalId was null or undefined when calling tallyResult.');
            }
            const localVarPath = `/cosmos/gov/v1beta1/proposals/{proposal_id}/tally`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary TotalSupply queries the total supply of all coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalSupply: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/bank/v1beta1/supply`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary UnbondingDelegation queries unbonding info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbondingDelegation: async (validatorAddr: string, delegatorAddr: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddr' is not null or undefined
            if (validatorAddr === null || validatorAddr === undefined) {
                throw new RequiredError('validatorAddr','Required parameter validatorAddr was null or undefined when calling unbondingDelegation.');
            }
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling unbondingDelegation.');
            }
            const localVarPath = `/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}/unbonding_delegation`
                .replace(`{${"validator_addr"}}`, encodeURIComponent(String(validatorAddr)))
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary UnreceivedAcks returns all the unreceived IBC acknowledgements associated with a channel and sequences.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {Array<string>} packetAckSequences list of acknowledgement sequences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unreceivedAcks: async (channelId: string, portId: string, packetAckSequences: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling unreceivedAcks.');
            }
            // verify required parameter 'portId' is not null or undefined
            if (portId === null || portId === undefined) {
                throw new RequiredError('portId','Required parameter portId was null or undefined when calling unreceivedAcks.');
            }
            // verify required parameter 'packetAckSequences' is not null or undefined
            if (packetAckSequences === null || packetAckSequences === undefined) {
                throw new RequiredError('packetAckSequences','Required parameter packetAckSequences was null or undefined when calling unreceivedAcks.');
            }
            const localVarPath = `/ibc/core/channel/v1beta1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_ack_sequences}/unreceived_acks`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)))
                .replace(`{${"packet_ack_sequences"}}`, encodeURIComponent(String(packetAckSequences)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary UnreceivedPackets returns all the unreceived IBC packets associated with a channel and sequences.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {Array<string>} packetCommitmentSequences list of packet sequences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unreceivedPackets: async (channelId: string, portId: string, packetCommitmentSequences: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling unreceivedPackets.');
            }
            // verify required parameter 'portId' is not null or undefined
            if (portId === null || portId === undefined) {
                throw new RequiredError('portId','Required parameter portId was null or undefined when calling unreceivedPackets.');
            }
            // verify required parameter 'packetCommitmentSequences' is not null or undefined
            if (packetCommitmentSequences === null || packetCommitmentSequences === undefined) {
                throw new RequiredError('packetCommitmentSequences','Required parameter packetCommitmentSequences was null or undefined when calling unreceivedPackets.');
            }
            const localVarPath = `/ibc/core/channel/v1beta1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/unreceived_packets`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)))
                .replace(`{${"packet_commitment_sequences"}}`, encodeURIComponent(String(packetCommitmentSequences)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary UpgradedConsensusState queries the consensus state that will serve as a trusted kernel for the next version of this chain. It will only be stored at the last height of this chain. UpgradedConsensusState RPC not supported with legacy querier
         * @param {string} lastHeight last height of the current chain must be sent in request as this is the height under which next consensus state is stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradedConsensusState: async (lastHeight: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lastHeight' is not null or undefined
            if (lastHeight === null || lastHeight === undefined) {
                throw new RequiredError('lastHeight','Required parameter lastHeight was null or undefined when calling upgradedConsensusState.');
            }
            const localVarPath = `/cosmos/upgrade/v1beta1/upgraded_consensus_state/{last_height}`
                .replace(`{${"last_height"}}`, encodeURIComponent(String(lastHeight)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validator queries validator info for given validator address.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validator: async (validatorAddr: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddr' is not null or undefined
            if (validatorAddr === null || validatorAddr === undefined) {
                throw new RequiredError('validatorAddr','Required parameter validatorAddr was null or undefined when calling validator.');
            }
            const localVarPath = `/cosmos/staking/v1beta1/validators/{validator_addr}`
                .replace(`{${"validator_addr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ValidatorCommission queries accumulated commission for a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorCommission: async (validatorAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddress' is not null or undefined
            if (validatorAddress === null || validatorAddress === undefined) {
                throw new RequiredError('validatorAddress','Required parameter validatorAddress was null or undefined when calling validatorCommission.');
            }
            const localVarPath = `/cosmos/distribution/v1beta1/validators/{validator_address}/commission`
                .replace(`{${"validator_address"}}`, encodeURIComponent(String(validatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ValidatorDelegations queries delegate info for given validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorDelegations: async (validatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddr' is not null or undefined
            if (validatorAddr === null || validatorAddr === undefined) {
                throw new RequiredError('validatorAddr','Required parameter validatorAddr was null or undefined when calling validatorDelegations.');
            }
            const localVarPath = `/cosmos/staking/v1beta1/validators/{validator_addr}/delegations`
                .replace(`{${"validator_addr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ValidatorOutstandingRewards queries rewards of a validator address.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorOutstandingRewards: async (validatorAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddress' is not null or undefined
            if (validatorAddress === null || validatorAddress === undefined) {
                throw new RequiredError('validatorAddress','Required parameter validatorAddress was null or undefined when calling validatorOutstandingRewards.');
            }
            const localVarPath = `/cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards`
                .replace(`{${"validator_address"}}`, encodeURIComponent(String(validatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ValidatorSlashes queries slash events of a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {string} [startingHeight] starting_height defines the optional starting height to query the slashes.
         * @param {string} [endingHeight] starting_height defines the optional ending height to query the slashes.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorSlashes: async (validatorAddress: string, startingHeight?: string, endingHeight?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddress' is not null or undefined
            if (validatorAddress === null || validatorAddress === undefined) {
                throw new RequiredError('validatorAddress','Required parameter validatorAddress was null or undefined when calling validatorSlashes.');
            }
            const localVarPath = `/cosmos/distribution/v1beta1/validators/{validator_address}/slashes`
                .replace(`{${"validator_address"}}`, encodeURIComponent(String(validatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startingHeight !== undefined) {
                localVarQueryParameter['starting_height'] = startingHeight;
            }

            if (endingHeight !== undefined) {
                localVarQueryParameter['ending_height'] = endingHeight;
            }

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ValidatorUnbondingDelegations queries unbonding delegations of a validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorUnbondingDelegations: async (validatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddr' is not null or undefined
            if (validatorAddr === null || validatorAddr === undefined) {
                throw new RequiredError('validatorAddr','Required parameter validatorAddr was null or undefined when calling validatorUnbondingDelegations.');
            }
            const localVarPath = `/cosmos/staking/v1beta1/validators/{validator_addr}/unbonding_delegations`
                .replace(`{${"validator_addr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validators queries all validators that match the given status.
         * @param {string} [status] status enables to query for validators matching a given status.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validators: async (status?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/staking/v1beta1/validators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Vote queries voted information based on proposalID, voterAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} voter voter defines the oter address for the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vote: async (proposalId: string, voter: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            if (proposalId === null || proposalId === undefined) {
                throw new RequiredError('proposalId','Required parameter proposalId was null or undefined when calling vote.');
            }
            // verify required parameter 'voter' is not null or undefined
            if (voter === null || voter === undefined) {
                throw new RequiredError('voter','Required parameter voter was null or undefined when calling vote.');
            }
            const localVarPath = `/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)))
                .replace(`{${"voter"}}`, encodeURIComponent(String(voter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Votes queries votes of a given proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votes: async (proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            if (proposalId === null || proposalId === undefined) {
                throw new RequiredError('proposalId','Required parameter proposalId was null or undefined when calling votes.');
            }
            const localVarPath = `/cosmos/gov/v1beta1/proposals/{proposal_id}/votes`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Account returns account details based on address.
         * @param {string} address address defines the address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async account(address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20025>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).account(address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary AllBalances queries the balance of all coins for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allBalances(address: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20027>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).allBalances(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary AllEvidence queries all evidence.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allEvidence(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20045>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).allEvidence(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary AnnualProvisions current minting annual provisions value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annualProvisions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20055>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).annualProvisions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary AppliedPlan queries a previously applied upgrade plan by its name.
         * @param {string} name name is the name of the applied plan to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appliedPlan(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20072>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).appliedPlan(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Params queries all parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authParams(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20026>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).authParams(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Balance queries the balance of a single coin for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} denom denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balance(address: string, denom: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20028>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).balance(address, denom, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Params queries the parameters of x/bank module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankParams(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20029>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).bankParams(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Channel queries an IBC Channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channel(channelId: string, portId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20076>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).channel(channelId, portId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary ChannelClientState queries for the client state for the channel associated with the provided channel identifiers.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelClientState(channelId: string, portId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).channelClientState(channelId, portId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary ChannelConsensusState queries for the consensus state for the channel associated with the provided channel identifiers.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} revisionNumber revision number of the consensus state
         * @param {string} revisionHeight revision height of the consensus state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelConsensusState(channelId: string, portId: string, revisionNumber: string, revisionHeight: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod1>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).channelConsensusState(channelId, portId, revisionNumber, revisionHeight, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Channels queries all the IBC channels of a chain.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channels(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20075>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).channels(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary ClientConnections queries the connection paths associated with a client state.
         * @param {string} clientId client identifier associated with a connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientConnections(clientId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryClientConnectionsResponseIsTheResponseTypeForTheQueryClientConnectionsRPCMethod>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).clientConnections(clientId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary ClientParams queries all parameters of the ibc client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientParams(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20077>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).clientParams(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary ClientState queries an IBC light client.
         * @param {string} clientId client state unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientState(clientId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20079>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).clientState(clientId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary ClientStates queries all the IBC light clients of a chain.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientStates(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20078>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).clientStates(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary CommunityPool queries the community pool coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async communityPool(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20037>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).communityPool(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Connection queries an IBC connection end.
         * @param {string} connectionId connection unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connection(connectionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20081>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).connection(connectionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary ConnectionChannels queries all the channels associated with a connection end.
         * @param {string} connection connection unique identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectionChannels(connection: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryConnectionChannelsResponseIsTheResponseTypeForTheQueryQueryConnectionChannelsRPCMethod>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).connectionChannels(connection, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary ConnectionClientState queries the client state associated with the connection.
         * @param {string} connectionId connection identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectionClientState(connectionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryConnectionClientStateResponseIsTheResponseTypeForTheQueryConnectionClientStateRPCMethod>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).connectionClientState(connectionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary ConnectionConsensusState queries the consensus state associated with the connection.
         * @param {string} connectionId connection identifier
         * @param {string} revisionNumber 
         * @param {string} revisionHeight 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectionConsensusState(connectionId: string, revisionNumber: string, revisionHeight: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryConnectionConsensusStateResponseIsTheResponseTypeForTheQueryConnectionConsensusStateRPCMethod>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).connectionConsensusState(connectionId, revisionNumber, revisionHeight, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Connections queries all the IBC connections of a chain.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connections(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20080>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).connections(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary ConsensusState queries a consensus state associated with a client state at a given height.
         * @param {string} clientId client identifier
         * @param {string} revisionNumber consensus state revision number
         * @param {string} revisionHeight consensus state revision height
         * @param {boolean} [latestHeight] latest_height overrrides the height field and queries the latest stored ConsensusState.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consensusState(clientId: string, revisionNumber: string, revisionHeight: string, latestHeight?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryConsensusStateResponseIsTheResponseTypeForTheQueryConsensusStateRPCMethod>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).consensusState(clientId, revisionNumber, revisionHeight, latestHeight, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary ConsensusStates queries all the consensus state associated with a given client.
         * @param {string} clientId client identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consensusStates(clientId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethod>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).consensusStates(clientId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary CurrentPlan queries the current upgrade plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentPlan(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20073>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).currentPlan(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delegation queries delegate info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegation(validatorAddr: string, delegatorAddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20067>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).delegation(validatorAddr, delegatorAddr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary DelegationRewards queries the total rewards accrued by a delegation.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegationRewards(delegatorAddress: string, validatorAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20039>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).delegationRewards(delegatorAddress, validatorAddress, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary DelegationTotalRewards queries the total rewards accrued by a each validator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegationTotalRewards(delegatorAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20038>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).delegationTotalRewards(delegatorAddress, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary DelegatorDelegations queries all delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegatorDelegations(delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20059>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).delegatorDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary DelegatorUnbondingDelegations queries all unbonding delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegatorUnbondingDelegations(delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20061>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).delegatorUnbondingDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary DelegatorValidator queries validator info for given delegator validator pair.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegatorValidator(delegatorAddr: string, validatorAddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20063>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).delegatorValidator(delegatorAddr, validatorAddr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary DelegatorValidators queries the validators of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegatorValidators(delegatorAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20040>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).delegatorValidators(delegatorAddress, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary DelegatorWithdrawAddress queries withdraw address of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegatorWithdrawAddress(delegatorAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20041>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).delegatorWithdrawAddress(delegatorAddress, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary DenomTrace queries a denomination trace information.
         * @param {string} hash hash (in hex format) of the denomination trace information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async denomTrace(hash: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20083>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).denomTrace(hash, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary DenomTraces queries all denomination traces.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async denomTraces(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20082>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).denomTraces(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deposit queries single deposit information based proposalID, depositAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} depositor depositor defines the deposit addresses from the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deposit(proposalId: string, depositor: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20051>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).deposit(proposalId, depositor, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deposits queries all deposits of a single proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deposits(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20050>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).deposits(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Params queries params of the distribution module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async distributionParams(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20042>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).distributionParams(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Evidence queries evidence based on evidence hash.
         * @param {string} evidenceHash evidence_hash defines the hash of the requested evidence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evidence(evidenceHash: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20046>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).evidence(evidenceHash, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Params queries all parameters of the gov module.
         * @param {string} paramsType params_type defines which parameters to query for, can be one of \&quot;voting\&quot;, \&quot;tallying\&quot; or \&quot;deposit\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govParams(paramsType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).govParams(paramsType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary HistoricalInfo queries the historical info for given height.
         * @param {string} height height defines at which height to query the historical info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async historicalInfo(height: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20064>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).historicalInfo(height, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Params queries all parameters of the ibc-transfer module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iBCTransferParams(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20084>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).iBCTransferParams(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Inflation returns the current minting inflation value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inflation(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20056>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).inflation(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Params returns the total set of minting parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mintParams(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20057>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).mintParams(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary NextSequenceReceive returns the next receive sequence for a given channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nextSequenceReceive(channelId: string, portId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuerySequenceResponseIsTheRequestTypeForTheQueryQueryNextSequenceReceiveResponseRPCMethod>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).nextSequenceReceive(channelId, portId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary PacketAcknowledgement queries a stored packet acknowledgement hash.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} sequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packetAcknowledgement(channelId: string, portId: string, sequence: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryPacketAcknowledgementResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).packetAcknowledgement(channelId, portId, sequence, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary PacketAcknowledgements returns all the packet acknowledgements associated with a channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packetAcknowledgements(channelId: string, portId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethod>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).packetAcknowledgements(channelId, portId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary PacketCommitment queries a stored packet commitment hash.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} sequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packetCommitment(channelId: string, portId: string, sequence: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryPacketCommitmentResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).packetCommitment(channelId, portId, sequence, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary PacketCommitments returns all the packet commitments hashes associated with a channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packetCommitments(channelId: string, portId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryPacketCommitmentsResponseIsTheRequestTypeForTheQueryQueryPacketCommitmentsRPCMethod>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).packetCommitments(channelId, portId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary PacketReceipt queries if a given packet sequence has been received on the queried chain
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} sequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packetReceipt(channelId: string, portId: string, sequence: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryPacketReceiptResponseDefinesTheClientQueryResponseForAPacketReceiptWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).packetReceipt(channelId, portId, sequence, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Params queries a specific parameter of a module, given its subspace and key.
         * @param {string} [subspace] subspace defines the module to query the parameter for.
         * @param {string} [key] key defines the key of the parameter in the subspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async params(subspace?: string, key?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20058>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).params(subspace, key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Pool queries the pool info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pool(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20066>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).pool(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Proposal queries proposal details based on ProposalID.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proposal(proposalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20049>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).proposal(proposalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Proposals queries all proposals based on given status.
         * @param {'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED'} [proposalStatus] proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
         * @param {string} [voter] voter defines the voter address for the proposals.
         * @param {string} [depositor] depositor defines the deposit addresses from the proposals.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proposals(proposalStatus?: 'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED', voter?: string, depositor?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20048>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).proposals(proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Redelegations queries redelegations of given address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [srcValidatorAddr] src_validator_addr defines the validator address to redelegate from.
         * @param {string} [dstValidatorAddr] dst_validator_addr defines the validator address to redelegate to.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redelegations(delegatorAddr: string, srcValidatorAddr?: string, dstValidatorAddr?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20060>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).redelegations(delegatorAddr, srcValidatorAddr, dstValidatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary SigningInfo queries the signing info of given cons address
         * @param {string} consAddress cons_address is the address to query signing info of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signingInfo(consAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuerySigningInfoResponseIsTheResponseTypeForTheQuerySigningInfoRPCMethod>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).signingInfo(consAddress, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary SigningInfos queries signing info of all validators
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signingInfos(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethod>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).signingInfos(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Params queries the parameters of slashing module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slashingParams(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethod>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).slashingParams(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary DelegatorValidators queries all validators info for given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingDelegatorValidators(delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20062>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).stakingDelegatorValidators(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Parameters queries the staking parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingParams(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20065>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).stakingParams(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary SupplyOf queries the supply of a single coin.
         * @param {string} denom denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplyOf(denom: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20030>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).supplyOf(denom, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary TallyResult queries the tally of a proposal vote.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tallyResult(proposalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20052>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).tallyResult(proposalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary TotalSupply queries the total supply of all coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async totalSupply(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCMethod>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).totalSupply(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary UnbondingDelegation queries unbonding info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unbondingDelegation(validatorAddr: string, delegatorAddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20068>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).unbondingDelegation(validatorAddr, delegatorAddr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary UnreceivedAcks returns all the unreceived IBC acknowledgements associated with a channel and sequences.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {Array<string>} packetAckSequences list of acknowledgement sequences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unreceivedAcks(channelId: string, portId: string, packetAckSequences: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryUnreceivedAcksResponseIsTheResponseTypeForTheQueryUnreceivedAcksRPCMethod>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).unreceivedAcks(channelId, portId, packetAckSequences, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary UnreceivedPackets returns all the unreceived IBC packets associated with a channel and sequences.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {Array<string>} packetCommitmentSequences list of packet sequences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unreceivedPackets(channelId: string, portId: string, packetCommitmentSequences: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryUnreceivedPacketsResponseIsTheResponseTypeForTheQueryUnreceivedPacketCommitmentsRPCMethod>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).unreceivedPackets(channelId, portId, packetCommitmentSequences, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary UpgradedConsensusState queries the consensus state that will serve as a trusted kernel for the next version of this chain. It will only be stored at the last height of this chain. UpgradedConsensusState RPC not supported with legacy querier
         * @param {string} lastHeight last height of the current chain must be sent in request as this is the height under which next consensus state is stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upgradedConsensusState(lastHeight: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20074>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).upgradedConsensusState(lastHeight, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Validator queries validator info for given validator address.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validator(validatorAddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryValidatorResponseIsResponseTypeForTheQueryValidatorRPCMethod>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).validator(validatorAddr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary ValidatorCommission queries accumulated commission for a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorCommission(validatorAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethod>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).validatorCommission(validatorAddress, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary ValidatorDelegations queries delegate info for given validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorDelegations(validatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryValidatorDelegationsResponseIsResponseTypeForTheQueryValidatorDelegationsRPCMethod>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).validatorDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary ValidatorOutstandingRewards queries rewards of a validator address.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorOutstandingRewards(validatorAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20043>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).validatorOutstandingRewards(validatorAddress, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary ValidatorSlashes queries slash events of a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {string} [startingHeight] starting_height defines the optional starting height to query the slashes.
         * @param {string} [endingHeight] starting_height defines the optional ending height to query the slashes.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorSlashes(validatorAddress: string, startingHeight?: string, endingHeight?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20044>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).validatorSlashes(validatorAddress, startingHeight, endingHeight, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary ValidatorUnbondingDelegations queries unbonding delegations of a validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorUnbondingDelegations(validatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20069>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).validatorUnbondingDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Validators queries all validators that match the given status.
         * @param {string} [status] status enables to query for validators matching a given status.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validators(status?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryValidatorsResponseIsResponseTypeForTheQueryValidatorsRPCMethod>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).validators(status, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Vote queries voted information based on proposalID, voterAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} voter voter defines the oter address for the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vote(proposalId: string, voter: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20054>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).vote(proposalId, voter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Votes queries votes of a given proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async votes(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20053>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).votes(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Account returns account details based on address.
         * @param {string} address address defines the address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        account(address: string, options?: any): AxiosPromise<InlineResponse20025> {
            return QueryApiFp(configuration).account(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary AllBalances queries the balance of all coins for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allBalances(address: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20027> {
            return QueryApiFp(configuration).allBalances(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary AllEvidence queries all evidence.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allEvidence(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20045> {
            return QueryApiFp(configuration).allEvidence(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary AnnualProvisions current minting annual provisions value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annualProvisions(options?: any): AxiosPromise<InlineResponse20055> {
            return QueryApiFp(configuration).annualProvisions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary AppliedPlan queries a previously applied upgrade plan by its name.
         * @param {string} name name is the name of the applied plan to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appliedPlan(name: string, options?: any): AxiosPromise<InlineResponse20072> {
            return QueryApiFp(configuration).appliedPlan(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Params queries all parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authParams(options?: any): AxiosPromise<InlineResponse20026> {
            return QueryApiFp(configuration).authParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Balance queries the balance of a single coin for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} denom denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balance(address: string, denom: string, options?: any): AxiosPromise<InlineResponse20028> {
            return QueryApiFp(configuration).balance(address, denom, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Params queries the parameters of x/bank module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankParams(options?: any): AxiosPromise<InlineResponse20029> {
            return QueryApiFp(configuration).bankParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Channel queries an IBC Channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channel(channelId: string, portId: string, options?: any): AxiosPromise<InlineResponse20076> {
            return QueryApiFp(configuration).channel(channelId, portId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ChannelClientState queries for the client state for the channel associated with the provided channel identifiers.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelClientState(channelId: string, portId: string, options?: any): AxiosPromise<QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod> {
            return QueryApiFp(configuration).channelClientState(channelId, portId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ChannelConsensusState queries for the consensus state for the channel associated with the provided channel identifiers.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} revisionNumber revision number of the consensus state
         * @param {string} revisionHeight revision height of the consensus state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelConsensusState(channelId: string, portId: string, revisionNumber: string, revisionHeight: string, options?: any): AxiosPromise<QueryChannelClientStateResponseIsTheResponseTypeForTheQueryQueryChannelClientStateRPCMethod1> {
            return QueryApiFp(configuration).channelConsensusState(channelId, portId, revisionNumber, revisionHeight, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Channels queries all the IBC channels of a chain.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channels(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20075> {
            return QueryApiFp(configuration).channels(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ClientConnections queries the connection paths associated with a client state.
         * @param {string} clientId client identifier associated with a connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientConnections(clientId: string, options?: any): AxiosPromise<QueryClientConnectionsResponseIsTheResponseTypeForTheQueryClientConnectionsRPCMethod> {
            return QueryApiFp(configuration).clientConnections(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ClientParams queries all parameters of the ibc client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientParams(options?: any): AxiosPromise<InlineResponse20077> {
            return QueryApiFp(configuration).clientParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ClientState queries an IBC light client.
         * @param {string} clientId client state unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientState(clientId: string, options?: any): AxiosPromise<InlineResponse20079> {
            return QueryApiFp(configuration).clientState(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ClientStates queries all the IBC light clients of a chain.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientStates(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20078> {
            return QueryApiFp(configuration).clientStates(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary CommunityPool queries the community pool coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityPool(options?: any): AxiosPromise<InlineResponse20037> {
            return QueryApiFp(configuration).communityPool(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Connection queries an IBC connection end.
         * @param {string} connectionId connection unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connection(connectionId: string, options?: any): AxiosPromise<InlineResponse20081> {
            return QueryApiFp(configuration).connection(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ConnectionChannels queries all the channels associated with a connection end.
         * @param {string} connection connection unique identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionChannels(connection: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<QueryConnectionChannelsResponseIsTheResponseTypeForTheQueryQueryConnectionChannelsRPCMethod> {
            return QueryApiFp(configuration).connectionChannels(connection, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ConnectionClientState queries the client state associated with the connection.
         * @param {string} connectionId connection identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionClientState(connectionId: string, options?: any): AxiosPromise<QueryConnectionClientStateResponseIsTheResponseTypeForTheQueryConnectionClientStateRPCMethod> {
            return QueryApiFp(configuration).connectionClientState(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ConnectionConsensusState queries the consensus state associated with the connection.
         * @param {string} connectionId connection identifier
         * @param {string} revisionNumber 
         * @param {string} revisionHeight 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionConsensusState(connectionId: string, revisionNumber: string, revisionHeight: string, options?: any): AxiosPromise<QueryConnectionConsensusStateResponseIsTheResponseTypeForTheQueryConnectionConsensusStateRPCMethod> {
            return QueryApiFp(configuration).connectionConsensusState(connectionId, revisionNumber, revisionHeight, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Connections queries all the IBC connections of a chain.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connections(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20080> {
            return QueryApiFp(configuration).connections(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ConsensusState queries a consensus state associated with a client state at a given height.
         * @param {string} clientId client identifier
         * @param {string} revisionNumber consensus state revision number
         * @param {string} revisionHeight consensus state revision height
         * @param {boolean} [latestHeight] latest_height overrrides the height field and queries the latest stored ConsensusState.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consensusState(clientId: string, revisionNumber: string, revisionHeight: string, latestHeight?: boolean, options?: any): AxiosPromise<QueryConsensusStateResponseIsTheResponseTypeForTheQueryConsensusStateRPCMethod> {
            return QueryApiFp(configuration).consensusState(clientId, revisionNumber, revisionHeight, latestHeight, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ConsensusStates queries all the consensus state associated with a given client.
         * @param {string} clientId client identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consensusStates(clientId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<QueryConsensusStatesResponseIsTheResponseTypeForTheQueryConsensusStatesRPCMethod> {
            return QueryApiFp(configuration).consensusStates(clientId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary CurrentPlan queries the current upgrade plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentPlan(options?: any): AxiosPromise<InlineResponse20073> {
            return QueryApiFp(configuration).currentPlan(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delegation queries delegate info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegation(validatorAddr: string, delegatorAddr: string, options?: any): AxiosPromise<InlineResponse20067> {
            return QueryApiFp(configuration).delegation(validatorAddr, delegatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DelegationRewards queries the total rewards accrued by a delegation.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegationRewards(delegatorAddress: string, validatorAddress: string, options?: any): AxiosPromise<InlineResponse20039> {
            return QueryApiFp(configuration).delegationRewards(delegatorAddress, validatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DelegationTotalRewards queries the total rewards accrued by a each validator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegationTotalRewards(delegatorAddress: string, options?: any): AxiosPromise<InlineResponse20038> {
            return QueryApiFp(configuration).delegationTotalRewards(delegatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DelegatorDelegations queries all delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorDelegations(delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20059> {
            return QueryApiFp(configuration).delegatorDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DelegatorUnbondingDelegations queries all unbonding delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorUnbondingDelegations(delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20061> {
            return QueryApiFp(configuration).delegatorUnbondingDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DelegatorValidator queries validator info for given delegator validator pair.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorValidator(delegatorAddr: string, validatorAddr: string, options?: any): AxiosPromise<InlineResponse20063> {
            return QueryApiFp(configuration).delegatorValidator(delegatorAddr, validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DelegatorValidators queries the validators of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorValidators(delegatorAddress: string, options?: any): AxiosPromise<InlineResponse20040> {
            return QueryApiFp(configuration).delegatorValidators(delegatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DelegatorWithdrawAddress queries withdraw address of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorWithdrawAddress(delegatorAddress: string, options?: any): AxiosPromise<InlineResponse20041> {
            return QueryApiFp(configuration).delegatorWithdrawAddress(delegatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DenomTrace queries a denomination trace information.
         * @param {string} hash hash (in hex format) of the denomination trace information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomTrace(hash: string, options?: any): AxiosPromise<InlineResponse20083> {
            return QueryApiFp(configuration).denomTrace(hash, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DenomTraces queries all denomination traces.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomTraces(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20082> {
            return QueryApiFp(configuration).denomTraces(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deposit queries single deposit information based proposalID, depositAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} depositor depositor defines the deposit addresses from the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit(proposalId: string, depositor: string, options?: any): AxiosPromise<InlineResponse20051> {
            return QueryApiFp(configuration).deposit(proposalId, depositor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deposits queries all deposits of a single proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposits(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20050> {
            return QueryApiFp(configuration).deposits(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Params queries params of the distribution module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionParams(options?: any): AxiosPromise<InlineResponse20042> {
            return QueryApiFp(configuration).distributionParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Evidence queries evidence based on evidence hash.
         * @param {string} evidenceHash evidence_hash defines the hash of the requested evidence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evidence(evidenceHash: string, options?: any): AxiosPromise<InlineResponse20046> {
            return QueryApiFp(configuration).evidence(evidenceHash, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Params queries all parameters of the gov module.
         * @param {string} paramsType params_type defines which parameters to query for, can be one of \&quot;voting\&quot;, \&quot;tallying\&quot; or \&quot;deposit\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParams(paramsType: string, options?: any): AxiosPromise<InlineResponse20047> {
            return QueryApiFp(configuration).govParams(paramsType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary HistoricalInfo queries the historical info for given height.
         * @param {string} height height defines at which height to query the historical info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicalInfo(height: string, options?: any): AxiosPromise<InlineResponse20064> {
            return QueryApiFp(configuration).historicalInfo(height, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Params queries all parameters of the ibc-transfer module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iBCTransferParams(options?: any): AxiosPromise<InlineResponse20084> {
            return QueryApiFp(configuration).iBCTransferParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inflation returns the current minting inflation value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inflation(options?: any): AxiosPromise<InlineResponse20056> {
            return QueryApiFp(configuration).inflation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Params returns the total set of minting parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintParams(options?: any): AxiosPromise<InlineResponse20057> {
            return QueryApiFp(configuration).mintParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary NextSequenceReceive returns the next receive sequence for a given channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nextSequenceReceive(channelId: string, portId: string, options?: any): AxiosPromise<QuerySequenceResponseIsTheRequestTypeForTheQueryQueryNextSequenceReceiveResponseRPCMethod> {
            return QueryApiFp(configuration).nextSequenceReceive(channelId, portId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PacketAcknowledgement queries a stored packet acknowledgement hash.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} sequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packetAcknowledgement(channelId: string, portId: string, sequence: string, options?: any): AxiosPromise<QueryPacketAcknowledgementResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved> {
            return QueryApiFp(configuration).packetAcknowledgement(channelId, portId, sequence, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PacketAcknowledgements returns all the packet acknowledgements associated with a channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packetAcknowledgements(channelId: string, portId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<QueryPacketAcknowledgemetsResponseIsTheRequestTypeForTheQueryQueryPacketAcknowledgementsRPCMethod> {
            return QueryApiFp(configuration).packetAcknowledgements(channelId, portId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PacketCommitment queries a stored packet commitment hash.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} sequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packetCommitment(channelId: string, portId: string, sequence: string, options?: any): AxiosPromise<QueryPacketCommitmentResponseDefinesTheClientQueryResponseForAPacketWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved> {
            return QueryApiFp(configuration).packetCommitment(channelId, portId, sequence, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PacketCommitments returns all the packet commitments hashes associated with a channel.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packetCommitments(channelId: string, portId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<QueryPacketCommitmentsResponseIsTheRequestTypeForTheQueryQueryPacketCommitmentsRPCMethod> {
            return QueryApiFp(configuration).packetCommitments(channelId, portId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PacketReceipt queries if a given packet sequence has been received on the queried chain
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {string} sequence packet sequence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packetReceipt(channelId: string, portId: string, sequence: string, options?: any): AxiosPromise<QueryPacketReceiptResponseDefinesTheClientQueryResponseForAPacketReceiptWhichAlsoIncludesAProofAndTheHeightFromWhichTheProofWasRetrieved> {
            return QueryApiFp(configuration).packetReceipt(channelId, portId, sequence, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Params queries a specific parameter of a module, given its subspace and key.
         * @param {string} [subspace] subspace defines the module to query the parameter for.
         * @param {string} [key] key defines the key of the parameter in the subspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        params(subspace?: string, key?: string, options?: any): AxiosPromise<InlineResponse20058> {
            return QueryApiFp(configuration).params(subspace, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pool queries the pool info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pool(options?: any): AxiosPromise<InlineResponse20066> {
            return QueryApiFp(configuration).pool(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Proposal queries proposal details based on ProposalID.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proposal(proposalId: string, options?: any): AxiosPromise<InlineResponse20049> {
            return QueryApiFp(configuration).proposal(proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Proposals queries all proposals based on given status.
         * @param {'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED'} [proposalStatus] proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
         * @param {string} [voter] voter defines the voter address for the proposals.
         * @param {string} [depositor] depositor defines the deposit addresses from the proposals.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proposals(proposalStatus?: 'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED', voter?: string, depositor?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20048> {
            return QueryApiFp(configuration).proposals(proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redelegations queries redelegations of given address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [srcValidatorAddr] src_validator_addr defines the validator address to redelegate from.
         * @param {string} [dstValidatorAddr] dst_validator_addr defines the validator address to redelegate to.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redelegations(delegatorAddr: string, srcValidatorAddr?: string, dstValidatorAddr?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20060> {
            return QueryApiFp(configuration).redelegations(delegatorAddr, srcValidatorAddr, dstValidatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary SigningInfo queries the signing info of given cons address
         * @param {string} consAddress cons_address is the address to query signing info of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signingInfo(consAddress: string, options?: any): AxiosPromise<QuerySigningInfoResponseIsTheResponseTypeForTheQuerySigningInfoRPCMethod> {
            return QueryApiFp(configuration).signingInfo(consAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary SigningInfos queries signing info of all validators
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signingInfos(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethod> {
            return QueryApiFp(configuration).signingInfos(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Params queries the parameters of slashing module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingParams(options?: any): AxiosPromise<QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethod> {
            return QueryApiFp(configuration).slashingParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DelegatorValidators queries all validators info for given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorValidators(delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20062> {
            return QueryApiFp(configuration).stakingDelegatorValidators(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Parameters queries the staking parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingParams(options?: any): AxiosPromise<InlineResponse20065> {
            return QueryApiFp(configuration).stakingParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary SupplyOf queries the supply of a single coin.
         * @param {string} denom denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplyOf(denom: string, options?: any): AxiosPromise<InlineResponse20030> {
            return QueryApiFp(configuration).supplyOf(denom, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary TallyResult queries the tally of a proposal vote.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tallyResult(proposalId: string, options?: any): AxiosPromise<InlineResponse20052> {
            return QueryApiFp(configuration).tallyResult(proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary TotalSupply queries the total supply of all coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalSupply(options?: any): AxiosPromise<QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCMethod> {
            return QueryApiFp(configuration).totalSupply(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary UnbondingDelegation queries unbonding info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbondingDelegation(validatorAddr: string, delegatorAddr: string, options?: any): AxiosPromise<InlineResponse20068> {
            return QueryApiFp(configuration).unbondingDelegation(validatorAddr, delegatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary UnreceivedAcks returns all the unreceived IBC acknowledgements associated with a channel and sequences.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {Array<string>} packetAckSequences list of acknowledgement sequences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unreceivedAcks(channelId: string, portId: string, packetAckSequences: Array<string>, options?: any): AxiosPromise<QueryUnreceivedAcksResponseIsTheResponseTypeForTheQueryUnreceivedAcksRPCMethod> {
            return QueryApiFp(configuration).unreceivedAcks(channelId, portId, packetAckSequences, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary UnreceivedPackets returns all the unreceived IBC packets associated with a channel and sequences.
         * @param {string} channelId channel unique identifier
         * @param {string} portId port unique identifier
         * @param {Array<string>} packetCommitmentSequences list of packet sequences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unreceivedPackets(channelId: string, portId: string, packetCommitmentSequences: Array<string>, options?: any): AxiosPromise<QueryUnreceivedPacketsResponseIsTheResponseTypeForTheQueryUnreceivedPacketCommitmentsRPCMethod> {
            return QueryApiFp(configuration).unreceivedPackets(channelId, portId, packetCommitmentSequences, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary UpgradedConsensusState queries the consensus state that will serve as a trusted kernel for the next version of this chain. It will only be stored at the last height of this chain. UpgradedConsensusState RPC not supported with legacy querier
         * @param {string} lastHeight last height of the current chain must be sent in request as this is the height under which next consensus state is stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradedConsensusState(lastHeight: string, options?: any): AxiosPromise<InlineResponse20074> {
            return QueryApiFp(configuration).upgradedConsensusState(lastHeight, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validator queries validator info for given validator address.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validator(validatorAddr: string, options?: any): AxiosPromise<QueryValidatorResponseIsResponseTypeForTheQueryValidatorRPCMethod> {
            return QueryApiFp(configuration).validator(validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ValidatorCommission queries accumulated commission for a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorCommission(validatorAddress: string, options?: any): AxiosPromise<QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethod> {
            return QueryApiFp(configuration).validatorCommission(validatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ValidatorDelegations queries delegate info for given validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorDelegations(validatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<QueryValidatorDelegationsResponseIsResponseTypeForTheQueryValidatorDelegationsRPCMethod> {
            return QueryApiFp(configuration).validatorDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ValidatorOutstandingRewards queries rewards of a validator address.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorOutstandingRewards(validatorAddress: string, options?: any): AxiosPromise<InlineResponse20043> {
            return QueryApiFp(configuration).validatorOutstandingRewards(validatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ValidatorSlashes queries slash events of a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {string} [startingHeight] starting_height defines the optional starting height to query the slashes.
         * @param {string} [endingHeight] starting_height defines the optional ending height to query the slashes.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorSlashes(validatorAddress: string, startingHeight?: string, endingHeight?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20044> {
            return QueryApiFp(configuration).validatorSlashes(validatorAddress, startingHeight, endingHeight, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ValidatorUnbondingDelegations queries unbonding delegations of a validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorUnbondingDelegations(validatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20069> {
            return QueryApiFp(configuration).validatorUnbondingDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validators queries all validators that match the given status.
         * @param {string} [status] status enables to query for validators matching a given status.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validators(status?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<QueryValidatorsResponseIsResponseTypeForTheQueryValidatorsRPCMethod> {
            return QueryApiFp(configuration).validators(status, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Vote queries voted information based on proposalID, voterAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} voter voter defines the oter address for the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vote(proposalId: string, voter: string, options?: any): AxiosPromise<InlineResponse20054> {
            return QueryApiFp(configuration).vote(proposalId, voter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Votes queries votes of a given proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votes(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20053> {
            return QueryApiFp(configuration).votes(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     * 
     * @summary Account returns account details based on address.
     * @param {string} address address defines the address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public account(address: string, options?: any) {
        return QueryApiFp(this.configuration).account(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary AllBalances queries the balance of all coins for a single account.
     * @param {string} address address is the address to query balances for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public allBalances(address: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).allBalances(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary AllEvidence queries all evidence.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public allEvidence(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).allEvidence(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary AnnualProvisions current minting annual provisions value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public annualProvisions(options?: any) {
        return QueryApiFp(this.configuration).annualProvisions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary AppliedPlan queries a previously applied upgrade plan by its name.
     * @param {string} name name is the name of the applied plan to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public appliedPlan(name: string, options?: any) {
        return QueryApiFp(this.configuration).appliedPlan(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Params queries all parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public authParams(options?: any) {
        return QueryApiFp(this.configuration).authParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Balance queries the balance of a single coin for a single account.
     * @param {string} address address is the address to query balances for.
     * @param {string} denom denom is the coin denom to query balances for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public balance(address: string, denom: string, options?: any) {
        return QueryApiFp(this.configuration).balance(address, denom, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Params queries the parameters of x/bank module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public bankParams(options?: any) {
        return QueryApiFp(this.configuration).bankParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Channel queries an IBC Channel.
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public channel(channelId: string, portId: string, options?: any) {
        return QueryApiFp(this.configuration).channel(channelId, portId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ChannelClientState queries for the client state for the channel associated with the provided channel identifiers.
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public channelClientState(channelId: string, portId: string, options?: any) {
        return QueryApiFp(this.configuration).channelClientState(channelId, portId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ChannelConsensusState queries for the consensus state for the channel associated with the provided channel identifiers.
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {string} revisionNumber revision number of the consensus state
     * @param {string} revisionHeight revision height of the consensus state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public channelConsensusState(channelId: string, portId: string, revisionNumber: string, revisionHeight: string, options?: any) {
        return QueryApiFp(this.configuration).channelConsensusState(channelId, portId, revisionNumber, revisionHeight, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Channels queries all the IBC channels of a chain.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public channels(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).channels(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ClientConnections queries the connection paths associated with a client state.
     * @param {string} clientId client identifier associated with a connection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public clientConnections(clientId: string, options?: any) {
        return QueryApiFp(this.configuration).clientConnections(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ClientParams queries all parameters of the ibc client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public clientParams(options?: any) {
        return QueryApiFp(this.configuration).clientParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ClientState queries an IBC light client.
     * @param {string} clientId client state unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public clientState(clientId: string, options?: any) {
        return QueryApiFp(this.configuration).clientState(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ClientStates queries all the IBC light clients of a chain.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public clientStates(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).clientStates(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary CommunityPool queries the community pool coins.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public communityPool(options?: any) {
        return QueryApiFp(this.configuration).communityPool(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Connection queries an IBC connection end.
     * @param {string} connectionId connection unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public connection(connectionId: string, options?: any) {
        return QueryApiFp(this.configuration).connection(connectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ConnectionChannels queries all the channels associated with a connection end.
     * @param {string} connection connection unique identifier
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public connectionChannels(connection: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).connectionChannels(connection, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ConnectionClientState queries the client state associated with the connection.
     * @param {string} connectionId connection identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public connectionClientState(connectionId: string, options?: any) {
        return QueryApiFp(this.configuration).connectionClientState(connectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ConnectionConsensusState queries the consensus state associated with the connection.
     * @param {string} connectionId connection identifier
     * @param {string} revisionNumber 
     * @param {string} revisionHeight 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public connectionConsensusState(connectionId: string, revisionNumber: string, revisionHeight: string, options?: any) {
        return QueryApiFp(this.configuration).connectionConsensusState(connectionId, revisionNumber, revisionHeight, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Connections queries all the IBC connections of a chain.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public connections(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).connections(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ConsensusState queries a consensus state associated with a client state at a given height.
     * @param {string} clientId client identifier
     * @param {string} revisionNumber consensus state revision number
     * @param {string} revisionHeight consensus state revision height
     * @param {boolean} [latestHeight] latest_height overrrides the height field and queries the latest stored ConsensusState.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public consensusState(clientId: string, revisionNumber: string, revisionHeight: string, latestHeight?: boolean, options?: any) {
        return QueryApiFp(this.configuration).consensusState(clientId, revisionNumber, revisionHeight, latestHeight, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ConsensusStates queries all the consensus state associated with a given client.
     * @param {string} clientId client identifier
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public consensusStates(clientId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).consensusStates(clientId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary CurrentPlan queries the current upgrade plan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public currentPlan(options?: any) {
        return QueryApiFp(this.configuration).currentPlan(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delegation queries delegate info for given validator delegator pair.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public delegation(validatorAddr: string, delegatorAddr: string, options?: any) {
        return QueryApiFp(this.configuration).delegation(validatorAddr, delegatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DelegationRewards queries the total rewards accrued by a delegation.
     * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
     * @param {string} validatorAddress validator_address defines the validator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public delegationRewards(delegatorAddress: string, validatorAddress: string, options?: any) {
        return QueryApiFp(this.configuration).delegationRewards(delegatorAddress, validatorAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DelegationTotalRewards queries the total rewards accrued by a each validator.
     * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public delegationTotalRewards(delegatorAddress: string, options?: any) {
        return QueryApiFp(this.configuration).delegationTotalRewards(delegatorAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DelegatorDelegations queries all delegations of a given delegator address.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public delegatorDelegations(delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).delegatorDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DelegatorUnbondingDelegations queries all unbonding delegations of a given delegator address.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public delegatorUnbondingDelegations(delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).delegatorUnbondingDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DelegatorValidator queries validator info for given delegator validator pair.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public delegatorValidator(delegatorAddr: string, validatorAddr: string, options?: any) {
        return QueryApiFp(this.configuration).delegatorValidator(delegatorAddr, validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DelegatorValidators queries the validators of a delegator.
     * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public delegatorValidators(delegatorAddress: string, options?: any) {
        return QueryApiFp(this.configuration).delegatorValidators(delegatorAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DelegatorWithdrawAddress queries withdraw address of a delegator.
     * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public delegatorWithdrawAddress(delegatorAddress: string, options?: any) {
        return QueryApiFp(this.configuration).delegatorWithdrawAddress(delegatorAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DenomTrace queries a denomination trace information.
     * @param {string} hash hash (in hex format) of the denomination trace information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public denomTrace(hash: string, options?: any) {
        return QueryApiFp(this.configuration).denomTrace(hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DenomTraces queries all denomination traces.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public denomTraces(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).denomTraces(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deposit queries single deposit information based proposalID, depositAddr.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {string} depositor depositor defines the deposit addresses from the proposals.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public deposit(proposalId: string, depositor: string, options?: any) {
        return QueryApiFp(this.configuration).deposit(proposalId, depositor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deposits queries all deposits of a single proposal.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public deposits(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).deposits(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Params queries params of the distribution module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public distributionParams(options?: any) {
        return QueryApiFp(this.configuration).distributionParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Evidence queries evidence based on evidence hash.
     * @param {string} evidenceHash evidence_hash defines the hash of the requested evidence.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public evidence(evidenceHash: string, options?: any) {
        return QueryApiFp(this.configuration).evidence(evidenceHash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Params queries all parameters of the gov module.
     * @param {string} paramsType params_type defines which parameters to query for, can be one of \&quot;voting\&quot;, \&quot;tallying\&quot; or \&quot;deposit\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public govParams(paramsType: string, options?: any) {
        return QueryApiFp(this.configuration).govParams(paramsType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary HistoricalInfo queries the historical info for given height.
     * @param {string} height height defines at which height to query the historical info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public historicalInfo(height: string, options?: any) {
        return QueryApiFp(this.configuration).historicalInfo(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Params queries all parameters of the ibc-transfer module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public iBCTransferParams(options?: any) {
        return QueryApiFp(this.configuration).iBCTransferParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inflation returns the current minting inflation value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public inflation(options?: any) {
        return QueryApiFp(this.configuration).inflation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Params returns the total set of minting parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public mintParams(options?: any) {
        return QueryApiFp(this.configuration).mintParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary NextSequenceReceive returns the next receive sequence for a given channel.
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public nextSequenceReceive(channelId: string, portId: string, options?: any) {
        return QueryApiFp(this.configuration).nextSequenceReceive(channelId, portId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PacketAcknowledgement queries a stored packet acknowledgement hash.
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {string} sequence packet sequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public packetAcknowledgement(channelId: string, portId: string, sequence: string, options?: any) {
        return QueryApiFp(this.configuration).packetAcknowledgement(channelId, portId, sequence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PacketAcknowledgements returns all the packet acknowledgements associated with a channel.
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public packetAcknowledgements(channelId: string, portId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).packetAcknowledgements(channelId, portId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PacketCommitment queries a stored packet commitment hash.
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {string} sequence packet sequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public packetCommitment(channelId: string, portId: string, sequence: string, options?: any) {
        return QueryApiFp(this.configuration).packetCommitment(channelId, portId, sequence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PacketCommitments returns all the packet commitments hashes associated with a channel.
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public packetCommitments(channelId: string, portId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).packetCommitments(channelId, portId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PacketReceipt queries if a given packet sequence has been received on the queried chain
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {string} sequence packet sequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public packetReceipt(channelId: string, portId: string, sequence: string, options?: any) {
        return QueryApiFp(this.configuration).packetReceipt(channelId, portId, sequence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Params queries a specific parameter of a module, given its subspace and key.
     * @param {string} [subspace] subspace defines the module to query the parameter for.
     * @param {string} [key] key defines the key of the parameter in the subspace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public params(subspace?: string, key?: string, options?: any) {
        return QueryApiFp(this.configuration).params(subspace, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pool queries the pool info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public pool(options?: any) {
        return QueryApiFp(this.configuration).pool(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Proposal queries proposal details based on ProposalID.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public proposal(proposalId: string, options?: any) {
        return QueryApiFp(this.configuration).proposal(proposalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Proposals queries all proposals based on given status.
     * @param {'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED'} [proposalStatus] proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
     * @param {string} [voter] voter defines the voter address for the proposals.
     * @param {string} [depositor] depositor defines the deposit addresses from the proposals.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public proposals(proposalStatus?: 'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED', voter?: string, depositor?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).proposals(proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redelegations queries redelegations of given address.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {string} [srcValidatorAddr] src_validator_addr defines the validator address to redelegate from.
     * @param {string} [dstValidatorAddr] dst_validator_addr defines the validator address to redelegate to.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public redelegations(delegatorAddr: string, srcValidatorAddr?: string, dstValidatorAddr?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).redelegations(delegatorAddr, srcValidatorAddr, dstValidatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary SigningInfo queries the signing info of given cons address
     * @param {string} consAddress cons_address is the address to query signing info of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public signingInfo(consAddress: string, options?: any) {
        return QueryApiFp(this.configuration).signingInfo(consAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary SigningInfos queries signing info of all validators
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public signingInfos(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).signingInfos(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Params queries the parameters of slashing module
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public slashingParams(options?: any) {
        return QueryApiFp(this.configuration).slashingParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DelegatorValidators queries all validators info for given delegator address.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public stakingDelegatorValidators(delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).stakingDelegatorValidators(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Parameters queries the staking parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public stakingParams(options?: any) {
        return QueryApiFp(this.configuration).stakingParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary SupplyOf queries the supply of a single coin.
     * @param {string} denom denom is the coin denom to query balances for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public supplyOf(denom: string, options?: any) {
        return QueryApiFp(this.configuration).supplyOf(denom, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary TallyResult queries the tally of a proposal vote.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public tallyResult(proposalId: string, options?: any) {
        return QueryApiFp(this.configuration).tallyResult(proposalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary TotalSupply queries the total supply of all coins.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public totalSupply(options?: any) {
        return QueryApiFp(this.configuration).totalSupply(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary UnbondingDelegation queries unbonding info for given validator delegator pair.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public unbondingDelegation(validatorAddr: string, delegatorAddr: string, options?: any) {
        return QueryApiFp(this.configuration).unbondingDelegation(validatorAddr, delegatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary UnreceivedAcks returns all the unreceived IBC acknowledgements associated with a channel and sequences.
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {Array<string>} packetAckSequences list of acknowledgement sequences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public unreceivedAcks(channelId: string, portId: string, packetAckSequences: Array<string>, options?: any) {
        return QueryApiFp(this.configuration).unreceivedAcks(channelId, portId, packetAckSequences, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary UnreceivedPackets returns all the unreceived IBC packets associated with a channel and sequences.
     * @param {string} channelId channel unique identifier
     * @param {string} portId port unique identifier
     * @param {Array<string>} packetCommitmentSequences list of packet sequences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public unreceivedPackets(channelId: string, portId: string, packetCommitmentSequences: Array<string>, options?: any) {
        return QueryApiFp(this.configuration).unreceivedPackets(channelId, portId, packetCommitmentSequences, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary UpgradedConsensusState queries the consensus state that will serve as a trusted kernel for the next version of this chain. It will only be stored at the last height of this chain. UpgradedConsensusState RPC not supported with legacy querier
     * @param {string} lastHeight last height of the current chain must be sent in request as this is the height under which next consensus state is stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public upgradedConsensusState(lastHeight: string, options?: any) {
        return QueryApiFp(this.configuration).upgradedConsensusState(lastHeight, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validator queries validator info for given validator address.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public validator(validatorAddr: string, options?: any) {
        return QueryApiFp(this.configuration).validator(validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ValidatorCommission queries accumulated commission for a validator.
     * @param {string} validatorAddress validator_address defines the validator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public validatorCommission(validatorAddress: string, options?: any) {
        return QueryApiFp(this.configuration).validatorCommission(validatorAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ValidatorDelegations queries delegate info for given validator.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public validatorDelegations(validatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).validatorDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ValidatorOutstandingRewards queries rewards of a validator address.
     * @param {string} validatorAddress validator_address defines the validator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public validatorOutstandingRewards(validatorAddress: string, options?: any) {
        return QueryApiFp(this.configuration).validatorOutstandingRewards(validatorAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ValidatorSlashes queries slash events of a validator.
     * @param {string} validatorAddress validator_address defines the validator address to query for.
     * @param {string} [startingHeight] starting_height defines the optional starting height to query the slashes.
     * @param {string} [endingHeight] starting_height defines the optional ending height to query the slashes.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public validatorSlashes(validatorAddress: string, startingHeight?: string, endingHeight?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).validatorSlashes(validatorAddress, startingHeight, endingHeight, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ValidatorUnbondingDelegations queries unbonding delegations of a validator.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public validatorUnbondingDelegations(validatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).validatorUnbondingDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validators queries all validators that match the given status.
     * @param {string} [status] status enables to query for validators matching a given status.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public validators(status?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).validators(status, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Vote queries voted information based on proposalID, voterAddr.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {string} voter voter defines the oter address for the proposals.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public vote(proposalId: string, voter: string, options?: any) {
        return QueryApiFp(this.configuration).vote(proposalId, voter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Votes queries votes of a given proposal.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public votes(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).votes(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceApi - axios parameter creator
 * @export
 */
export const ServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary BroadcastTx broadcast transaction.
         * @param {InlineObject16} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTx: async (body: InlineObject16, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling broadcastTx.');
            }
            const localVarPath = `/cosmos/tx/v1beta1/txs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetBlockByHeight queries block for given height.
         * @param {string} height 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHeight: async (height: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            if (height === null || height === undefined) {
                throw new RequiredError('height','Required parameter height was null or undefined when calling getBlockByHeight.');
            }
            const localVarPath = `/cosmos/base/tendermint/v1beta1/blocks/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetLatestBlock returns the latest block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBlock: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/base/tendermint/v1beta1/blocks/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetLatestValidatorSet queries latest validator-set.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestValidatorSet: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/base/tendermint/v1beta1/validatorsets/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetNodeInfo queries the current node info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/base/tendermint/v1beta1/node_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetSyncing queries node syncing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncing: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/base/tendermint/v1beta1/syncing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetTx fetches a tx by hash.
         * @param {string} hash hash is the tx hash to query, encoded as a hex string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx: async (hash: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling getTx.');
            }
            const localVarPath = `/cosmos/tx/v1beta1/txs/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetTxsEvent fetches txs by event.
         * @param {Array<string>} [events] events is the list of transaction event type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsEvent: async (events?: Array<string>, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/tx/v1beta1/txs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (events) {
                localVarQueryParameter['events'] = events;
            }

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetValidatorSetByHeight queries validator-set at a given height.
         * @param {string} height 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidatorSetByHeight: async (height: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            if (height === null || height === undefined) {
                throw new RequiredError('height','Required parameter height was null or undefined when calling getValidatorSetByHeight.');
            }
            const localVarPath = `/cosmos/base/tendermint/v1beta1/validatorsets/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulate simulates executing a transaction for estimating gas usage.
         * @param {CosmosTxV1beta1SimulateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulate: async (body: CosmosTxV1beta1SimulateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling simulate.');
            }
            const localVarPath = `/cosmos/tx/v1beta1/simulate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceApi - functional programming interface
 * @export
 */
export const ServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary BroadcastTx broadcast transaction.
         * @param {InlineObject16} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async broadcastTx(body: InlineObject16, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20071>> {
            const localVarAxiosArgs = await ServiceApiAxiosParamCreator(configuration).broadcastTx(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary GetBlockByHeight queries block for given height.
         * @param {string} height 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHeight(height: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20032>> {
            const localVarAxiosArgs = await ServiceApiAxiosParamCreator(configuration).getBlockByHeight(height, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary GetLatestBlock returns the latest block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestBlock(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20031>> {
            const localVarAxiosArgs = await ServiceApiAxiosParamCreator(configuration).getLatestBlock(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary GetLatestValidatorSet queries latest validator-set.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestValidatorSet(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20035>> {
            const localVarAxiosArgs = await ServiceApiAxiosParamCreator(configuration).getLatestValidatorSet(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary GetNodeInfo queries the current node info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20033>> {
            const localVarAxiosArgs = await ServiceApiAxiosParamCreator(configuration).getNodeInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary GetSyncing queries node syncing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSyncing(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20034>> {
            const localVarAxiosArgs = await ServiceApiAxiosParamCreator(configuration).getSyncing(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary GetTx fetches a tx by hash.
         * @param {string} hash hash is the tx hash to query, encoded as a hex string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTx(hash: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CosmosTxV1beta1GetTxResponse>> {
            const localVarAxiosArgs = await ServiceApiAxiosParamCreator(configuration).getTx(hash, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary GetTxsEvent fetches txs by event.
         * @param {Array<string>} [events] events is the list of transaction event type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxsEvent(events?: Array<string>, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CosmosTxV1beta1GetTxsEventResponse>> {
            const localVarAxiosArgs = await ServiceApiAxiosParamCreator(configuration).getTxsEvent(events, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary GetValidatorSetByHeight queries validator-set at a given height.
         * @param {string} height 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidatorSetByHeight(height: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20036>> {
            const localVarAxiosArgs = await ServiceApiAxiosParamCreator(configuration).getValidatorSetByHeight(height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Simulate simulates executing a transaction for estimating gas usage.
         * @param {CosmosTxV1beta1SimulateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulate(body: CosmosTxV1beta1SimulateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20070>> {
            const localVarAxiosArgs = await ServiceApiAxiosParamCreator(configuration).simulate(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ServiceApi - factory interface
 * @export
 */
export const ServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary BroadcastTx broadcast transaction.
         * @param {InlineObject16} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTx(body: InlineObject16, options?: any): AxiosPromise<InlineResponse20071> {
            return ServiceApiFp(configuration).broadcastTx(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GetBlockByHeight queries block for given height.
         * @param {string} height 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHeight(height: string, options?: any): AxiosPromise<InlineResponse20032> {
            return ServiceApiFp(configuration).getBlockByHeight(height, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GetLatestBlock returns the latest block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBlock(options?: any): AxiosPromise<InlineResponse20031> {
            return ServiceApiFp(configuration).getLatestBlock(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GetLatestValidatorSet queries latest validator-set.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestValidatorSet(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20035> {
            return ServiceApiFp(configuration).getLatestValidatorSet(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GetNodeInfo queries the current node info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeInfo(options?: any): AxiosPromise<InlineResponse20033> {
            return ServiceApiFp(configuration).getNodeInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GetSyncing queries node syncing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncing(options?: any): AxiosPromise<InlineResponse20034> {
            return ServiceApiFp(configuration).getSyncing(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GetTx fetches a tx by hash.
         * @param {string} hash hash is the tx hash to query, encoded as a hex string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx(hash: string, options?: any): AxiosPromise<CosmosTxV1beta1GetTxResponse> {
            return ServiceApiFp(configuration).getTx(hash, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GetTxsEvent fetches txs by event.
         * @param {Array<string>} [events] events is the list of transaction event type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsEvent(events?: Array<string>, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<CosmosTxV1beta1GetTxsEventResponse> {
            return ServiceApiFp(configuration).getTxsEvent(events, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GetValidatorSetByHeight queries validator-set at a given height.
         * @param {string} height 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidatorSetByHeight(height: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20036> {
            return ServiceApiFp(configuration).getValidatorSetByHeight(height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Simulate simulates executing a transaction for estimating gas usage.
         * @param {CosmosTxV1beta1SimulateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulate(body: CosmosTxV1beta1SimulateRequest, options?: any): AxiosPromise<InlineResponse20070> {
            return ServiceApiFp(configuration).simulate(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceApi - object-oriented interface
 * @export
 * @class ServiceApi
 * @extends {BaseAPI}
 */
export class ServiceApi extends BaseAPI {
    /**
     * 
     * @summary BroadcastTx broadcast transaction.
     * @param {InlineObject16} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public broadcastTx(body: InlineObject16, options?: any) {
        return ServiceApiFp(this.configuration).broadcastTx(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GetBlockByHeight queries block for given height.
     * @param {string} height 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public getBlockByHeight(height: string, options?: any) {
        return ServiceApiFp(this.configuration).getBlockByHeight(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GetLatestBlock returns the latest block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public getLatestBlock(options?: any) {
        return ServiceApiFp(this.configuration).getLatestBlock(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GetLatestValidatorSet queries latest validator-set.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public getLatestValidatorSet(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return ServiceApiFp(this.configuration).getLatestValidatorSet(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GetNodeInfo queries the current node info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public getNodeInfo(options?: any) {
        return ServiceApiFp(this.configuration).getNodeInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GetSyncing queries node syncing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public getSyncing(options?: any) {
        return ServiceApiFp(this.configuration).getSyncing(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GetTx fetches a tx by hash.
     * @param {string} hash hash is the tx hash to query, encoded as a hex string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public getTx(hash: string, options?: any) {
        return ServiceApiFp(this.configuration).getTx(hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GetTxsEvent fetches txs by event.
     * @param {Array<string>} [events] events is the list of transaction event type.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public getTxsEvent(events?: Array<string>, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return ServiceApiFp(this.configuration).getTxsEvent(events, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GetValidatorSetByHeight queries validator-set at a given height.
     * @param {string} height 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public getValidatorSetByHeight(height: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return ServiceApiFp(this.configuration).getValidatorSetByHeight(height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Simulate simulates executing a transaction for estimating gas usage.
     * @param {CosmosTxV1beta1SimulateRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public simulate(body: CosmosTxV1beta1SimulateRequest, options?: any) {
        return ServiceApiFp(this.configuration).simulate(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SlashingApi - axios parameter creator
 * @export
 */
export const SlashingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the current slashing parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingParametersGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/slashing/parameters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get sign info of all validators
         * @summary Get sign info of given all validators
         * @param {number} page Page number
         * @param {number} limit Maximum number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingSigningInfosGet: async (page: number, limit: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling slashingSigningInfosGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling slashingSigningInfosGet.');
            }
            const localVarPath = `/slashing/signing_infos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Send transaction to unjail a jailed validator
         * @summary Unjail a jailed validator
         * @param {string} validatorAddr Bech32 validator address
         * @param {InlineObject7} unjailBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingValidatorsValidatorAddrUnjailPost: async (validatorAddr: string, unjailBody: InlineObject7, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddr' is not null or undefined
            if (validatorAddr === null || validatorAddr === undefined) {
                throw new RequiredError('validatorAddr','Required parameter validatorAddr was null or undefined when calling slashingValidatorsValidatorAddrUnjailPost.');
            }
            // verify required parameter 'unjailBody' is not null or undefined
            if (unjailBody === null || unjailBody === undefined) {
                throw new RequiredError('unjailBody','Required parameter unjailBody was null or undefined when calling slashingValidatorsValidatorAddrUnjailPost.');
            }
            const localVarPath = `/slashing/validators/{validatorAddr}/unjail`
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof unjailBody !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(unjailBody !== undefined ? unjailBody : {})
                : (unjailBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SlashingApi - functional programming interface
 * @export
 */
export const SlashingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the current slashing parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slashingParametersGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
            const localVarAxiosArgs = await SlashingApiAxiosParamCreator(configuration).slashingParametersGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get sign info of all validators
         * @summary Get sign info of given all validators
         * @param {number} page Page number
         * @param {number} limit Maximum number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slashingSigningInfosGet(page: number, limit: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20015>>> {
            const localVarAxiosArgs = await SlashingApiAxiosParamCreator(configuration).slashingSigningInfosGet(page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Send transaction to unjail a jailed validator
         * @summary Unjail a jailed validator
         * @param {string} validatorAddr Bech32 validator address
         * @param {InlineObject7} unjailBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slashingValidatorsValidatorAddrUnjailPost(validatorAddr: string, unjailBody: InlineObject7, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004Tx>> {
            const localVarAxiosArgs = await SlashingApiAxiosParamCreator(configuration).slashingValidatorsValidatorAddrUnjailPost(validatorAddr, unjailBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SlashingApi - factory interface
 * @export
 */
export const SlashingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get the current slashing parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingParametersGet(options?: any): AxiosPromise<InlineResponse20016> {
            return SlashingApiFp(configuration).slashingParametersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get sign info of all validators
         * @summary Get sign info of given all validators
         * @param {number} page Page number
         * @param {number} limit Maximum number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingSigningInfosGet(page: number, limit: number, options?: any): AxiosPromise<Array<InlineResponse20015>> {
            return SlashingApiFp(configuration).slashingSigningInfosGet(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Send transaction to unjail a jailed validator
         * @summary Unjail a jailed validator
         * @param {string} validatorAddr Bech32 validator address
         * @param {InlineObject7} unjailBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingValidatorsValidatorAddrUnjailPost(validatorAddr: string, unjailBody: InlineObject7, options?: any): AxiosPromise<InlineResponse2004Tx> {
            return SlashingApiFp(configuration).slashingValidatorsValidatorAddrUnjailPost(validatorAddr, unjailBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SlashingApi - object-oriented interface
 * @export
 * @class SlashingApi
 * @extends {BaseAPI}
 */
export class SlashingApi extends BaseAPI {
    /**
     * 
     * @summary Get the current slashing parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlashingApi
     */
    public slashingParametersGet(options?: any) {
        return SlashingApiFp(this.configuration).slashingParametersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get sign info of all validators
     * @summary Get sign info of given all validators
     * @param {number} page Page number
     * @param {number} limit Maximum number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlashingApi
     */
    public slashingSigningInfosGet(page: number, limit: number, options?: any) {
        return SlashingApiFp(this.configuration).slashingSigningInfosGet(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send transaction to unjail a jailed validator
     * @summary Unjail a jailed validator
     * @param {string} validatorAddr Bech32 validator address
     * @param {InlineObject7} unjailBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlashingApi
     */
    public slashingValidatorsValidatorAddrUnjailPost(validatorAddr: string, unjailBody: InlineObject7, options?: any) {
        return SlashingApiFp(this.configuration).slashingValidatorsValidatorAddrUnjailPost(validatorAddr, unjailBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StakingApi - axios parameter creator
 * @export
 */
export const StakingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all delegations from a delegator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsGet: async (delegatorAddr: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrDelegationsGet.');
            }
            const localVarPath = `/staking/delegators/{delegatorAddr}/delegations`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit delegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject4} [delegation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsPost: async (delegatorAddr: string, delegation?: InlineObject4, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrDelegationsPost.');
            }
            const localVarPath = `/staking/delegators/{delegatorAddr}/delegations`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof delegation !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(delegation !== undefined ? delegation : {})
                : (delegation || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query the current delegation between a delegator and a validator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet: async (delegatorAddr: string, validatorAddr: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet.');
            }
            // verify required parameter 'validatorAddr' is not null or undefined
            if (validatorAddr === null || validatorAddr === undefined) {
                throw new RequiredError('validatorAddr','Required parameter validatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet.');
            }
            const localVarPath = `/staking/delegators/{delegatorAddr}/delegations/{validatorAddr}`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)))
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit a redelegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject6} [delegation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrRedelegationsPost: async (delegatorAddr: string, delegation?: InlineObject6, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrRedelegationsPost.');
            }
            const localVarPath = `/staking/delegators/{delegatorAddr}/redelegations`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof delegation !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(delegation !== undefined ? delegation : {})
                : (delegation || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all unbonding delegations from a delegator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsGet: async (delegatorAddr: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrUnbondingDelegationsGet.');
            }
            const localVarPath = `/staking/delegators/{delegatorAddr}/unbonding_delegations`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit an unbonding delegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject5} [delegation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsPost: async (delegatorAddr: string, delegation?: InlineObject5, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrUnbondingDelegationsPost.');
            }
            const localVarPath = `/staking/delegators/{delegatorAddr}/unbonding_delegations`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof delegation !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(delegation !== undefined ? delegation : {})
                : (delegation || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query all unbonding delegations between a delegator and a validator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet: async (delegatorAddr: string, validatorAddr: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet.');
            }
            // verify required parameter 'validatorAddr' is not null or undefined
            if (validatorAddr === null || validatorAddr === undefined) {
                throw new RequiredError('validatorAddr','Required parameter validatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet.');
            }
            const localVarPath = `/staking/delegators/{delegatorAddr}/unbonding_delegations/{validatorAddr}`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)))
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query all validators that a delegator is bonded to
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrValidatorsGet: async (delegatorAddr: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrValidatorsGet.');
            }
            const localVarPath = `/staking/delegators/{delegatorAddr}/validators`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query a validator that a delegator is bonded to
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 ValAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet: async (delegatorAddr: string, validatorAddr: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            if (delegatorAddr === null || delegatorAddr === undefined) {
                throw new RequiredError('delegatorAddr','Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet.');
            }
            // verify required parameter 'validatorAddr' is not null or undefined
            if (validatorAddr === null || validatorAddr === undefined) {
                throw new RequiredError('validatorAddr','Required parameter validatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet.');
            }
            const localVarPath = `/staking/delegators/{delegatorAddr}/validators/{validatorAddr}`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)))
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the current staking parameter values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingParametersGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/staking/parameters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the current state of the staking pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingPoolGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/staking/pool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all redelegations (filter by query params)
         * @param {string} [delegator] Bech32 AccAddress of Delegator
         * @param {string} [validatorFrom] Bech32 ValAddress of SrcValidator
         * @param {string} [validatorTo] Bech32 ValAddress of DstValidator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingRedelegationsGet: async (delegator?: string, validatorFrom?: string, validatorTo?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/staking/redelegations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (delegator !== undefined) {
                localVarQueryParameter['delegator'] = delegator;
            }

            if (validatorFrom !== undefined) {
                localVarQueryParameter['validator_from'] = validatorFrom;
            }

            if (validatorTo !== undefined) {
                localVarQueryParameter['validator_to'] = validatorTo;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all validator candidates. By default it returns only the bonded validators.
         * @param {string} [status] The validator bond status. Must be either \&#39;bonded\&#39;, \&#39;unbonded\&#39;, or \&#39;unbonding\&#39;.
         * @param {number} [page] The page number.
         * @param {number} [limit] The maximum number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingValidatorsGet: async (status?: string, page?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/staking/validators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all delegations from a validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrDelegationsGet: async (validatorAddr: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddr' is not null or undefined
            if (validatorAddr === null || validatorAddr === undefined) {
                throw new RequiredError('validatorAddr','Required parameter validatorAddr was null or undefined when calling stakingValidatorsValidatorAddrDelegationsGet.');
            }
            const localVarPath = `/staking/validators/{validatorAddr}/delegations`
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query the information from a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrGet: async (validatorAddr: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddr' is not null or undefined
            if (validatorAddr === null || validatorAddr === undefined) {
                throw new RequiredError('validatorAddr','Required parameter validatorAddr was null or undefined when calling stakingValidatorsValidatorAddrGet.');
            }
            const localVarPath = `/staking/validators/{validatorAddr}`
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all unbonding delegations from a validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrUnbondingDelegationsGet: async (validatorAddr: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddr' is not null or undefined
            if (validatorAddr === null || validatorAddr === undefined) {
                throw new RequiredError('validatorAddr','Required parameter validatorAddr was null or undefined when calling stakingValidatorsValidatorAddrUnbondingDelegationsGet.');
            }
            const localVarPath = `/staking/validators/{validatorAddr}/unbonding_delegations`
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StakingApi - functional programming interface
 * @export
 */
export const StakingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all delegations from a delegator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingDelegatorsDelegatorAddrDelegationsGet(delegatorAddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2009>>> {
            const localVarAxiosArgs = await StakingApiAxiosParamCreator(configuration).stakingDelegatorsDelegatorAddrDelegationsGet(delegatorAddr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Submit delegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject4} [delegation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingDelegatorsDelegatorAddrDelegationsPost(delegatorAddr: string, delegation?: InlineObject4, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004Tx>> {
            const localVarAxiosArgs = await StakingApiAxiosParamCreator(configuration).stakingDelegatorsDelegatorAddrDelegationsPost(delegatorAddr, delegation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Query the current delegation between a delegator and a validator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(delegatorAddr: string, validatorAddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await StakingApiAxiosParamCreator(configuration).stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Submit a redelegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject6} [delegation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingDelegatorsDelegatorAddrRedelegationsPost(delegatorAddr: string, delegation?: InlineObject6, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004Tx>> {
            const localVarAxiosArgs = await StakingApiAxiosParamCreator(configuration).stakingDelegatorsDelegatorAddrRedelegationsPost(delegatorAddr, delegation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all unbonding delegations from a delegator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(delegatorAddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20010>>> {
            const localVarAxiosArgs = await StakingApiAxiosParamCreator(configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(delegatorAddr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Submit an unbonding delegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject5} [delegation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(delegatorAddr: string, delegation?: InlineObject5, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004Tx>> {
            const localVarAxiosArgs = await StakingApiAxiosParamCreator(configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(delegatorAddr, delegation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Query all unbonding delegations between a delegator and a validator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(delegatorAddr: string, validatorAddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await StakingApiAxiosParamCreator(configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Query all validators that a delegator is bonded to
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingDelegatorsDelegatorAddrValidatorsGet(delegatorAddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20012>>> {
            const localVarAxiosArgs = await StakingApiAxiosParamCreator(configuration).stakingDelegatorsDelegatorAddrValidatorsGet(delegatorAddr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Query a validator that a delegator is bonded to
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 ValAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(delegatorAddr: string, validatorAddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await StakingApiAxiosParamCreator(configuration).stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(delegatorAddr, validatorAddr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the current staking parameter values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingParametersGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await StakingApiAxiosParamCreator(configuration).stakingParametersGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the current state of the staking pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingPoolGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await StakingApiAxiosParamCreator(configuration).stakingPoolGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all redelegations (filter by query params)
         * @param {string} [delegator] Bech32 AccAddress of Delegator
         * @param {string} [validatorFrom] Bech32 ValAddress of SrcValidator
         * @param {string} [validatorTo] Bech32 ValAddress of DstValidator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingRedelegationsGet(delegator?: string, validatorFrom?: string, validatorTo?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Redelegation>>> {
            const localVarAxiosArgs = await StakingApiAxiosParamCreator(configuration).stakingRedelegationsGet(delegator, validatorFrom, validatorTo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all validator candidates. By default it returns only the bonded validators.
         * @param {string} [status] The validator bond status. Must be either \&#39;bonded\&#39;, \&#39;unbonded\&#39;, or \&#39;unbonding\&#39;.
         * @param {number} [page] The page number.
         * @param {number} [limit] The maximum number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingValidatorsGet(status?: string, page?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20012>>> {
            const localVarAxiosArgs = await StakingApiAxiosParamCreator(configuration).stakingValidatorsGet(status, page, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all delegations from a validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingValidatorsValidatorAddrDelegationsGet(validatorAddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2009>>> {
            const localVarAxiosArgs = await StakingApiAxiosParamCreator(configuration).stakingValidatorsValidatorAddrDelegationsGet(validatorAddr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Query the information from a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingValidatorsValidatorAddrGet(validatorAddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await StakingApiAxiosParamCreator(configuration).stakingValidatorsValidatorAddrGet(validatorAddr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all unbonding delegations from a validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingValidatorsValidatorAddrUnbondingDelegationsGet(validatorAddr: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20010>>> {
            const localVarAxiosArgs = await StakingApiAxiosParamCreator(configuration).stakingValidatorsValidatorAddrUnbondingDelegationsGet(validatorAddr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StakingApi - factory interface
 * @export
 */
export const StakingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get all delegations from a delegator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsGet(delegatorAddr: string, options?: any): AxiosPromise<Array<InlineResponse2009>> {
            return StakingApiFp(configuration).stakingDelegatorsDelegatorAddrDelegationsGet(delegatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit delegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject4} [delegation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsPost(delegatorAddr: string, delegation?: InlineObject4, options?: any): AxiosPromise<InlineResponse2004Tx> {
            return StakingApiFp(configuration).stakingDelegatorsDelegatorAddrDelegationsPost(delegatorAddr, delegation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query the current delegation between a delegator and a validator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(delegatorAddr: string, validatorAddr: string, options?: any): AxiosPromise<InlineResponse2009> {
            return StakingApiFp(configuration).stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit a redelegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject6} [delegation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrRedelegationsPost(delegatorAddr: string, delegation?: InlineObject6, options?: any): AxiosPromise<InlineResponse2004Tx> {
            return StakingApiFp(configuration).stakingDelegatorsDelegatorAddrRedelegationsPost(delegatorAddr, delegation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all unbonding delegations from a delegator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(delegatorAddr: string, options?: any): AxiosPromise<Array<InlineResponse20010>> {
            return StakingApiFp(configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(delegatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit an unbonding delegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject5} [delegation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(delegatorAddr: string, delegation?: InlineObject5, options?: any): AxiosPromise<InlineResponse2004Tx> {
            return StakingApiFp(configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(delegatorAddr, delegation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query all unbonding delegations between a delegator and a validator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(delegatorAddr: string, validatorAddr: string, options?: any): AxiosPromise<InlineResponse20011> {
            return StakingApiFp(configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query all validators that a delegator is bonded to
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrValidatorsGet(delegatorAddr: string, options?: any): AxiosPromise<Array<InlineResponse20012>> {
            return StakingApiFp(configuration).stakingDelegatorsDelegatorAddrValidatorsGet(delegatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query a validator that a delegator is bonded to
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 ValAddress of Delegator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(delegatorAddr: string, validatorAddr: string, options?: any): AxiosPromise<InlineResponse20012> {
            return StakingApiFp(configuration).stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(delegatorAddr, validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the current staking parameter values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingParametersGet(options?: any): AxiosPromise<InlineResponse20014> {
            return StakingApiFp(configuration).stakingParametersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the current state of the staking pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingPoolGet(options?: any): AxiosPromise<InlineResponse20013> {
            return StakingApiFp(configuration).stakingPoolGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all redelegations (filter by query params)
         * @param {string} [delegator] Bech32 AccAddress of Delegator
         * @param {string} [validatorFrom] Bech32 ValAddress of SrcValidator
         * @param {string} [validatorTo] Bech32 ValAddress of DstValidator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingRedelegationsGet(delegator?: string, validatorFrom?: string, validatorTo?: string, options?: any): AxiosPromise<Array<Redelegation>> {
            return StakingApiFp(configuration).stakingRedelegationsGet(delegator, validatorFrom, validatorTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all validator candidates. By default it returns only the bonded validators.
         * @param {string} [status] The validator bond status. Must be either \&#39;bonded\&#39;, \&#39;unbonded\&#39;, or \&#39;unbonding\&#39;.
         * @param {number} [page] The page number.
         * @param {number} [limit] The maximum number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingValidatorsGet(status?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<InlineResponse20012>> {
            return StakingApiFp(configuration).stakingValidatorsGet(status, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all delegations from a validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrDelegationsGet(validatorAddr: string, options?: any): AxiosPromise<Array<InlineResponse2009>> {
            return StakingApiFp(configuration).stakingValidatorsValidatorAddrDelegationsGet(validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query the information from a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrGet(validatorAddr: string, options?: any): AxiosPromise<InlineResponse20012> {
            return StakingApiFp(configuration).stakingValidatorsValidatorAddrGet(validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all unbonding delegations from a validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrUnbondingDelegationsGet(validatorAddr: string, options?: any): AxiosPromise<Array<InlineResponse20010>> {
            return StakingApiFp(configuration).stakingValidatorsValidatorAddrUnbondingDelegationsGet(validatorAddr, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StakingApi - object-oriented interface
 * @export
 * @class StakingApi
 * @extends {BaseAPI}
 */
export class StakingApi extends BaseAPI {
    /**
     * 
     * @summary Get all delegations from a delegator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public stakingDelegatorsDelegatorAddrDelegationsGet(delegatorAddr: string, options?: any) {
        return StakingApiFp(this.configuration).stakingDelegatorsDelegatorAddrDelegationsGet(delegatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit delegation
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {InlineObject4} [delegation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public stakingDelegatorsDelegatorAddrDelegationsPost(delegatorAddr: string, delegation?: InlineObject4, options?: any) {
        return StakingApiFp(this.configuration).stakingDelegatorsDelegatorAddrDelegationsPost(delegatorAddr, delegation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query the current delegation between a delegator and a validator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(delegatorAddr: string, validatorAddr: string, options?: any) {
        return StakingApiFp(this.configuration).stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit a redelegation
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {InlineObject6} [delegation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public stakingDelegatorsDelegatorAddrRedelegationsPost(delegatorAddr: string, delegation?: InlineObject6, options?: any) {
        return StakingApiFp(this.configuration).stakingDelegatorsDelegatorAddrRedelegationsPost(delegatorAddr, delegation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all unbonding delegations from a delegator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(delegatorAddr: string, options?: any) {
        return StakingApiFp(this.configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(delegatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit an unbonding delegation
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {InlineObject5} [delegation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(delegatorAddr: string, delegation?: InlineObject5, options?: any) {
        return StakingApiFp(this.configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(delegatorAddr, delegation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query all unbonding delegations between a delegator and a validator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(delegatorAddr: string, validatorAddr: string, options?: any) {
        return StakingApiFp(this.configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query all validators that a delegator is bonded to
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public stakingDelegatorsDelegatorAddrValidatorsGet(delegatorAddr: string, options?: any) {
        return StakingApiFp(this.configuration).stakingDelegatorsDelegatorAddrValidatorsGet(delegatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query a validator that a delegator is bonded to
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 ValAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(delegatorAddr: string, validatorAddr: string, options?: any) {
        return StakingApiFp(this.configuration).stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(delegatorAddr, validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the current staking parameter values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public stakingParametersGet(options?: any) {
        return StakingApiFp(this.configuration).stakingParametersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the current state of the staking pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public stakingPoolGet(options?: any) {
        return StakingApiFp(this.configuration).stakingPoolGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all redelegations (filter by query params)
     * @param {string} [delegator] Bech32 AccAddress of Delegator
     * @param {string} [validatorFrom] Bech32 ValAddress of SrcValidator
     * @param {string} [validatorTo] Bech32 ValAddress of DstValidator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public stakingRedelegationsGet(delegator?: string, validatorFrom?: string, validatorTo?: string, options?: any) {
        return StakingApiFp(this.configuration).stakingRedelegationsGet(delegator, validatorFrom, validatorTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all validator candidates. By default it returns only the bonded validators.
     * @param {string} [status] The validator bond status. Must be either \&#39;bonded\&#39;, \&#39;unbonded\&#39;, or \&#39;unbonding\&#39;.
     * @param {number} [page] The page number.
     * @param {number} [limit] The maximum number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public stakingValidatorsGet(status?: string, page?: number, limit?: number, options?: any) {
        return StakingApiFp(this.configuration).stakingValidatorsGet(status, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all delegations from a validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public stakingValidatorsValidatorAddrDelegationsGet(validatorAddr: string, options?: any) {
        return StakingApiFp(this.configuration).stakingValidatorsValidatorAddrDelegationsGet(validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query the information from a single validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public stakingValidatorsValidatorAddrGet(validatorAddr: string, options?: any) {
        return StakingApiFp(this.configuration).stakingValidatorsValidatorAddrGet(validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all unbonding delegations from a validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public stakingValidatorsValidatorAddrUnbondingDelegationsGet(validatorAddr: string, options?: any) {
        return StakingApiFp(this.configuration).stakingValidatorsValidatorAddrUnbondingDelegationsGet(validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SupplyApi - axios parameter creator
 * @export
 */
export const SupplyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Total supply of a single coin denomination
         * @param {string} denomination Coin denomination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplyTotalDenominationGet: async (denomination: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'denomination' is not null or undefined
            if (denomination === null || denomination === undefined) {
                throw new RequiredError('denomination','Required parameter denomination was null or undefined when calling supplyTotalDenominationGet.');
            }
            const localVarPath = `/supply/total/{denomination}`
                .replace(`{${"denomination"}}`, encodeURIComponent(String(denomination)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Total supply of coins in the chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplyTotalGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/supply/total`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SupplyApi - functional programming interface
 * @export
 */
export const SupplyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Total supply of a single coin denomination
         * @param {string} denomination Coin denomination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplyTotalDenominationGet(denomination: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SupplyApiAxiosParamCreator(configuration).supplyTotalDenominationGet(denomination, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Total supply of coins in the chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplyTotalGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await SupplyApiAxiosParamCreator(configuration).supplyTotalGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SupplyApi - factory interface
 * @export
 */
export const SupplyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Total supply of a single coin denomination
         * @param {string} denomination Coin denomination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplyTotalDenominationGet(denomination: string, options?: any): AxiosPromise<string> {
            return SupplyApiFp(configuration).supplyTotalDenominationGet(denomination, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Total supply of coins in the chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplyTotalGet(options?: any): AxiosPromise<InlineResponse20024> {
            return SupplyApiFp(configuration).supplyTotalGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SupplyApi - object-oriented interface
 * @export
 * @class SupplyApi
 * @extends {BaseAPI}
 */
export class SupplyApi extends BaseAPI {
    /**
     * 
     * @summary Total supply of a single coin denomination
     * @param {string} denomination Coin denomination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplyApi
     */
    public supplyTotalDenominationGet(denomination: string, options?: any) {
        return SupplyApiFp(this.configuration).supplyTotalDenominationGet(denomination, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Total supply of coins in the chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplyApi
     */
    public supplyTotalGet(options?: any) {
        return SupplyApiFp(this.configuration).supplyTotalGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TendermintRPCApi - axios parameter creator
 * @export
 */
export const TendermintRPCApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a block at a certain height
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksHeightGet: async (height: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            if (height === null || height === undefined) {
                throw new RequiredError('height','Required parameter height was null or undefined when calling blocksHeightGet.');
            }
            const localVarPath = `/blocks/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the latest block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksLatestGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/blocks/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get if the node is currently syning with other nodes
         * @summary Syncing state of node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncingGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/syncing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a validator set a certain height
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsetsHeightGet: async (height: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            if (height === null || height === undefined) {
                throw new RequiredError('height','Required parameter height was null or undefined when calling validatorsetsHeightGet.');
            }
            const localVarPath = `/validatorsets/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the latest validator set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsetsLatestGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/validatorsets/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TendermintRPCApi - functional programming interface
 * @export
 */
export const TendermintRPCApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a block at a certain height
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blocksHeightGet(height: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await TendermintRPCApiAxiosParamCreator(configuration).blocksHeightGet(height, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the latest block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blocksLatestGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await TendermintRPCApiAxiosParamCreator(configuration).blocksLatestGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get if the node is currently syning with other nodes
         * @summary Syncing state of node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncingGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await TendermintRPCApiAxiosParamCreator(configuration).syncingGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a validator set a certain height
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorsetsHeightGet(height: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await TendermintRPCApiAxiosParamCreator(configuration).validatorsetsHeightGet(height, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the latest validator set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorsetsLatestGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await TendermintRPCApiAxiosParamCreator(configuration).validatorsetsLatestGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TendermintRPCApi - factory interface
 * @export
 */
export const TendermintRPCApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get a block at a certain height
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksHeightGet(height: number, options?: any): AxiosPromise<InlineResponse2002> {
            return TendermintRPCApiFp(configuration).blocksHeightGet(height, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the latest block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksLatestGet(options?: any): AxiosPromise<InlineResponse2002> {
            return TendermintRPCApiFp(configuration).blocksLatestGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get if the node is currently syning with other nodes
         * @summary Syncing state of node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncingGet(options?: any): AxiosPromise<InlineResponse2001> {
            return TendermintRPCApiFp(configuration).syncingGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a validator set a certain height
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsetsHeightGet(height: number, options?: any): AxiosPromise<InlineResponse2003> {
            return TendermintRPCApiFp(configuration).validatorsetsHeightGet(height, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the latest validator set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsetsLatestGet(options?: any): AxiosPromise<InlineResponse2003> {
            return TendermintRPCApiFp(configuration).validatorsetsLatestGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TendermintRPCApi - object-oriented interface
 * @export
 * @class TendermintRPCApi
 * @extends {BaseAPI}
 */
export class TendermintRPCApi extends BaseAPI {
    /**
     * 
     * @summary Get a block at a certain height
     * @param {number} height Block height
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TendermintRPCApi
     */
    public blocksHeightGet(height: number, options?: any) {
        return TendermintRPCApiFp(this.configuration).blocksHeightGet(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the latest block
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TendermintRPCApi
     */
    public blocksLatestGet(options?: any) {
        return TendermintRPCApiFp(this.configuration).blocksLatestGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get if the node is currently syning with other nodes
     * @summary Syncing state of node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TendermintRPCApi
     */
    public syncingGet(options?: any) {
        return TendermintRPCApiFp(this.configuration).syncingGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a validator set a certain height
     * @param {number} height Block height
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TendermintRPCApi
     */
    public validatorsetsHeightGet(height: number, options?: any) {
        return TendermintRPCApiFp(this.configuration).validatorsetsHeightGet(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the latest validator set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TendermintRPCApi
     */
    public validatorsetsLatestGet(options?: any) {
        return TendermintRPCApiFp(this.configuration).validatorsetsLatestGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Decode a transaction (signed or not) from base64-encoded Amino serialized bytes to JSON
         * @summary Decode a transaction from the Amino wire format
         * @param {InlineObject2} tx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsDecodePost: async (tx: InlineObject2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tx' is not null or undefined
            if (tx === null || tx === undefined) {
                throw new RequiredError('tx','Required parameter tx was null or undefined when calling txsDecodePost.');
            }
            const localVarPath = `/txs/decode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof tx !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(tx !== undefined ? tx : {})
                : (tx || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Encode a transaction (signed or not) from JSON to base64-encoded Amino serialized bytes
         * @summary Encode a transaction to the Amino wire format
         * @param {InlineObject1} tx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsEncodePost: async (tx: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tx' is not null or undefined
            if (tx === null || tx === undefined) {
                throw new RequiredError('tx','Required parameter tx was null or undefined when calling txsEncodePost.');
            }
            const localVarPath = `/txs/encode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof tx !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(tx !== undefined ? tx : {})
                : (tx || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Search transactions by events.
         * @summary Search transactions
         * @param {string} [messageAction] transaction events such as \&#39;message.action&#x3D;send\&#39; which results in the following endpoint: \&#39;GET /txs?message.action&#x3D;send\&#39;. note that each module documents its own events. look for xx_events.md in the corresponding cosmos-sdk/docs/spec directory
         * @param {string} [messageSender] transaction tags with sender: \&#39;GET /txs?message.action&#x3D;send&amp;message.sender&#x3D;cosmos16xyempempp92x9hyzz9wrgf94r6j9h5f06pxxv\&#39;
         * @param {number} [page] Page number
         * @param {number} [limit] Maximum number of items per page
         * @param {number} [txMinheight] transactions on blocks with height greater or equal this value
         * @param {number} [txMaxheight] transactions on blocks with height less than or equal this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsGet: async (messageAction?: string, messageSender?: string, page?: number, limit?: number, txMinheight?: number, txMaxheight?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/txs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (messageAction !== undefined) {
                localVarQueryParameter['message.action'] = messageAction;
            }

            if (messageSender !== undefined) {
                localVarQueryParameter['message.sender'] = messageSender;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (txMinheight !== undefined) {
                localVarQueryParameter['tx.minheight'] = txMinheight;
            }

            if (txMaxheight !== undefined) {
                localVarQueryParameter['tx.maxheight'] = txMaxheight;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a transaction using its hash.
         * @summary Get a Tx by hash
         * @param {string} hash Tx hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsHashGet: async (hash: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling txsHashGet.');
            }
            const localVarPath = `/txs/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Broadcast a signed tx to a full node
         * @summary Broadcast a signed tx
         * @param {InlineObject} txBroadcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsPost: async (txBroadcast: InlineObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'txBroadcast' is not null or undefined
            if (txBroadcast === null || txBroadcast === undefined) {
                throw new RequiredError('txBroadcast','Required parameter txBroadcast was null or undefined when calling txsPost.');
            }
            const localVarPath = `/txs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof txBroadcast !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(txBroadcast !== undefined ? txBroadcast : {})
                : (txBroadcast || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Decode a transaction (signed or not) from base64-encoded Amino serialized bytes to JSON
         * @summary Decode a transaction from the Amino wire format
         * @param {InlineObject2} tx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txsDecodePost(tx: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004Tx>> {
            const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(configuration).txsDecodePost(tx, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Encode a transaction (signed or not) from JSON to base64-encoded Amino serialized bytes
         * @summary Encode a transaction to the Amino wire format
         * @param {InlineObject1} tx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txsEncodePost(tx: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(configuration).txsEncodePost(tx, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Search transactions by events.
         * @summary Search transactions
         * @param {string} [messageAction] transaction events such as \&#39;message.action&#x3D;send\&#39; which results in the following endpoint: \&#39;GET /txs?message.action&#x3D;send\&#39;. note that each module documents its own events. look for xx_events.md in the corresponding cosmos-sdk/docs/spec directory
         * @param {string} [messageSender] transaction tags with sender: \&#39;GET /txs?message.action&#x3D;send&amp;message.sender&#x3D;cosmos16xyempempp92x9hyzz9wrgf94r6j9h5f06pxxv\&#39;
         * @param {number} [page] Page number
         * @param {number} [limit] Maximum number of items per page
         * @param {number} [txMinheight] transactions on blocks with height greater or equal this value
         * @param {number} [txMaxheight] transactions on blocks with height less than or equal this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txsGet(messageAction?: string, messageSender?: string, page?: number, limit?: number, txMinheight?: number, txMaxheight?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(configuration).txsGet(messageAction, messageSender, page, limit, txMinheight, txMaxheight, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a transaction using its hash.
         * @summary Get a Tx by hash
         * @param {string} hash Tx hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txsHashGet(hash: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(configuration).txsHashGet(hash, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Broadcast a signed tx to a full node
         * @summary Broadcast a signed tx
         * @param {InlineObject} txBroadcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txsPost(txBroadcast: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await TransactionsApiAxiosParamCreator(configuration).txsPost(txBroadcast, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Decode a transaction (signed or not) from base64-encoded Amino serialized bytes to JSON
         * @summary Decode a transaction from the Amino wire format
         * @param {InlineObject2} tx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsDecodePost(tx: InlineObject2, options?: any): AxiosPromise<InlineResponse2004Tx> {
            return TransactionsApiFp(configuration).txsDecodePost(tx, options).then((request) => request(axios, basePath));
        },
        /**
         * Encode a transaction (signed or not) from JSON to base64-encoded Amino serialized bytes
         * @summary Encode a transaction to the Amino wire format
         * @param {InlineObject1} tx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsEncodePost(tx: InlineObject1, options?: any): AxiosPromise<InlineResponse2007> {
            return TransactionsApiFp(configuration).txsEncodePost(tx, options).then((request) => request(axios, basePath));
        },
        /**
         * Search transactions by events.
         * @summary Search transactions
         * @param {string} [messageAction] transaction events such as \&#39;message.action&#x3D;send\&#39; which results in the following endpoint: \&#39;GET /txs?message.action&#x3D;send\&#39;. note that each module documents its own events. look for xx_events.md in the corresponding cosmos-sdk/docs/spec directory
         * @param {string} [messageSender] transaction tags with sender: \&#39;GET /txs?message.action&#x3D;send&amp;message.sender&#x3D;cosmos16xyempempp92x9hyzz9wrgf94r6j9h5f06pxxv\&#39;
         * @param {number} [page] Page number
         * @param {number} [limit] Maximum number of items per page
         * @param {number} [txMinheight] transactions on blocks with height greater or equal this value
         * @param {number} [txMaxheight] transactions on blocks with height less than or equal this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsGet(messageAction?: string, messageSender?: string, page?: number, limit?: number, txMinheight?: number, txMaxheight?: number, options?: any): AxiosPromise<InlineResponse2005> {
            return TransactionsApiFp(configuration).txsGet(messageAction, messageSender, page, limit, txMinheight, txMaxheight, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a transaction using its hash.
         * @summary Get a Tx by hash
         * @param {string} hash Tx hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsHashGet(hash: string, options?: any): AxiosPromise<InlineResponse2004> {
            return TransactionsApiFp(configuration).txsHashGet(hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Broadcast a signed tx to a full node
         * @summary Broadcast a signed tx
         * @param {InlineObject} txBroadcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsPost(txBroadcast: InlineObject, options?: any): AxiosPromise<InlineResponse2006> {
            return TransactionsApiFp(configuration).txsPost(txBroadcast, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Decode a transaction (signed or not) from base64-encoded Amino serialized bytes to JSON
     * @summary Decode a transaction from the Amino wire format
     * @param {InlineObject2} tx 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public txsDecodePost(tx: InlineObject2, options?: any) {
        return TransactionsApiFp(this.configuration).txsDecodePost(tx, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Encode a transaction (signed or not) from JSON to base64-encoded Amino serialized bytes
     * @summary Encode a transaction to the Amino wire format
     * @param {InlineObject1} tx 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public txsEncodePost(tx: InlineObject1, options?: any) {
        return TransactionsApiFp(this.configuration).txsEncodePost(tx, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search transactions by events.
     * @summary Search transactions
     * @param {string} [messageAction] transaction events such as \&#39;message.action&#x3D;send\&#39; which results in the following endpoint: \&#39;GET /txs?message.action&#x3D;send\&#39;. note that each module documents its own events. look for xx_events.md in the corresponding cosmos-sdk/docs/spec directory
     * @param {string} [messageSender] transaction tags with sender: \&#39;GET /txs?message.action&#x3D;send&amp;message.sender&#x3D;cosmos16xyempempp92x9hyzz9wrgf94r6j9h5f06pxxv\&#39;
     * @param {number} [page] Page number
     * @param {number} [limit] Maximum number of items per page
     * @param {number} [txMinheight] transactions on blocks with height greater or equal this value
     * @param {number} [txMaxheight] transactions on blocks with height less than or equal this value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public txsGet(messageAction?: string, messageSender?: string, page?: number, limit?: number, txMinheight?: number, txMaxheight?: number, options?: any) {
        return TransactionsApiFp(this.configuration).txsGet(messageAction, messageSender, page, limit, txMinheight, txMaxheight, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a transaction using its hash.
     * @summary Get a Tx by hash
     * @param {string} hash Tx hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public txsHashGet(hash: string, options?: any) {
        return TransactionsApiFp(this.configuration).txsHashGet(hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Broadcast a signed tx to a full node
     * @summary Broadcast a signed tx
     * @param {InlineObject} txBroadcast 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public txsPost(txBroadcast: InlineObject, options?: any) {
        return TransactionsApiFp(this.configuration).txsPost(txBroadcast, options).then((request) => request(this.axios, this.basePath));
    }
}


